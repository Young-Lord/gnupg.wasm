# 1 "parse-packet.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 363 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "parse-packet.c" 2
# 21 "parse-packet.c"
# 1 "../config.h" 1
# 22 "parse-packet.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 1 3




# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 1 3
# 29 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 1 3
# 84 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_header_macro.h" 1 3
# 85 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3



# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 89 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_size_t.h" 1 3
# 18 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 94 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 103 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_wchar_t.h" 1 3
# 24 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_wchar_t.h" 3
typedef int wchar_t;
# 104 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_null.h" 1 3
# 109 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 123 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_max_align_t.h" 1 3
# 19 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 124 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_offsetof.h" 1 3
# 129 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 30 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 2 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 1 3
# 56 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 1 3
# 20 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 146 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long int uintptr_t;
# 161 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int intptr_t;
# 177 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef signed char int8_t;




typedef short int16_t;




typedef int int32_t;




typedef long long int int64_t;




typedef long long int intmax_t;




typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long int uint64_t;
# 227 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int uintmax_t;
# 21 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 2 3

typedef int8_t int_fast8_t;
typedef int64_t int_fast64_t;

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;

typedef uint8_t uint_fast8_t;
typedef uint64_t uint_fast64_t;

typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
# 95 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/stdint.h" 1 3
typedef int32_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef uint32_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
# 96 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 2 3
# 57 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 2 3
# 31 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 2 3





                                                             ;
                                                              ;
                                                              ;
                                                               ;
                                                              ;
                                                               ;
                                                              ;
                                                               ;
                                                            ;







typedef long unsigned int __wasi_size_t;

                                                                  ;
                                                                     ;




typedef uint64_t __wasi_filesize_t;

                                                                      ;
                                                                         ;




typedef uint64_t __wasi_timestamp_t;

                                                                       ;
                                                                          ;




typedef uint32_t __wasi_clockid_t;
# 102 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;







typedef uint16_t __wasi_errno_t;
# 498 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                   ;
                                                                      ;




typedef uint64_t __wasi_rights_t;
# 663 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint32_t __wasi_fd_t;

                                                                ;
                                                                   ;




typedef struct __wasi_iovec_t {



    uint8_t * buf;




    __wasi_size_t buf_len;

} __wasi_iovec_t;

                                                                   ;
                                                                      ;
                                                                            ;
                                                                                ;




typedef struct __wasi_ciovec_t {



    const uint8_t * buf;




    __wasi_size_t buf_len;

} __wasi_ciovec_t;

                                                                    ;
                                                                       ;
                                                                             ;
                                                                                 ;




typedef int64_t __wasi_filedelta_t;

                                                                       ;
                                                                          ;




typedef uint8_t __wasi_whence_t;
# 744 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;






typedef uint64_t __wasi_dircookie_t;

                                                                       ;
                                                                          ;




typedef uint32_t __wasi_dirnamlen_t;

                                                                       ;
                                                                          ;




typedef uint64_t __wasi_inode_t;

                                                                   ;
                                                                      ;




typedef uint8_t __wasi_filetype_t;
# 818 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                      ;
                                                                         ;




typedef struct __wasi_dirent_t {



    __wasi_dircookie_t d_next;




    __wasi_inode_t d_ino;




    __wasi_dirnamlen_t d_namlen;




    __wasi_filetype_t d_type;

} __wasi_dirent_t;

                                                                     ;
                                                                       ;
                                                                                ;
                                                                               ;
                                                                                   ;
                                                                                 ;




typedef uint8_t __wasi_advice_t;
# 889 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint16_t __wasi_fdflags_t;
# 924 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef struct __wasi_fdstat_t {



    __wasi_filetype_t fs_filetype;




    __wasi_fdflags_t fs_flags;




    __wasi_rights_t fs_rights_base;





    __wasi_rights_t fs_rights_inheriting;

} __wasi_fdstat_t;

                                                                     ;
                                                                       ;
                                                                                     ;
                                                                                  ;
                                                                                        ;
                                                                                               ;





typedef uint64_t __wasi_device_t;

                                                                    ;
                                                                       ;




typedef uint16_t __wasi_fstflags_t;
# 995 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                      ;
                                                                         ;




typedef uint32_t __wasi_lookupflags_t;






                                                                         ;
                                                                            ;




typedef uint16_t __wasi_oflags_t;
# 1036 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint64_t __wasi_linkcount_t;

                                                                       ;
                                                                          ;




typedef struct __wasi_filestat_t {



    __wasi_device_t dev;




    __wasi_inode_t ino;




    __wasi_filetype_t filetype;




    __wasi_linkcount_t nlink;




    __wasi_filesize_t size;




    __wasi_timestamp_t atim;




    __wasi_timestamp_t mtim;




    __wasi_timestamp_t ctim;

} __wasi_filestat_t;

                                                                       ;
                                                                         ;
                                                                               ;
                                                                               ;
                                                                                     ;
                                                                                  ;
                                                                                 ;
                                                                                 ;
                                                                                 ;
                                                                                 ;





typedef uint64_t __wasi_userdata_t;

                                                                      ;
                                                                         ;




typedef uint8_t __wasi_eventtype_t;
# 1136 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                       ;
                                                                          ;





typedef uint16_t __wasi_eventrwflags_t;






                                                                          ;
                                                                             ;





typedef struct __wasi_event_fd_readwrite_t {



    __wasi_filesize_t nbytes;




    __wasi_eventrwflags_t flags;

} __wasi_event_fd_readwrite_t;

                                                                                 ;
                                                                                   ;
                                                                                            ;
                                                                                           ;




typedef union __wasi_event_u_t {



    __wasi_event_fd_readwrite_t fd_readwrite;

} __wasi_event_u_t;

                                                                      ;
                                                                        ;




typedef struct __wasi_event_t {



    __wasi_userdata_t userdata;




    __wasi_errno_t error;




    __wasi_eventtype_t type;




    __wasi_event_u_t u;

} __wasi_event_t;

                                                                    ;
                                                                      ;
                                                                                 ;
                                                                              ;
                                                                              ;
                                                                           ;





typedef uint16_t __wasi_subclockflags_t;
# 1237 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                           ;
                                                                              ;




typedef struct __wasi_subscription_clock_t {



    __wasi_clockid_t id;




    __wasi_timestamp_t timeout;





    __wasi_timestamp_t precision;




    __wasi_subclockflags_t flags;

} __wasi_subscription_clock_t;

                                                                                 ;
                                                                                   ;
                                                                                        ;
                                                                                             ;
                                                                                                ;
                                                                                            ;





typedef struct __wasi_subscription_fd_readwrite_t {



    __wasi_fd_t file_descriptor;

} __wasi_subscription_fd_readwrite_t;

                                                                                       ;
                                                                                          ;
                                                                                                            ;




typedef union __wasi_subscription_u_t {



    __wasi_subscription_clock_t clock;




    __wasi_subscription_fd_readwrite_t fd_readwrite;

} __wasi_subscription_u_t;

                                                                             ;
                                                                               ;




typedef struct __wasi_subscription_t {




    __wasi_userdata_t userdata;




    __wasi_eventtype_t type;




    __wasi_subscription_u_t u;

} __wasi_subscription_t;

                                                                           ;
                                                                             ;
                                                                                        ;
                                                                                    ;
                                                                                  ;




typedef uint32_t __wasi_exitcode_t;

                                                                      ;
                                                                         ;




typedef uint8_t __wasi_signal_t;
# 1536 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint16_t __wasi_riflags_t;
# 1554 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef uint16_t __wasi_roflags_t;






                                                                     ;
                                                                        ;





typedef uint16_t __wasi_siflags_t;

                                                                     ;
                                                                        ;




typedef uint8_t __wasi_sdflags_t;
# 1594 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef uint8_t __wasi_preopentype_t;






                                                                         ;
                                                                            ;




typedef struct __wasi_prestat_dir_t {



    __wasi_size_t pr_name_len;

} __wasi_prestat_dir_t;

                                                                         ;
                                                                            ;
                                                                                          ;




typedef union __wasi_prestat_u_t {



    __wasi_prestat_dir_t dir;

} __wasi_prestat_u_t;

                                                                       ;
                                                                          ;




typedef struct __wasi_prestat_t {



    __wasi_preopentype_t pr_type;




    __wasi_prestat_u_t u;

} __wasi_prestat_t;

                                                                     ;
                                                                        ;
                                                                                  ;
                                                                            ;
# 1669 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_args_get(
    uint8_t * * argv,

    uint8_t * argv_buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("args_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_args_sizes_get(



    __wasi_size_t *argc,



    __wasi_size_t *argv_buf_size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("args_sizes_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_environ_get(
    uint8_t * * environ,

    uint8_t * environ_buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("environ_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_environ_sizes_get(



    __wasi_size_t *argc,



    __wasi_size_t *argv_buf_size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("environ_sizes_get"),
    __warn_unused_result__
));







__wasi_errno_t __wasi_clock_res_get(



    __wasi_clockid_t id,




    __wasi_timestamp_t *resolution
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("clock_res_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_clock_time_get(



    __wasi_clockid_t id,




    __wasi_timestamp_t precision,




    __wasi_timestamp_t *time
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("clock_time_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_advise(
    __wasi_fd_t fd,




    __wasi_filesize_t offset,




    __wasi_filesize_t len,




    __wasi_advice_t advice
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_advise"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_allocate(
    __wasi_fd_t fd,




    __wasi_filesize_t offset,




    __wasi_filesize_t len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_allocate"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_close(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_close"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_datasync(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_datasync"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_get(
    __wasi_fd_t fd,




    __wasi_fdstat_t *stat
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_set_flags(
    __wasi_fd_t fd,




    __wasi_fdflags_t flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_set_flags"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_set_rights(
    __wasi_fd_t fd,




    __wasi_rights_t fs_rights_base,

    __wasi_rights_t fs_rights_inheriting
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_set_rights"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_filestat_get(
    __wasi_fd_t fd,




    __wasi_filestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_filestat_set_size(
    __wasi_fd_t fd,




    __wasi_filesize_t size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_set_size"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_filestat_set_times(
    __wasi_fd_t fd,




    __wasi_timestamp_t atim,




    __wasi_timestamp_t mtim,




    __wasi_fstflags_t fst_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_set_times"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_pread(
    __wasi_fd_t fd,




    const __wasi_iovec_t *iovs,




    size_t iovs_len,




    __wasi_filesize_t offset,




    __wasi_size_t *nread
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_pread"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_prestat_get(
    __wasi_fd_t fd,




    __wasi_prestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_prestat_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_prestat_dir_name(
    __wasi_fd_t fd,




    uint8_t * path,

    __wasi_size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_prestat_dir_name"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_pwrite(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *iovs,




    size_t iovs_len,




    __wasi_filesize_t offset,




    __wasi_size_t *nwritten
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_pwrite"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_read(
    __wasi_fd_t fd,




    const __wasi_iovec_t *iovs,




    size_t iovs_len,




    __wasi_size_t *nread
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_read"),
    __warn_unused_result__
));
# 2098 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_fd_readdir(
    __wasi_fd_t fd,




    uint8_t * buf,

    __wasi_size_t buf_len,




    __wasi_dircookie_t cookie,




    __wasi_size_t *bufused
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_readdir"),
    __warn_unused_result__
));
# 2133 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_fd_renumber(
    __wasi_fd_t fd,




    __wasi_fd_t to
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_renumber"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_seek(
    __wasi_fd_t fd,




    __wasi_filedelta_t offset,




    __wasi_whence_t whence,




    __wasi_filesize_t *newoffset
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_seek"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_sync(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_sync"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_tell(
    __wasi_fd_t fd,




    __wasi_filesize_t *offset
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_tell"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_write(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *iovs,




    size_t iovs_len,




    __wasi_size_t *nwritten
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_write"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_create_directory(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_create_directory"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_filestat_get(
    __wasi_fd_t fd,




    __wasi_lookupflags_t flags,




    const char *path,




    size_t path_len,




    __wasi_filestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_filestat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_filestat_set_times(
    __wasi_fd_t fd,




    __wasi_lookupflags_t flags,




    const char *path,




    size_t path_len,




    __wasi_timestamp_t atim,




    __wasi_timestamp_t mtim,




    __wasi_fstflags_t fst_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_filestat_set_times"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_link(
    __wasi_fd_t old_fd,




    __wasi_lookupflags_t old_flags,




    const char *old_path,




    size_t old_path_len,




    __wasi_fd_t new_fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_link"),
    __warn_unused_result__
));
# 2376 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_path_open(
    __wasi_fd_t fd,




    __wasi_lookupflags_t dirflags,





    const char *path,




    size_t path_len,




    __wasi_oflags_t oflags,
# 2409 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
    __wasi_rights_t fs_rights_base,

    __wasi_rights_t fs_rights_inherting,

    __wasi_fdflags_t fdflags,




    __wasi_fd_t *opened_fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_open"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_readlink(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len,




    uint8_t * buf,

    __wasi_size_t buf_len,




    __wasi_size_t *bufused
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_readlink"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_path_remove_directory(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_remove_directory"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_rename(
    __wasi_fd_t fd,




    const char *old_path,




    size_t old_path_len,




    __wasi_fd_t new_fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_rename"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_symlink(



    const char *old_path,




    size_t old_path_len,

    __wasi_fd_t fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_symlink"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_path_unlink_file(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_unlink_file"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_poll_oneoff(



    const __wasi_subscription_t * in,




    __wasi_event_t * out,




    __wasi_size_t nsubscriptions,




    __wasi_size_t *nevents
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("poll_oneoff"),
    __warn_unused_result__
));






_Noreturn void __wasi_proc_exit(



    __wasi_exitcode_t rval
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("proc_exit")));





__wasi_errno_t __wasi_proc_raise(



    __wasi_signal_t sig
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("proc_raise"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_sched_yield(
    void
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sched_yield"),
    __warn_unused_result__
));
# 2652 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_random_get(



    uint8_t * buf,

    __wasi_size_t buf_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("random_get"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_sock_recv(
    __wasi_fd_t fd,




    const __wasi_iovec_t *ri_data,




    size_t ri_data_len,




    __wasi_riflags_t ri_flags,




    __wasi_size_t *ro_datalen,



    __wasi_roflags_t *ro_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_recv"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_sock_send(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *si_data,




    size_t si_data_len,




    __wasi_siflags_t si_flags,




    __wasi_size_t *so_datalen
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_send"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_sock_shutdown(
    __wasi_fd_t fd,




    __wasi_sdflags_t how
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_shutdown"),
    __warn_unused_result__
));
# 6 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 2 3






# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/features.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 2 3
# 30 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef __builtin_va_list va_list;




typedef __builtin_va_list __isoc_va_list;
# 141 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long int size_t;
# 156 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int ssize_t;
# 243 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long long int off_t;
# 400 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct _IO_FILE FILE;
# 31 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 2 3
# 66 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 3
typedef union _G_fpos64_t {
 char __opaque[16];
 long long __lldata;
 double __align;
} fpos_t;

extern FILE *const stdin;
extern FILE *const stdout;
extern FILE *const stderr;





FILE *fopen(const char *restrict, const char *restrict);
FILE *freopen(const char *restrict, const char *restrict, FILE *restrict);
int fclose(FILE *);

int remove(const char *);
int rename(const char *, const char *);

int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
void clearerr(FILE *);

int fseek(FILE *, long, int);
long ftell(FILE *);
void rewind(FILE *);

int fgetpos(FILE *restrict, fpos_t *restrict);
int fsetpos(FILE *, const fpos_t *);

size_t fread(void *restrict, size_t, size_t, FILE *restrict);
size_t fwrite(const void *restrict, size_t, size_t, FILE *restrict);

int fgetc(FILE *);
int getc(FILE *);
int getchar(void);
int ungetc(int, FILE *);

int fputc(int, FILE *);
int putc(int, FILE *);
int putchar(int);

char *fgets(char *restrict, int, FILE *restrict);




int fputs(const char *restrict, FILE *restrict);
int puts(const char *);

int printf(const char *restrict, ...);
int fprintf(FILE *restrict, const char *restrict, ...);
int sprintf(char *restrict, const char *restrict, ...);
int snprintf(char *restrict, size_t, const char *restrict, ...);

int vprintf(const char *restrict, __isoc_va_list);
int vfprintf(FILE *restrict, const char *restrict, __isoc_va_list);
int vsprintf(char *restrict, const char *restrict, __isoc_va_list);
int vsnprintf(char *restrict, size_t, const char *restrict, __isoc_va_list);

int scanf(const char *restrict, ...);
int fscanf(FILE *restrict, const char *restrict, ...);
int sscanf(const char *restrict, const char *restrict, ...);
int vscanf(const char *restrict, __isoc_va_list);
int vfscanf(FILE *restrict, const char *restrict, __isoc_va_list);
int vsscanf(const char *restrict, const char *restrict, __isoc_va_list);

void perror(const char *);

int setvbuf(FILE *restrict, char *restrict, int, size_t);
void setbuf(FILE *restrict, char *restrict);

char *tmpnam(char *);
FILE *tmpfile(void);




FILE *fmemopen(void *restrict, size_t, const char *restrict);
FILE *open_memstream(char **, size_t *);
FILE *fdopen(int, const char *);
FILE *popen(const char *, const char *);
int pclose(FILE *);
int fileno(FILE *);
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
int dprintf(int, const char *restrict, ...);
int vdprintf(int, const char *restrict, __isoc_va_list);
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);
ssize_t getdelim(char **restrict, size_t *restrict, int, FILE *restrict);
ssize_t getline(char **restrict, size_t *restrict, FILE *restrict);
int renameat(int, const char *, int, const char *);
char *ctermid(char *);







char *tempnam(const char *, const char *);




char *cuserid(char *);
void setlinebuf(FILE *);
void setbuffer(FILE *, char *, size_t);
int fgetc_unlocked(FILE *);
int fputc_unlocked(int, FILE *);
int fflush_unlocked(FILE *);
size_t fread_unlocked(void *, size_t, size_t, FILE *);
size_t fwrite_unlocked(const void *, size_t, size_t, FILE *);
void clearerr_unlocked(FILE *);
int feof_unlocked(FILE *);
int ferror_unlocked(FILE *);
int fileno_unlocked(FILE *);
int getw(FILE *);
int putw(int, FILE *);
char *fgetln(FILE *, size_t *);
int asprintf(char **, const char *, ...);
int vasprintf(char **, const char *, __isoc_va_list);



char *fgets_unlocked(char *, int, FILE *);
int fputs_unlocked(const char *, FILE *);

typedef ssize_t (cookie_read_function_t)(void *, char *, size_t);
typedef ssize_t (cookie_write_function_t)(void *, const char *, size_t);
typedef int (cookie_seek_function_t)(void *, off_t *, int);
typedef int (cookie_close_function_t)(void *);

typedef struct _IO_cookie_io_functions_t {
 cookie_read_function_t *read;
 cookie_write_function_t *write;
 cookie_seek_function_t *seek;
 cookie_close_function_t *close;
} cookie_io_functions_t;

FILE *fopencookie(void *, const char *, cookie_io_functions_t);
# 23 "parse-packet.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h" 1 3







int getloadavg(double loadavg[], int nelem);





# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 1 3
# 21 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 40 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int wchar_t;
# 22 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 2 3

int atoi (const char *);
long atol (const char *);
long long atoll (const char *);
double atof (const char *);

float strtof (const char *restrict, char **restrict);
double strtod (const char *restrict, char **restrict);
long double strtold (const char *restrict, char **restrict);

long strtol (const char *restrict, char **restrict, int);
unsigned long strtoul (const char *restrict, char **restrict, int);
long long strtoll (const char *restrict, char **restrict, int);
unsigned long long strtoull (const char *restrict, char **restrict, int);

int rand (void);
void srand (unsigned);

void *malloc (size_t);
void *calloc (size_t, size_t);
void *realloc (void *, size_t);
void free (void *);
void *aligned_alloc(size_t, size_t);

_Noreturn void abort (void);
int atexit (void (*) (void));
_Noreturn void exit (int);
_Noreturn void _Exit (int);
int at_quick_exit (void (*) (void));
_Noreturn void quick_exit (int);

char *getenv (const char *);

int system (const char *);

void *bsearch (const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
void qsort (void *, size_t, size_t, int (*)(const void *, const void *));

int abs (int);
long labs (long);
long long llabs (long long);

typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;
typedef struct { long long quot, rem; } lldiv_t;

div_t div (int, int);
ldiv_t ldiv (long, long);
lldiv_t lldiv (long long, long long);

int mblen (const char *, size_t);
int mbtowc (wchar_t *restrict, const char *restrict, size_t);
int wctomb (char *, wchar_t);
size_t mbstowcs (wchar_t *restrict, const char *restrict, size_t);
size_t wcstombs (char *restrict, const wchar_t *restrict, size_t);




size_t __ctype_get_mb_cur_max(void);
# 101 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 3
int posix_memalign (void **, size_t, size_t);
int setenv (const char *, const char *, int);
int unsetenv (const char *);
int mkstemp (char *);
int mkostemp (char *, int);
char *mkdtemp (char *);
int getsubopt (char **, char *const *, char **);
int rand_r (unsigned *);






char *realpath (const char *restrict, char *restrict);
long int random (void);
void srandom (unsigned int);
char *initstate (unsigned int, char *, size_t);
char *setstate (char *);
int putenv (char *);
int posix_openpt (int);
int grantpt (int);
int unlockpt (int);
char *ptsname (int);
char *l64a (long);
long a64l (const char *);
void setkey (const char *);
double drand48 (void);
double erand48 (unsigned short [3]);
long int lrand48 (void);
long int nrand48 (unsigned short [3]);
long mrand48 (void);
long jrand48 (unsigned short [3]);
void srand48 (long);
unsigned short *seed48 (unsigned short [3]);
void lcong48 (unsigned short [7]);



# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h" 1 3








# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h" 2 3

void *alloca(size_t);
# 141 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 2 3
char *mktemp (char *);
int mkstemps (char *, int);
int mkostemps (char *, int, int);
void *valloc (size_t);
void *memalign(size_t, size_t);
int getloadavg(double *, int);
int clearenv(void);


void *reallocarray (void *, size_t, size_t);
void qsort_r (void *, size_t, size_t, int (*)(const void *, const void *, void *), void *);



int ptsname_r(int, char *, size_t);
char *ecvt(double, int, int *, int *);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
char *secure_getenv(const char *);
struct __locale_struct;
float strtof_l(const char *restrict, char **restrict, struct __locale_struct *);
double strtod_l(const char *restrict, char **restrict, struct __locale_struct *);
long double strtold_l(const char *restrict, char **restrict, struct __locale_struct *);
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h" 2 3
# 24 "parse-packet.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/string.h" 1 3







extern char* strlwr(char *);
extern char* strupr(char *);





# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 1 3
# 25 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 412 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __locale_struct * locale_t;
# 26 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 2 3

void *memcpy (void *restrict, const void *restrict, size_t);
void *memmove (void *, const void *, size_t);
void *memset (void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void *memchr (const void *, int, size_t);

char *strcpy (char *restrict, const char *restrict);
char *strncpy (char *restrict, const char *restrict, size_t);

char *strcat (char *restrict, const char *restrict);
char *strncat (char *restrict, const char *restrict, size_t);

int strcmp (const char *, const char *);
int strncmp (const char *, const char *, size_t);

int strcoll (const char *, const char *);
size_t strxfrm (char *restrict, const char *restrict, size_t);

char *strchr (const char *, int);
char *strrchr (const char *, int);

size_t strcspn (const char *, const char *);
size_t strspn (const char *, const char *);
char *strpbrk (const char *, const char *);
char *strstr (const char *, const char *);
char *strtok (char *restrict, const char *restrict);

size_t strlen (const char *);

char *strerror (int);


# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 2 3




int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
char *index (const char *, int);
char *rindex (const char *, int);



int ffs (int);
int ffsl (long);
int ffsll (long long);


int strcasecmp (const char *, const char *);
int strncasecmp (const char *, const char *, size_t);

int strcasecmp_l (const char *, const char *, locale_t);
int strncasecmp_l (const char *, const char *, size_t, locale_t);
# 60 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 2 3





char *strtok_r (char *restrict, const char *restrict, char **restrict);
int strerror_r (int, char *, size_t);
char *stpcpy(char *restrict, const char *restrict);
char *stpncpy(char *restrict, const char *restrict, size_t);
size_t strnlen (const char *, size_t);
char *strdup (const char *);
char *strndup (const char *, size_t);
char *strsignal(int);
char *strerror_l (int, locale_t);
int strcoll_l (const char *, const char *, locale_t);
size_t strxfrm_l (char *restrict, const char *restrict, size_t, locale_t);
void *memmem(const void *, size_t, const void *, size_t);




void *memccpy (void *restrict, const void *restrict, int, size_t);



char *strsep(char **, const char *);
size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
void explicit_bzero (void *, size_t);




int strverscmp (const char *, const char *);
char *strchrnul(const char *, int);
char *strcasestr(const char *, const char *);
void *memrchr(const void *, int, size_t);
void *mempcpy(void *, const void *, size_t);
# 16 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/string.h" 2 3
# 25 "parse-packet.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/assert.h" 1 3
# 19 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/assert.h" 3
_Noreturn void __assert_fail (const char *, const char *, int, const char *);
# 26 "parse-packet.c" 2

# 1 "./packet.h" 1
# 24 "./packet.h"
# 1 "../include/types.h" 1
# 24 "../include/types.h"
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 1 3
# 24 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 2 3

typedef struct { intmax_t quot, rem; } imaxdiv_t;

intmax_t imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);

intmax_t strtoimax(const char *restrict, char **restrict, int);
uintmax_t strtoumax(const char *restrict, char **restrict, int);

intmax_t wcstoimax(const wchar_t *restrict, wchar_t **restrict, int);
uintmax_t wcstoumax(const wchar_t *restrict, wchar_t **restrict, int);
# 25 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 2 3
# 25 "../include/types.h" 2
# 43 "../include/types.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 1 3
# 57 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 83 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long long int time_t;




typedef int suseconds_t;





typedef struct {
    union {
        int __i[10];
        volatile int __vi[10];
        unsigned long __s[10];
    } __u;



    const char *_a_transferredcanvases;

} pthread_attr_t;




typedef struct { union { int __i[6]; volatile int __vi[6]; volatile void *__p[6]; } __u; } pthread_mutex_t;
# 120 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct { union { int __i[12]; volatile int __vi[12]; void *__p[12]; } __u; } pthread_cond_t;
# 130 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct { union { int __i[sizeof(long)==8?14:8]; volatile int __vi[sizeof(long)==8?14:8]; void *__p[sizeof(long)==8?7:8]; } __u; } pthread_rwlock_t;




typedef struct { union { int __i[5]; volatile int __vi[5]; void *__p[5]; } __u; } pthread_barrier_t;
# 171 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int register_t;
# 222 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int u_int64_t;
# 233 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned mode_t;




typedef unsigned long int nlink_t;
# 248 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int ino_t;




typedef unsigned int dev_t;




typedef int blksize_t;




typedef int blkcnt_t;




typedef unsigned int fsblkcnt_t;




typedef unsigned int fsfilcnt_t;
# 289 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef void * timer_t;




typedef int clockid_t;




typedef int clock_t;
# 320 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int pid_t;




typedef unsigned id_t;




typedef unsigned uid_t;




typedef unsigned gid_t;




typedef int key_t;




typedef unsigned useconds_t;
# 358 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __pthread * pthread_t;





typedef int pthread_once_t;




typedef unsigned pthread_key_t;




typedef int pthread_spinlock_t;




typedef struct { unsigned __attr; } pthread_mutexattr_t;




typedef struct { unsigned __attr; } pthread_condattr_t;




typedef struct { unsigned __attr; } pthread_barrierattr_t;




typedef struct { unsigned __attr[2]; } pthread_rwlockattr_t;
# 58 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3


typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned u_int32_t;
typedef char *caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short, ushort;
typedef unsigned u_int, uint;
typedef unsigned long u_long, ulong;
typedef long long quad_t;
typedef unsigned long long u_quad_t;
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 11 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 2 3








static inline uint16_t __bswap16(uint16_t __x)
{
 return __x<<8 | __x>>8;
}

static inline uint32_t __bswap32(uint32_t __x)
{
 return __x>>24 | __x>>8&0xff00 | __x<<8&0xff0000 | __x<<24;
}

static inline uint64_t __bswap64(uint64_t __x)
{
 return __bswap32(__x)+0ULL<<32 | __bswap32(__x>>32);
}
# 71 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 1 3
# 16 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 309 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
struct timeval { time_t tv_sec; suseconds_t tv_usec; };




struct timespec { time_t tv_sec; long tv_nsec; };
# 418 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __sigset_t { unsigned long __bits[128/sizeof(long)]; } sigset_t;
# 17 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 2 3



typedef unsigned long fd_mask;

typedef struct {
 unsigned long fds_bits[1024 / 8 / sizeof(long)];
} fd_set;






int select (int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict);
int pselect (int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict);
# 72 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3
# 44 "../include/types.h" 2





typedef unsigned char byte;
# 76 "../include/types.h"
typedef unsigned short u16;
# 86 "../include/types.h"
typedef unsigned int u32;
# 103 "../include/types.h"
typedef uint64_t u64;
# 126 "../include/types.h"
typedef union {
    int a;
    short b;
    char c[1];
    long d;

    u64 e;

    float f;
    double g;
} PROPERLY_ALIGNED_TYPE;

struct string_list {
    struct string_list *next;
    unsigned int flags;
    char d[1];
};
typedef struct string_list *STRLIST;
typedef struct string_list *strlist_t;
# 25 "./packet.h" 2
# 1 "../include/iobuf.h" 1
# 36 "../include/iobuf.h"
typedef struct iobuf_struct *IOBUF;
typedef struct iobuf_struct *iobuf_t;


struct iobuf_struct {
    int use;
    off_t nlimit;
    off_t nbytes;
    off_t ntotal;
    int nofast;
    void *directfp;
    struct {
 size_t size;
 size_t start;
 size_t len;
 byte *buf;
    } d;
    int filter_eof;
    int error;
    int (*filter)( void *opaque, int control,
     IOBUF chain, byte *buf, size_t *len);
    void *filter_ov;
    int filter_ov_owner;
    char *real_fname;
    IOBUF chain;
    int no, subno;
    void *opaque;

    struct {
 size_t size;
 size_t start;
 size_t len;
 byte *buf;
    } unget;
};
# 81 "../include/iobuf.h"
int iobuf_debug_mode;

void iobuf_enable_special_filenames ( int yes );
int iobuf_is_pipe_filename (const char *fname);
IOBUF iobuf_alloc(int use, size_t bufsize);
IOBUF iobuf_temp(void);
IOBUF iobuf_temp_with_content( const char *buffer, size_t length );
IOBUF iobuf_open( const char *fname );
IOBUF iobuf_fdopen( int fd, const char *mode );
IOBUF iobuf_sockopen( int fd, const char *mode );
IOBUF iobuf_create( const char *fname );
IOBUF iobuf_append( const char *fname );
IOBUF iobuf_openrw( const char *fname );
int iobuf_ioctl ( IOBUF a, int cmd, int intval, void *ptrval );
int iobuf_close( IOBUF iobuf );
int iobuf_cancel( IOBUF iobuf );

int iobuf_push_filter( IOBUF a, int (*f)(void *opaque, int control,
         IOBUF chain, byte *buf, size_t *len), void *ov );
int iobuf_push_filter2( IOBUF a,
      int (*f)(void *opaque, int control,
      IOBUF chain, byte *buf, size_t *len),
      void *ov, int rel_ov );
int iobuf_flush(IOBUF a);
void iobuf_clear_eof(IOBUF a);



void iobuf_set_limit( IOBUF a, off_t nlimit );

off_t iobuf_tell( IOBUF a );
int iobuf_seek( IOBUF a, off_t newpos );

int iobuf_readbyte(IOBUF a);
int iobuf_read(IOBUF a, byte *buf, unsigned buflen );
unsigned iobuf_read_line( IOBUF a, byte **addr_of_buffer,
     unsigned *length_of_buffer, unsigned *max_length );
int iobuf_peek(IOBUF a, byte *buf, unsigned buflen );
int iobuf_writebyte(IOBUF a, unsigned c);
int iobuf_write(IOBUF a, byte *buf, unsigned buflen );
int iobuf_writestr(IOBUF a, const char *buf );

void iobuf_flush_temp( IOBUF temp );
int iobuf_write_temp( IOBUF a, IOBUF temp );
size_t iobuf_temp_to_buffer( IOBUF a, byte *buffer, size_t buflen );
void iobuf_unget_and_close_temp( IOBUF a, IOBUF temp );

int iobuf_get_fd (IOBUF a);
off_t iobuf_get_filelength (IOBUF a, int *overflow);

const char *iobuf_get_real_fname( IOBUF a );
const char *iobuf_get_fname( IOBUF a );

void iobuf_set_partial_block_mode( IOBUF a, size_t len );

int iobuf_translate_file_handle ( int fd, int for_write );
# 160 "../include/iobuf.h"
void iobuf_skip_rest (IOBUF a, unsigned long n, int partial);
# 26 "./packet.h" 2
# 1 "../include/mpi.h" 1
# 32 "../include/mpi.h"
# 1 "../config.h" 1
# 33 "../include/mpi.h" 2



# 1 "../include/memory.h" 1
# 57 "../include/memory.h"
void *xmalloc( size_t n );
void *xtrymalloc (size_t n);
void *xmalloc_clear( size_t n );
void *xmalloc_secure( size_t n );
void *xmalloc_secure_clear( size_t n );
void *xrealloc( void *a, size_t n );
void xfree( void *p );
void m_check( const void *a );

char *xstrdup( const char * a);
char *xtrystrdup (const char *a);


size_t m_size( const void *a );
void m_print_stats(const char *prefix);


void *xcalloc (size_t n, size_t m);
void *xcalloc_secure (size_t n, size_t m);



int secmem_init( size_t npool );
void secmem_term( void );
void *secmem_malloc( size_t size );
void *secmexrealloc( void *a, size_t newsize );
void secmem_free( void *a );
int m_is_secure( const void *p );
void secmem_dump_stats(void);
void secmem_set_flags( unsigned flags );
unsigned secmem_get_flags(void);
# 102 "../include/memory.h"
int memory_debug_mode;
int memory_stat_debug_mode;
# 37 "../include/mpi.h" 2
# 49 "../include/mpi.h"
int mpi_debug_mode;


struct gcry_mpi;
typedef struct gcry_mpi *MPI;
# 72 "../include/mpi.h"
MPI mpi_alloc( unsigned nlimbs );
MPI mpi_alloc_secure( unsigned nlimbs );
MPI mpi_alloc_like( MPI a );
void mpi_free( MPI a );
void mpi_resize( MPI a, unsigned nlimbs );
MPI mpi_copy( MPI a );


MPI mpi_set_opaque( MPI a, void *p, unsigned int len );
void *mpi_get_opaque( MPI a, unsigned int *len );

void mpi_set_secure( MPI a );
void mpi_clear( MPI a );
void mpi_set( MPI w, MPI u);
void mpi_set_cond( MPI w, MPI u, unsigned long set);
void mpi_set_ui( MPI w, ulong u);
MPI mpi_alloc_set_ui( unsigned long u);
void mpi_m_check( MPI a );
void mpi_swap( MPI a, MPI b);
int mpi_get_nlimbs (MPI a);
int mpi_is_neg (MPI a);
unsigned int mpi_nlimb_hint_from_nbytes (unsigned int nbytes);
unsigned int mpi_nlimb_hint_from_nbits (unsigned int nbits);
unsigned int mpi_get_flags (MPI a);


int mpi_write( IOBUF out, MPI a );




MPI mpi_read(IOBUF inp, unsigned *nread, int secure);

MPI mpi_read_from_buffer(byte *buffer, unsigned *ret_nread, int secure);
int mpi_fromstr(MPI val, const char *str);
int mpi_print( FILE *fp, MPI a, int mode );
void g10_log_mpidump( const char *text, MPI a );
u32 mpi_get_keyid( MPI a, u32 *keyid );
byte *mpi_get_buffer( MPI a, unsigned *nbytes, int *sign );
byte *mpi_get_secure_buffer( MPI a, unsigned *nbytes, int *sign );
void mpi_set_buffer( MPI a, const byte *buffer, unsigned nbytes, int sign );




void mpi_add_ui(MPI w, MPI u, ulong v );
void mpi_add(MPI w, MPI u, MPI v);
void mpi_addm(MPI w, MPI u, MPI v, MPI m);
void mpi_sub_ui(MPI w, MPI u, ulong v );
void mpi_sub( MPI w, MPI u, MPI v);
void mpi_subm( MPI w, MPI u, MPI v, MPI m);


void mpi_mul_ui(MPI w, MPI u, ulong v );
void mpi_mul_2exp( MPI w, MPI u, ulong cnt);
void mpi_mul( MPI w, MPI u, MPI v);
void mpi_mulm( MPI w, MPI u, MPI v, MPI m);


ulong mpi_fdiv_r_ui( MPI rem, MPI dividend, ulong divisor );
void mpi_fdiv_r( MPI rem, MPI dividend, MPI divisor );
void mpi_fdiv_q( MPI quot, MPI dividend, MPI divisor );
void mpi_fdiv_qr( MPI quot, MPI rem, MPI dividend, MPI divisor );
void mpi_tdiv_r( MPI rem, MPI num, MPI den);
void mpi_tdiv_qr( MPI quot, MPI rem, MPI num, MPI den);
void mpi_tdiv_q_2exp( MPI w, MPI u, unsigned count );
int mpi_divisible_ui(MPI dividend, ulong divisor );


int mpi_gcd( MPI g, MPI a, MPI b );


void mpi_pow( MPI w, MPI u, MPI v);
void mpi_powm( MPI res, MPI base, MPI exponent, MPI mod);


void mpi_mulpowm( MPI res, MPI *basearray, MPI *exparray, MPI mod);


int mpi_cmp_ui( MPI u, ulong v );
int mpi_cmp( MPI u, MPI v );


int mpi_getbyte( MPI a, unsigned idx );
void mpi_putbyte( MPI a, unsigned idx, int value );
unsigned mpi_trailing_zeros( MPI a );


void mpi_normalize( MPI a );
unsigned mpi_get_nbits( MPI a );
int mpi_test_bit( MPI a, unsigned n );
void mpi_set_bit( MPI a, unsigned n );
void mpi_set_highbit( MPI a, unsigned n );
void mpi_clear_highbit( MPI a, unsigned n );
void mpi_clear_bit( MPI a, unsigned n );
void mpi_rshift( MPI x, MPI a, unsigned n );


void mpi_invm( MPI x, MPI u, MPI v );
# 27 "./packet.h" 2
# 1 "../include/cipher.h" 1
# 26 "../include/cipher.h"
# 1 "../include/../cipher/random.h" 1
# 25 "../include/../cipher/random.h"
void random_dump_stats(void);
void secure_randoxmalloc(void);
void set_random_seed_file(const char *);
void update_random_seed_file(void);
int quick_random_gen( int onoff );
int random_is_faked(void);
void random_disable_locking (void);
void randomize_buffer( byte *buffer, size_t length, int level );
void randomize_mpi (MPI mpi, size_t nbits, int level);
byte *get_random_bits( size_t nbits, int level, int secure );
void fast_random_poll( void );
# 27 "../include/cipher.h" 2
# 82 "../include/cipher.h"
typedef struct
{
  int algo;
  int keylen;
  int algo_info_printed;
  int use_mdc;
  int symmetric;
  byte key[32];
} DEK;

struct cipher_handle_s;
typedef struct cipher_handle_s *CIPHER_HANDLE;
# 103 "../include/cipher.h"
struct md_digest_list_s;

struct gcry_md_context {
    int secure;
    FILE *debug;
    int finalized;
    struct md_digest_list_s *list;
    int bufcount;
    int bufsize;
    byte buffer[1];
};

typedef struct gcry_md_context *MD_HANDLE;
# 126 "../include/cipher.h"
int g10c_debug_mode;
int g10_opt_verbose;
const char *g10_opt_homedir;



void register_cipher_extension( const char *mainpgm, const char *fname );


int string_to_digest_algo( const char *string );
const char * digest_algo_to_string( int algo );
int check_digest_algo( int algo );
MD_HANDLE md_open( int algo, int secure );
void md_enable( MD_HANDLE hd, int algo );
MD_HANDLE md_copy( MD_HANDLE a );
void md_reset( MD_HANDLE a );
void md_close(MD_HANDLE a);
void md_write( MD_HANDLE a, const byte *inbuf, size_t inlen);
void md_final(MD_HANDLE a);
byte *md_read( MD_HANDLE a, int algo );
int md_digest( MD_HANDLE a, int algo, byte *buffer, int buflen );
int md_get_algo( MD_HANDLE a );
int md_algo_present( MD_HANDLE a, int algo );
int md_digest_length( int algo );
const byte *md_asn_oid( int algo, size_t *asnlen, size_t *mdlen );
void md_start_debug( MD_HANDLE a, const char *suffix );
void md_stop_debug( MD_HANDLE a );
# 161 "../include/cipher.h"
void rmd160_hash_buffer (char *outbuf, const char *buffer, size_t length);
void sha1_hash_buffer (char *outbuf, const char *buffer, size_t length);



int string_to_cipher_algo( const char *string );
const char * cipher_algo_to_string( int algo );
void disable_cipher_algo( int algo );
int check_cipher_algo( int algo );
unsigned cipher_get_keylen( int algo );
unsigned cipher_get_blocksize( int algo );
CIPHER_HANDLE cipher_open( int algo, int mode, int secure );
void cipher_close( CIPHER_HANDLE c );
int cipher_setkey( CIPHER_HANDLE c, byte *key, unsigned keylen );
void cipher_setiv( CIPHER_HANDLE c, const byte *iv, unsigned ivlen );
void cipher_encrypt( CIPHER_HANDLE c, byte *out, byte *in, unsigned nbytes );
void cipher_decrypt( CIPHER_HANDLE c, byte *out, byte *in, unsigned nbytes );
void cipher_sync( CIPHER_HANDLE c );







int string_to_pubkey_algo( const char *string );
const char * pubkey_algo_to_string( int algo );
void disable_pubkey_algo( int algo );
int check_pubkey_algo( int algo );
int check_pubkey_algo2( int algo, unsigned use );
int pubkey_get_npkey( int algo );
int pubkey_get_nskey( int algo );
int pubkey_get_nsig( int algo );
int pubkey_get_nenc( int algo );
unsigned pubkey_nbits( int algo, MPI *pkey );
int pubkey_generate( int algo, unsigned nbits, MPI *skey, MPI **retfactors );
int dsa2_generate( int algo, unsigned nbits, unsigned qbits,
     MPI *skey, MPI **retfactors );
int pubkey_check_secret_key( int algo, MPI *skey );
int pubkey_encrypt( int algo, MPI *resarr, MPI data, MPI *pkey );
int pubkey_decrypt( int algo, MPI *result, MPI *data, MPI *skey );
int pubkey_sign( int algo, MPI *resarr, MPI hash, MPI *skey );
int pubkey_verify( int algo, MPI hash, MPI *data, MPI *pkey );


extern ushort small_prime_numbers[];


void register_primegen_progress ( void (*cb)( void *, int), void *cb_data );
MPI generate_secret_prime( unsigned nbits );
MPI generate_public_prime( unsigned nbits );
MPI generate_elg_prime( int mode, unsigned pbits, unsigned qbits,
        MPI g, MPI **factors );


void register_pk_dsa_progress ( void (*cb)( void *, int), void *cb_data );
void register_pk_elg_progress ( void (*cb)( void *, int), void *cb_data );
# 28 "./packet.h" 2
# 1 "./filter.h" 1
# 26 "./filter.h"
typedef struct {
    MD_HANDLE md;
    MD_HANDLE md2;
    size_t maxbuf_size;
} md_filter_context_t;

typedef struct {
    int refcount;



    int what;
    int only_keyblocks;
    const char *hdrlines;


    int no_openpgp_data;
    int key_failed_code;



    int inp_checked;
    int inp_bypass;
    int in_cleartext;
    int not_dash_escaped;
    int hashes;
    int faked;
    int truncated;
    int qp_detected;
    int pgp2mode;
    byte eol[3];




    byte *buffer;
    unsigned buffer_size;
    unsigned buffer_len;
    unsigned buffer_pos;

    byte radbuf[4];
    int idx, idx2;
    u32 crc;

    int status;
    int cancel;
    int any_data;
    int pending_lf;
} armor_filter_context_t;

struct unarmor_pump_s;
typedef struct unarmor_pump_s *UnarmorPump;


struct compress_filter_context_s {
    int status;
    void *opaque;
    byte *inbuf;
    unsigned inbufsize;
    byte *outbuf;
    unsigned outbufsize;
    int algo;
    int algo1hack;
    int new_ctb;
    void (*release)(struct compress_filter_context_s*);
};
typedef struct compress_filter_context_s compress_filter_context_t;


typedef struct {
    DEK *dek;
    u32 datalen;
    CIPHER_HANDLE cipher_hd;
    int header;
    MD_HANDLE mdc_hash;
    byte enchash[20];
    int create_mdc;
} cipher_filter_context_t;



typedef struct {
    byte *buffer;
    unsigned buffer_size;
    unsigned buffer_len;
    unsigned buffer_pos;
    int truncated;
    int not_dash_escaped;
    int escape_from;
    MD_HANDLE md;
    int pending_lf;
    int pending_esc;
} text_filter_context_t;


typedef struct {
    char *what;
    u32 last_time;
    unsigned long last;
    unsigned long offset;
    unsigned long total;
} progress_filter_context_t;




int md_filter( void *opaque, int control, IOBUF a, byte *buf, size_t *ret_len);
void free_md_filter_context( md_filter_context_t *mfx );


armor_filter_context_t *new_armor_context (void);
void release_armor_context (armor_filter_context_t *afx);
int push_armor_filter (armor_filter_context_t *afx, IOBUF iobuf);
int use_armor_filter( IOBUF a );
int armor_filter( void *opaque, int control,
    IOBUF chain, byte *buf, size_t *ret_len);
UnarmorPump unarmor_pump_new (void);
void unarmor_pump_release (UnarmorPump x);
int unarmor_pump (UnarmorPump x, int c);


void push_compress_filter(IOBUF out,compress_filter_context_t *zfx,int algo);
void push_compress_filter2(IOBUF out,compress_filter_context_t *zfx,
      int algo,int rel);


int cipher_filter( void *opaque, int control,
     IOBUF chain, byte *buf, size_t *ret_len);


int text_filter( void *opaque, int control,
   IOBUF chain, byte *buf, size_t *ret_len);
int copy_clearsig_text( IOBUF out, IOBUF inp, MD_HANDLE md,
     int escape_dash, int escape_from, int pgp2mode );


int progress_filter (void *opaque, int control,
       IOBUF a, byte *buf, size_t *ret_len);
void handle_progress (progress_filter_context_t *pfx,
        IOBUF inp, const char *name);
# 29 "./packet.h" 2
# 1 "./global.h" 1
# 25 "./global.h"
typedef struct kbnode_struct *KBNODE;
typedef struct kbnode_struct *kbnode_t;
typedef struct keydb_search_desc KEYDB_SEARCH_DESC;
# 30 "./packet.h" 2



typedef enum {
 PKT_NONE =0,
 PKT_PUBKEY_ENC =1,
 PKT_SIGNATURE =2,
 PKT_SYMKEY_ENC =3,
 PKT_ONEPASS_SIG =4,
 PKT_SECRET_KEY =5,
 PKT_PUBLIC_KEY =6,
 PKT_SECRET_SUBKEY =7,
 PKT_COMPRESSED =8,
 PKT_ENCRYPTED =9,
 PKT_MARKER =10,
 PKT_PLAINTEXT =11,
 PKT_RING_TRUST =12,
 PKT_USER_ID =13,
 PKT_PUBLIC_SUBKEY =14,
 PKT_OLD_COMMENT =16,
 PKT_ATTRIBUTE =17,
 PKT_ENCRYPTED_MDC =18,
 PKT_MDC =19,
 PKT_COMMENT =61,
        PKT_GPG_CONTROL =63
} pkttype_t;

typedef struct packet_struct PACKET;


typedef enum {
    CTRLPKT_CLEARSIGN_START = 1,
    CTRLPKT_PIPEMODE = 2,
    CTRLPKT_PLAINTEXT_MARK =3
} ctrlpkttype_t;

typedef enum {
    PREFTYPE_NONE = 0,
    PREFTYPE_SYM = 1,
    PREFTYPE_HASH = 2,
    PREFTYPE_ZIP = 3
} preftype_t;

typedef struct {
    byte type;
    byte value;
} prefitem_t;

typedef struct {
    int mode;
    byte hash_algo;
    byte salt[8];
    u32 count;
} STRING2KEY;

typedef struct {
    byte version;
    byte cipher_algo;
    STRING2KEY s2k;
    byte seskeylen;
    byte seskey[1];
} PKT_symkey_enc;

typedef struct {
    u32 keyid[2];
    byte version;
    byte pubkey_algo;
    byte throw_keyid;
    MPI data[2];
} PKT_pubkey_enc;


typedef struct {
    u32 keyid[2];
    byte sig_class;
    byte digest_algo;
    byte pubkey_algo;
    byte last;
} PKT_onepass_sig;


typedef struct {
    size_t size;
    size_t len;
    byte data[1];
} subpktarea_t;

struct revocation_key {
  byte class;
  byte algid;
  byte fpr[20];
};



typedef struct
{
  int valid;
  int checked;

  char *uri;

  unsigned char fpr[20];
  char email[1];
} pka_info_t;



typedef struct
{
  struct
  {
    unsigned checked:1;
    unsigned valid:1;
    unsigned chosen_selfsig:1;
    unsigned unknown_critical:1;
    unsigned exportable:1;
    unsigned revocable:1;
    unsigned policy_url:1;
    unsigned notation:1;
    unsigned pref_ks:1;
    unsigned expired:1;
    unsigned pka_tried:1;
  } flags;
  u32 keyid[2];
  u32 timestamp;
  u32 expiredate;
  byte version;
  byte sig_class;
  byte pubkey_algo;

  byte digest_algo;
  byte trust_depth;
  byte trust_value;
  const byte *trust_regexp;
  struct revocation_key **revkey;
  int numrevkeys;
  pka_info_t *pka_info;

  subpktarea_t *hashed;
  subpktarea_t *unhashed;
  byte digest_start[2];
  MPI data[2];
} PKT_signature;




struct user_attribute {
  byte type;
  const byte *data;
  u32 len;
};

typedef struct
{
  int ref;
  int len;
  struct user_attribute *attribs;
  int numattribs;
  byte *attrib_data;
  unsigned long attrib_len;
  byte *namehash;
  int help_key_usage;
  u32 help_key_expire;
  int help_full_count;
  int help_marginal_count;
  int is_primary;
  int is_revoked;
  int is_expired;
  u32 expiredate;
  prefitem_t *prefs;
  u32 created;
  byte selfsigversion;
  struct
  {

    unsigned mdc:1;
    unsigned ks_modify:1;
    unsigned compacted:1;
  } flags;
  char name[1];
} PKT_user_id;

struct revoke_info
{

  u32 date;

  u32 keyid[2];

  byte algo;
};







typedef struct {
    u32 timestamp;
    u32 expiredate;
    u32 max_expiredate;
    struct revoke_info revoked;
    byte hdrbytes;
    byte version;
    byte selfsigversion;
    byte pubkey_algo;
    byte pubkey_usage;
    byte req_usage;
    byte req_algo;
    u32 has_expired;
    int is_revoked;

    int maybe_revoked;

    int is_valid;
    int dont_cache;
    byte backsig;
    u32 main_keyid[2];
    u32 keyid[2];
    byte is_primary;
    byte is_disabled;
    prefitem_t *prefs;
    int mdc_feature;
    PKT_user_id *user_id;
    struct revocation_key *revkey;
    int numrevkeys;
    u32 trust_timestamp;
    byte trust_depth;
    byte trust_value;
    const byte *trust_regexp;
    MPI pkey[4];
} PKT_public_key;





typedef struct {
    u32 timestamp;
    u32 expiredate;
    u32 max_expiredate;
    byte hdrbytes;
    byte version;
    byte pubkey_algo;
    byte pubkey_usage;
    byte req_usage;
    byte req_algo;
    u32 has_expired;
    int is_revoked;
    int is_valid;
    u32 main_keyid[2];
    u32 keyid[2];
    byte is_primary;
    byte is_protected;



    struct {
 byte algo;
        byte sha1chk;
 STRING2KEY s2k;
 byte ivlen;
 byte iv[16];
    } protect;
    MPI skey[6];
    u16 csum;
} PKT_secret_key;


typedef struct {
    int len;
    char data[1];
} PKT_comment;

typedef struct {
    u32 len;
    byte new_ctb;
    byte algorithm;
    IOBUF buf;
} PKT_compressed;

typedef struct {
    u32 len;
    int extralen;
    byte new_ctb;
    byte is_partial;
    byte mdc_method;
    IOBUF buf;
} PKT_encrypted;

typedef struct {
    byte hash[20];
} PKT_mdc;

typedef struct {
    unsigned int trustval;
    unsigned int sigcache;
} PKT_ring_trust;

typedef struct {
    u32 len;
    IOBUF buf;
    byte new_ctb;
    byte is_partial;
    int mode;
    u32 timestamp;
    int namelen;
    char name[1];
} PKT_plaintext;

typedef struct {
    int control;
    size_t datalen;
    char data[1];
} PKT_gpg_control;


struct packet_struct {
    pkttype_t pkttype;
    union {
 void *generic;
 PKT_symkey_enc *symkey_enc;
 PKT_pubkey_enc *pubkey_enc;
 PKT_onepass_sig *onepass_sig;
 PKT_signature *signature;
 PKT_public_key *public_key;
 PKT_secret_key *secret_key;
 PKT_comment *comment;
 PKT_user_id *user_id;
 PKT_compressed *compressed;
 PKT_encrypted *encrypted;
 PKT_mdc *mdc;
 PKT_ring_trust *ring_trust;
 PKT_plaintext *plaintext;
        PKT_gpg_control *gpg_control;
    } pkt;
};





typedef enum {
    SIGSUBPKT_TEST_CRITICAL=-3,
    SIGSUBPKT_LIST_UNHASHED=-2,
    SIGSUBPKT_LIST_HASHED =-1,
    SIGSUBPKT_NONE = 0,
    SIGSUBPKT_SIG_CREATED = 2,
    SIGSUBPKT_SIG_EXPIRE = 3,
    SIGSUBPKT_EXPORTABLE = 4,
    SIGSUBPKT_TRUST = 5,
    SIGSUBPKT_REGEXP = 6,
    SIGSUBPKT_REVOCABLE = 7,
    SIGSUBPKT_KEY_EXPIRE = 9,
    SIGSUBPKT_ARR =10,
    SIGSUBPKT_PREF_SYM =11,
    SIGSUBPKT_REV_KEY =12,
    SIGSUBPKT_ISSUER =16,
    SIGSUBPKT_NOTATION =20,
    SIGSUBPKT_PREF_HASH =21,
    SIGSUBPKT_PREF_COMPR =22,
    SIGSUBPKT_KS_FLAGS =23,
    SIGSUBPKT_PREF_KS =24,
    SIGSUBPKT_PRIMARY_UID =25,
    SIGSUBPKT_POLICY =26,
    SIGSUBPKT_KEY_FLAGS =27,
    SIGSUBPKT_SIGNERS_UID =28,
    SIGSUBPKT_REVOC_REASON =29,
    SIGSUBPKT_FEATURES =30,

    SIGSUBPKT_SIGNATURE =32,

    SIGSUBPKT_FLAG_CRITICAL=128
} sigsubpkttype_t;

struct notation
{
  char *name;
  char *value;
  char *altvalue;
  unsigned char *bdat;
  size_t blen;
  struct
  {
    unsigned int critical:1;
    unsigned int ignore:1;
  } flags;
  struct notation *next;
};


void reset_literals_seen(void);
int proc_packets( void *ctx, IOBUF a );
int proc_signature_packets( void *ctx, IOBUF a,
       STRLIST signedfiles, const char *sigfile );
int proc_encryption_packets( void *ctx, IOBUF a );
int list_packets( IOBUF a );


int set_packet_list_mode( int mode );


int dbg_search_packet( IOBUF inp, PACKET *pkt, off_t *retpos, int with_uid,
                       const char* file, int lineno );
int dbg_parse_packet( IOBUF inp, PACKET *ret_pkt,
                      const char* file, int lineno );
int dbg_copy_all_packets( IOBUF inp, IOBUF out,
                          const char* file, int lineno );
int dbg_copy_some_packets( IOBUF inp, IOBUF out, off_t stopoff,
                           const char* file, int lineno );
int dbg_skip_some_packets( IOBUF inp, unsigned n,
                           const char* file, int lineno );
# 463 "./packet.h"
int parse_signature( IOBUF inp, int pkttype, unsigned long pktlen,
       PKT_signature *sig );
const byte *enum_sig_subpkt ( const subpktarea_t *subpkts,
                              sigsubpkttype_t reqtype,
                              size_t *ret_n, int *start, int *critical );
const byte *parse_sig_subpkt ( const subpktarea_t *buffer,
                               sigsubpkttype_t reqtype,
                               size_t *ret_n );
const byte *parse_sig_subpkt2 ( PKT_signature *sig,
                                sigsubpkttype_t reqtype,
                                size_t *ret_n );
int parse_one_sig_subpkt( const byte *buffer, size_t n, int type );
void parse_revkeys(PKT_signature *sig);
int parse_attribute_subpkts(PKT_user_id *uid);
void make_attribute_uidname(PKT_user_id *uid, size_t max_namelen);
PACKET *create_gpg_control ( ctrlpkttype_t type,
                             const byte *data,
                             size_t datalen );


int build_packet( IOBUF inp, PACKET *pkt );
u32 calc_packet_length( PACKET *pkt );
void build_sig_subpkt( PKT_signature *sig, sigsubpkttype_t type,
   const byte *buffer, size_t buflen );
void build_sig_subpkt_from_sig( PKT_signature *sig );
int delete_sig_subpkt(subpktarea_t *buffer, sigsubpkttype_t type );
void build_attribute_subpkt(PKT_user_id *uid,byte type,
       const void *buf,u32 buflen,
       const void *header,u32 headerlen);
struct notation *string_to_notation(const char *string,int is_utf8);
struct notation *sig_to_notation(PKT_signature *sig);
void free_notation(struct notation *notation);


void free_symkey_enc( PKT_symkey_enc *enc );
void free_pubkey_enc( PKT_pubkey_enc *enc );
void free_seckey_enc( PKT_signature *enc );
int digest_algo_from_sig( PKT_signature *sig );
void release_public_key_parts( PKT_public_key *pk );
void free_public_key( PKT_public_key *key );
void release_secret_key_parts( PKT_secret_key *sk );
void free_secret_key( PKT_secret_key *sk );
void free_attributes(PKT_user_id *uid);
void free_user_id( PKT_user_id *uid );
void free_comment( PKT_comment *rem );
void free_packet( PACKET *pkt );
prefitem_t *copy_prefs (const prefitem_t *prefs);
PKT_public_key *copy_public_key( PKT_public_key *d, PKT_public_key *s );
void copy_public_parts_to_secret_key( PKT_public_key *pk, PKT_secret_key *sk );
PKT_secret_key *copy_secret_key( PKT_secret_key *d, PKT_secret_key *s );
PKT_signature *copy_signature( PKT_signature *d, PKT_signature *s );
PKT_user_id *scopy_user_id (PKT_user_id *sd );
int cmp_public_keys( PKT_public_key *a, PKT_public_key *b );
int cmp_secret_keys( PKT_secret_key *a, PKT_secret_key *b );
int cmp_signatures( PKT_signature *a, PKT_signature *b );
int cmp_public_secret_key( PKT_public_key *pk, PKT_secret_key *sk );
int cmp_user_ids( PKT_user_id *a, PKT_user_id *b );



int signature_check( PKT_signature *sig, MD_HANDLE digest );
int signature_check2( PKT_signature *sig, MD_HANDLE digest, u32 *r_expiredate,
        int *r_expired, int *r_revoked, PKT_public_key *ret_pk );


int is_secret_key_protected( PKT_secret_key *sk );
int check_secret_key( PKT_secret_key *sk, int retries );
int protect_secret_key( PKT_secret_key *sk, DEK *dek );


int get_session_key( PKT_pubkey_enc *k, DEK *dek );
int get_override_session_key( DEK *dek, const char *string );


int handle_compressed( void *ctx, PKT_compressed *cd,
         int (*callback)(IOBUF, void *), void *passthru );


int decrypt_data( void *ctx, PKT_encrypted *ed, DEK *dek );


int handle_plaintext( PKT_plaintext *pt, md_filter_context_t *mfx,
     int nooutput, int clearsig );
int ask_for_detached_datafile( MD_HANDLE md, MD_HANDLE md2,
          const char *inname, int textmode );


int make_keysig_packet( PKT_signature **ret_sig, PKT_public_key *pk,
   PKT_user_id *uid, PKT_public_key *subpk,
   PKT_secret_key *sk, int sigclass, int digest_algo,
   int sigversion, u32 timestamp, u32 duration,
   int (*mksubpkt)(PKT_signature *, void *),
   void *opaque );
int update_keysig_packet( PKT_signature **ret_sig,
                      PKT_signature *orig_sig,
                      PKT_public_key *pk,
                      PKT_user_id *uid,
                      PKT_public_key *subpk,
                      PKT_secret_key *sk,
                      int (*mksubpkt)(PKT_signature *, void *),
                      void *opaque );


PKT_user_id *generate_user_id(void);
# 28 "parse-packet.c" 2


# 1 "../include/util.h" 1
# 23 "../include/util.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 1 3
# 14 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 1 3
# 47 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_header_macro.h" 1 3
# 48 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3



# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___gnuc_va_list.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___gnuc_va_list.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 52 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_list.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_list.h" 3
typedef __builtin_va_list va_list;
# 57 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_arg.h" 1 3
# 62 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___va_copy.h" 1 3
# 67 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_copy.h" 1 3
# 72 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 2 3
# 24 "../include/util.h" 2


# 1 "../include/errors.h" 1
# 27 "../include/util.h" 2


# 1 "../include/compat.h" 1







int hextobyte( const char *s );
int ascii_toupper (int c);
int ascii_tolower (int c);
int ascii_strcasecmp( const char *a, const char *b );
int ascii_strncasecmp( const char *a, const char *b, size_t n);






char *xstrconcat (const char *s1, ...) __attribute__ ((sentinel(0)));
# 30 "../include/util.h" 2
# 39 "../include/util.h"
typedef struct {
     int *argc;
     char ***argv;
     unsigned flags;
     int err;

     int r_opt;
     int r_type;
     union {
  int ret_int;
  long ret_long;
  ulong ret_ulong;
  char *ret_str;
     } r;
     struct {
  int idx;
  int inarg;
  int stopped;
  const char *last;
  void *aliases;
  const void *cur_alias;
         void *iio_list;
     } internal;
} ARGPARSE_ARGS;

typedef struct {
    int short_opt;
    const char *long_opt;
    unsigned flags;
    const char *description;
} ARGPARSE_OPTS;


void log_set_logfile( const char *name, int fd );
FILE *log_stream(void);
void g10_log_print_prefix(const char *text);
void log_set_name( const char *name );
const char *log_get_name(void);
void log_set_pid( int pid );
int log_get_errorcount( int clear );
void log_inc_errorcount(void);
int log_set_strict(int val);
void g10_log_hexdump( const char *text, const char *buf, size_t len );



  void g10_log_bug( const char *fmt, ... )
       __attribute__ ((noreturn, format (printf,1,2)));
  void g10_log_bug0( const char *, int, const char * ) __attribute__ ((noreturn));
  void g10_log_fatal( const char *fmt, ... )
       __attribute__ ((noreturn, format (printf,1,2)));
  void g10_log_error( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_info( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_warning( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_debug( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
# 121 "../include/util.h"
const char * g10_errstr( int no );


int arg_parse( ARGPARSE_ARGS *arg, ARGPARSE_OPTS *opts);
int optfile_parse( FILE *fp, const char *filename, unsigned *lineno,
     ARGPARSE_ARGS *arg, ARGPARSE_OPTS *opts);
void usage( int level );
const char *default_strusage( int level );



const char *strusage( int level );



# 1 "../include/../include/dotlock.h" 1
# 97 "../include/../include/dotlock.h"
struct dotlock_handle;
typedef struct dotlock_handle *dotlock_t;

void dotlock_disable (void);
dotlock_t dotlock_create (const char *file_to_lock, unsigned int flags);
void dotlock_set_fd (dotlock_t h, int fd);
int dotlock_get_fd (dotlock_t h);
void dotlock_destroy (dotlock_t h, int reclaim);
int dotlock_take (dotlock_t h, long timeout);
int dotlock_release (dotlock_t h);
void dotlock_remove_lockfiles (int reclaim);
void dotlock_remove_lockfiles_reclaim (void);
# 137 "../include/util.h" 2


char * make_basename(const char *filepath, const char *inputpath);
char * make_dirname(const char *filepath);
char *make_filename( const char *first_part, ... );
int compare_filenames( const char *a, const char *b );
int same_file_p (const char *name1, const char *name2);
const char *print_fname_stdin( const char *s );
const char *print_fname_stdout( const char *s );
int is_file_compressed(const char *s, int *r_status);


u32 make_timestamp(void);
u32 scan_isodatestr( const char *string );
u32 isotime2seconds (const char *string);
const char *strtimevalue( u32 stamp );
const char *strtimestamp( u32 stamp );
const char *isotimestamp( u32 stamp );
const char *asctimestamp( u32 stamp );
void print_string( FILE *fp, const byte *p, size_t n, int delim );
void print_string2( FILE *fp, const byte *p, size_t n, int delim, int delim2 );
void print_utf8_string( FILE *fp, const byte *p, size_t n );
void print_utf8_string2( FILE *fp, const byte *p, size_t n, int delim);
char *make_printable_string( const byte *p, size_t n, int delim );
int answer_is_yes_no_default( const char *s, int def_answer );
int answer_is_yes( const char *s );
int answer_is_yes_no_quit( const char *s );
int answer_is_okay_cancel (const char *s, int def_answer);
int match_multistr(const char *multistr,const char *match);


void free_strlist( STRLIST sl );

STRLIST add_to_strlist( STRLIST *list, const char *string );
STRLIST add_to_strlist2( STRLIST *list, const char *string, int is_utf8 );
STRLIST append_to_strlist( STRLIST *list, const char *string );
STRLIST append_to_strlist2( STRLIST *list, const char *string, int is_utf8 );
STRLIST strlist_prev( STRLIST head, STRLIST node );
STRLIST strlist_last( STRLIST node );
char *pop_strlist( STRLIST *list );
const char *memistr( const char *buf, size_t buflen, const char *sub );
const char *ascii_memistr( const char *buf, size_t buflen, const char *sub );
char *mem2str( char *, const void *, size_t);
char *trim_spaces( char *string );
unsigned int trim_trailing_chars( byte *line, unsigned int len,
                                  const char *trimchars);
unsigned int trim_trailing_ws( byte *line, unsigned len );
unsigned int check_trailing_chars( const byte *line, unsigned int len,
                                   const char *trimchars );
unsigned int check_trailing_ws( const byte *line, unsigned int len );
int string_count_chr( const char *string, int c );
int has_invalid_email_chars (const char *s);
int is_valid_mailbox (const char *name);
int set_native_charset( const char *newset );
const char* get_native_charset(void);
char *native_to_utf8( const char *string );
char *utf8_to_native( const char *string, size_t length, int delim);
char *string_to_utf8 (const char *string);

int ascii_isupper (int c);
int ascii_islower (int c);
int ascii_memcasecmp( const char *a, const char *b, size_t n);
char *ascii_strlwr (char *s);
# 223 "../include/util.h"
struct private_membuf_s {
  size_t len;
  size_t size;
  char *buf;
  int out_of_core;
};

typedef struct private_membuf_s membuf_t;

void init_membuf (membuf_t *mb, int initiallen);
void put_membuf (membuf_t *mb, const void *buf, size_t len);
void put_membuf_str (membuf_t *mb, const char *buf);
void *get_membuf (membuf_t *mb, size_t *len);
# 249 "../include/util.h"
char *xasprintf (const char *fmt, ...);
char *xtryasprintf (const char *fmt, ...);
char *xtryvasprintf (const char *fmt, va_list arg_ptr);
char *strconcat (const char *s1, ...) __attribute__ ((sentinel(0)));


char *get_pka_info (const char *address, void *fprbuf, size_t fprbuflen);


int get_cert (const char *name, int want_ipgp, size_t max_size, IOBUF *iobuf,
              unsigned char **fpr,size_t *fpr_len,char **url);


int hex2bin (const char *string, void *buffer, size_t length);
int hexcolon2bin (const char *string, void *buffer, size_t length);
char *bin2hex (const void *buffer, size_t length, char *stringbuf);
char *bin2hexcolon (const void *buffer, size_t length, char *stringbuf);
const char *hex2str (const char *hexstring,
                     char *buffer, size_t bufsize, size_t *buflen);
char *hex2str_alloc (const char *hexstring, size_t *r_count);
# 31 "parse-packet.c" 2



# 1 "./photoid.h" 1
# 27 "./photoid.h"
PKT_user_id *generate_photo_id(PKT_public_key *pk,const char *filename);
int parse_image_header(const struct user_attribute *attr,byte *type,u32 *len);
char *image_type_to_string(byte type,int style);
void show_photos(const struct user_attribute *attrs,int count,
   PKT_public_key *pk,PKT_secret_key *sk,PKT_user_id *uid);
# 35 "parse-packet.c" 2
# 1 "./options.h" 1
# 25 "./options.h"
# 1 "./main.h" 1
# 26 "./main.h"
# 1 "./keydb.h" 1
# 43 "./keydb.h"
struct getkey_ctx_s;
typedef struct getkey_ctx_s *GETKEY_CTX;
# 54 "./keydb.h"
struct kbnode_struct {
    KBNODE next;
    PACKET *pkt;
    int flag;
    int private_flag;
    ulong recno;
};





enum resource_type {
    rt_UNKNOWN = 0,
    rt_RING = 1
};






struct keyblock_pos_struct {
    int resno;
    enum resource_type rt;
    off_t offset;
    unsigned count;
    IOBUF fp;
    int secret;
    PACKET *pkt;
    int valid;
};
typedef struct keyblock_pos_struct KBPOS;


typedef struct pk_list *PK_LIST;
struct pk_list {
    PK_LIST next;
    PKT_public_key *pk;
    int flags;
};


typedef struct sk_list *SK_LIST;
struct sk_list {
    SK_LIST next;
    PKT_secret_key *sk;
    int mark;
};



typedef struct pubkey_find_info *PUBKEY_FIND_INFO;
struct pubkey_find_info {
    u32 keyid[2];
    unsigned nbits;
    byte pubkey_algo;
    byte fingerprint[20];
    char userid[1];
};


typedef struct keydb_handle *KEYDB_HANDLE;

typedef enum {
    KEYDB_SEARCH_MODE_NONE,
    KEYDB_SEARCH_MODE_EXACT,
    KEYDB_SEARCH_MODE_SUBSTR,
    KEYDB_SEARCH_MODE_MAIL,
    KEYDB_SEARCH_MODE_MAILSUB,
    KEYDB_SEARCH_MODE_MAILEND,
    KEYDB_SEARCH_MODE_WORDS,
    KEYDB_SEARCH_MODE_SHORT_KID,
    KEYDB_SEARCH_MODE_LONG_KID,
    KEYDB_SEARCH_MODE_FPR16,
    KEYDB_SEARCH_MODE_FPR20,
    KEYDB_SEARCH_MODE_FPR,
    KEYDB_SEARCH_MODE_FIRST,
    KEYDB_SEARCH_MODE_NEXT
} KeydbSearchMode;

struct keydb_search_desc {
    KeydbSearchMode mode;
    int (*skipfnc)(void *,u32*,PKT_user_id*);
    void *skipfncvalue;
    union {
        const char *name;
        byte fpr[20];
        u32 kid[2];
    } u;
    int exact;
};







int keydb_add_resource (const char *url, int flags, int secret);
KEYDB_HANDLE keydb_new (int secret);
void keydb_release (KEYDB_HANDLE hd);
const char *keydb_get_resource_name (KEYDB_HANDLE hd);
int keydb_get_keyblock (KEYDB_HANDLE hd, KBNODE *ret_kb);
int keydb_update_keyblock (KEYDB_HANDLE hd, KBNODE kb);
int keydb_insert_keyblock (KEYDB_HANDLE hd, KBNODE kb);
int keydb_delete_keyblock (KEYDB_HANDLE hd);
int keydb_locate_writable (KEYDB_HANDLE hd, const char *reserved);
void keydb_rebuild_caches (int noisy);
int keydb_search_reset (KEYDB_HANDLE hd);

int keydb_search2 (KEYDB_HANDLE hd, KEYDB_SEARCH_DESC *desc,
     size_t ndesc, size_t *descindex);
int keydb_search_first (KEYDB_HANDLE hd);
int keydb_search_next (KEYDB_HANDLE hd);
int keydb_search_kid (KEYDB_HANDLE hd, u32 *kid);
int keydb_search_fpr (KEYDB_HANDLE hd, const byte *fpr);



void show_revocation_reason( PKT_public_key *pk, int mode );
int check_signatures_trust( PKT_signature *sig );
void release_pk_list( PK_LIST pk_list );
int build_pk_list( STRLIST rcpts, PK_LIST *ret_pk_list, unsigned use );
union pref_hint
{
  int digest_length;
};
int algo_available( preftype_t preftype, int algo,
       const union pref_hint *hint );
int select_algo_from_prefs( PK_LIST pk_list, int preftype,
        int request, const union pref_hint *hint );
int select_mdc_from_pklist (PK_LIST pk_list);


void release_sk_list( SK_LIST sk_list );
int build_sk_list( STRLIST locusr, SK_LIST *ret_sk_list,
         int unlock, unsigned use );
# 200 "./keydb.h"
typedef int assuan_error_t;
typedef void *assuan_context_t;

int have_static_passphrase(void);
void set_passphrase_from_string(const char *pass);
void read_passphrase_from_fd( int fd );
void passphrase_clear_cache ( u32 *keyid, const char *cacheid, int algo );
char *ask_passphrase (const char *description,
                      const char *tryagain_text,
                      const char *promptid,
                      const char *prompt,
                      const char *cacheid, int *canceled);
DEK *passphrase_to_dek( u32 *keyid, int pubkey_algo,
   int cipher_algo, STRING2KEY *s2k, int mode,
                        const char *tryagain_text, int *canceled);
void set_next_passphrase( const char *s );
char *get_last_passphrase(void);
void next_to_last_passphrase(void);


int classify_user_id( const char *name, KEYDB_SEARCH_DESC *desc);
void cache_public_key( PKT_public_key *pk );
void getkey_disable_caches(void);
int get_pubkey( PKT_public_key *pk, u32 *keyid );
int get_pubkey_fast ( PKT_public_key *pk, u32 *keyid );
KBNODE get_pubkeyblock( u32 *keyid );
int get_pubkey_byname( PKT_public_key *pk, const char *name,
                       KBNODE *ret_keyblock, KEYDB_HANDLE *ret_kdbhd,
         int include_unusable );
int get_pubkey_bynames( GETKEY_CTX *rx, PKT_public_key *pk,
   STRLIST names, KBNODE *ret_keyblock );
int get_pubkey_next( GETKEY_CTX ctx, PKT_public_key *pk, KBNODE *ret_keyblock );
void get_pubkey_end( GETKEY_CTX ctx );
int get_seckey( PKT_secret_key *sk, u32 *keyid );
int get_primary_seckey( PKT_secret_key *sk, u32 *keyid );
int get_pubkey_byfprint( PKT_public_key *pk, const byte *fprint,
       size_t fprint_len );
int get_pubkey_byfprint_fast (PKT_public_key *pk,
                              const byte *fprint, size_t fprint_len);
int get_keyblock_byfprint( KBNODE *ret_keyblock, const byte *fprint,
       size_t fprint_len );
int get_keyblock_bylid( KBNODE *ret_keyblock, ulong lid );
int seckey_available( u32 *keyid );
int get_seckey_byname( PKT_secret_key *sk, const char *name, int unlock );
int get_seckey_bynames( GETKEY_CTX *rx, PKT_secret_key *sk,
   STRLIST names, KBNODE *ret_keyblock );
int get_seckey_next (GETKEY_CTX ctx, PKT_secret_key *sk, KBNODE *ret_keyblock);
void get_seckey_end( GETKEY_CTX ctx );

int get_seckey_byfprint( PKT_secret_key *sk,
    const byte *fprint, size_t fprint_len);
int get_seckeyblock_byfprint (KBNODE *ret_keyblock, const byte *fprint,
                              size_t fprint_len );


int enum_secret_keys( void **context, PKT_secret_key *sk,
        int with_subkeys, int with_spm );
void merge_keys_and_selfsig( KBNODE keyblock );
char*get_user_id_string( u32 *keyid );
char*get_user_id_string_native( u32 *keyid );
char*get_long_user_id_string( u32 *keyid );
char*get_user_id( u32 *keyid, size_t *rn );
char*get_user_id_native( u32 *keyid );
KEYDB_HANDLE get_ctx_handle(GETKEY_CTX ctx);
void release_akl(void);
int parse_auto_key_locate(char *options);


int pubkey_letter( int algo );
void hash_public_key( MD_HANDLE md, PKT_public_key *pk );
size_t keystrlen(void);
const char *keystr(u32 *keyid);
const char *keystr_from_pk(PKT_public_key *pk);
const char *keystr_from_sk(PKT_secret_key *sk);
const char *keystr_from_desc(KEYDB_SEARCH_DESC *desc);
u32 keyid_from_sk( PKT_secret_key *sk, u32 *keyid );
u32 keyid_from_pk( PKT_public_key *pk, u32 *keyid );
u32 keyid_from_sig( PKT_signature *sig, u32 *keyid );
u32 keyid_from_fingerprint(const byte *fprint, size_t fprint_len, u32 *keyid);
byte *namehash_from_uid(PKT_user_id *uid);
unsigned nbits_from_pk( PKT_public_key *pk );
unsigned nbits_from_sk( PKT_secret_key *sk );
const char *datestr_from_pk( PKT_public_key *pk );
const char *datestr_from_sk( PKT_secret_key *sk );
const char *datestr_from_sig( PKT_signature *sig );
const char *expirestr_from_pk( PKT_public_key *pk );
const char *expirestr_from_sk( PKT_secret_key *sk );
const char *expirestr_from_sig( PKT_signature *sig );
const char *revokestr_from_pk( PKT_public_key *pk );
const char *usagestr_from_pk( PKT_public_key *pk );
const char *colon_strtime (u32 t);
const char *colon_datestr_from_pk (PKT_public_key *pk);
const char *colon_datestr_from_sk (PKT_secret_key *sk);
const char *colon_datestr_from_sig (PKT_signature *sig);
const char *colon_expirestr_from_sig (PKT_signature *sig);
byte *fingerprint_from_sk( PKT_secret_key *sk, byte *buf, size_t *ret_len );
byte *fingerprint_from_pk( PKT_public_key *pk, byte *buf, size_t *ret_len );


KBNODE new_kbnode( PACKET *pkt );
KBNODE clone_kbnode( KBNODE node );
void release_kbnode( KBNODE n );
void delete_kbnode( KBNODE node );
void add_kbnode( KBNODE root, KBNODE node );
void insert_kbnode( KBNODE root, KBNODE node, int pkttype );
void move_kbnode( KBNODE *root, KBNODE node, KBNODE where );
void remove_kbnode( KBNODE *root, KBNODE node );
KBNODE find_prev_kbnode( KBNODE root, KBNODE node, int pkttype );
KBNODE find_next_kbnode( KBNODE node, int pkttype );
KBNODE find_kbnode( KBNODE node, int pkttype );
KBNODE walk_kbnode( KBNODE root, KBNODE *context, int all );
void clear_kbnode_flags( KBNODE n );
int commit_kbnode( KBNODE *root );
void dump_kbnode( KBNODE node );
# 27 "./main.h" 2
# 47 "./main.h"
typedef struct
{
  int header_okay;
  PK_LIST pk_list;
  DEK *symkey_dek;
  STRING2KEY *symkey_s2k;
  cipher_filter_context_t cfx;
} encrypt_filter_context_t;

struct groupitem
{
  char *name;
  STRLIST values;
  struct groupitem *next;
};

struct weakhash
{
  int algo;
  int rejection_shown;
  struct weakhash *next;
};



extern int g10_errors_seen;


  void g10_exit(int rc) __attribute__ ((noreturn));



void print_pubkey_algo_note( int algo );
void print_cipher_algo_note( int algo );
void print_digest_algo_note( int algo );
void additional_weak_digest (const char* digestname);


char *make_radix64_string( const byte *data, size_t len );
int parse_key_failed_line (const void *lineptr, unsigned int len);


void trap_unaligned(void);
int disable_core_dumps(void);
void register_secured_file (const char *fname);
void unregister_secured_file (const char *fname);
int is_secured_file (int fd);
int is_secured_filename (const char *fname);
u16 checksum_u16( unsigned n );
u16 checksum( byte *p, unsigned n );
u16 checksum_mpi( MPI a );
u32 buffer_to_u32( const byte *buffer );
const byte *get_session_marker( size_t *rlen );
int openpgp_cipher_test_algo( int algo );
int openpgp_pk_test_algo( int algo, unsigned int usage_flags );
int openpgp_pk_algo_usage ( int algo );
int openpgp_md_test_algo( int algo );

void md5_digest_warn (int show);

void not_in_gpg1_notice (void);

struct expando_args
{
  PKT_public_key *pk;
  PKT_secret_key *sk;
  byte imagetype;
  int validity_info;
  const char *validity_string;
};

char *pct_expando(const char *string,struct expando_args *args);
void deprecated_warning(const char *configname,unsigned int configlineno,
   const char *option,const char *repl1,const char *repl2);
void deprecated_command (const char *name);

const char *compress_algo_to_string(int algo);
int string_to_compress_algo(const char *string);
int check_compress_algo(int algo);
int default_cipher_algo(void);
int default_compress_algo(void);
const char *compliance_option_string(void);
void compliance_failure(void);

struct parse_options
{
  char *name;
  unsigned int bit;
  char **value;
  char *help;
};

char *optsep(char **stringp);
char *argsplit(char *string);
int parse_options(char *str,unsigned int *options,
    struct parse_options *opts,int noisy);
char *unescape_percent_string (const unsigned char *s);
char *default_homedir (void);
const char *get_libexecdir (void);
int path_access(const char *file,int mode);


void display_online_help( const char *keyword );


int setup_symkey(STRING2KEY **symkey_s2k,DEK **symkey_dek);
int encode_symmetric( const char *filename );
int encode_store( const char *filename );
int encode_crypt( const char *filename, STRLIST remusr, int use_symkey );
void encode_crypt_files(int nfiles, char **files, STRLIST remusr);
int encrypt_filter( void *opaque, int control,
      IOBUF a, byte *buf, size_t *ret_len);



int complete_sig( PKT_signature *sig, PKT_secret_key *sk, MD_HANDLE md );
int sign_file( STRLIST filenames, int detached, STRLIST locusr,
        int do_encrypt, STRLIST remusr, const char *outfile );
int clearsign_file( const char *fname, STRLIST locusr, const char *outfile );
int sign_symencrypt_file (const char *fname, STRLIST locusr);


int check_revocation_keys (PKT_public_key *pk, PKT_signature *sig);
int check_backsig(PKT_public_key *main_pk,PKT_public_key *sub_pk,
    PKT_signature *backsig);
int check_key_signature( KBNODE root, KBNODE node, int *is_selfsig );
int check_key_signature2( KBNODE root, KBNODE node, PKT_public_key *check_pk,
     PKT_public_key *ret_pk, int *is_selfsig,
     u32 *r_expiredate, int *r_expired );


int delete_keys( STRLIST names, int secret, int allow_both );


void keyedit_menu( const char *username, STRLIST locusr,
     STRLIST commands, int quiet, int seckey_check );
void show_basic_key_info (KBNODE keyblock);


u32 parse_expire_string(u32 timestamp,const char *string);
u32 ask_expire_interval(u32 timestamp,int object,const char *def_expire);
void generate_keypair( const char *fname, const char *card_serialno,
                       const char *backup_encryption_dir );
int keygen_set_std_prefs (const char *string,int personal);
PKT_user_id *keygen_get_std_prefs (void);
int keygen_add_key_expire( PKT_signature *sig, void *opaque );
int keygen_add_std_prefs( PKT_signature *sig, void *opaque );
int keygen_upd_std_prefs( PKT_signature *sig, void *opaque );
int keygen_add_keyserver_url(PKT_signature *sig, void *opaque);
int keygen_add_notations(PKT_signature *sig,void *opaque);
int keygen_add_revkey(PKT_signature *sig, void *opaque);
int make_backsig(PKT_signature *sig,PKT_public_key *pk,
   PKT_public_key *sub_pk,PKT_secret_key *sub_sk,
                 u32 timestamp);
int generate_subkeypair( KBNODE pub_keyblock, KBNODE sec_keyblock );

int generate_card_subkeypair (KBNODE pub_keyblock, KBNODE sec_keyblock,
                              int keyno, const char *serialno);
int save_unprotected_key_to_card (PKT_secret_key *sk, int keyno);



int overwrite_filep( const char *fname );
char *make_outfile_name( const char *iname );
char *ask_outfile_name( const char *name, size_t namelen );
int open_outfile( const char *iname, int mode, IOBUF *a );
char *get_matching_datafile (const char *sigfilename);
IOBUF open_sigfile( const char *iname, progress_filter_context_t *pfx );
void try_make_homedir( const char *fname );


void make_session_key( DEK *dek );
MPI encode_session_key( DEK *dek, unsigned nbits );
MPI pkcs1_encode_md( MD_HANDLE md, int algo, size_t len, unsigned nbits,
       const byte *asn, size_t asnlen );
MPI encode_md_value( PKT_public_key *pk, PKT_secret_key *sk,
       MD_HANDLE md, int hash_algo );



typedef int (*import_filter_t)(kbnode_t keyblock, void *arg);

int parse_import_options(char *str,unsigned int *options,int noisy);
void import_keys( char **fnames, int nnames,
    void *stats_hd, unsigned int options );
int import_keys_stream (IOBUF inp,void *stats_hd,unsigned char **fpr,
                        size_t *fpr_len,unsigned int options,
                        import_filter_t filter, void *filter_arg,
                        int *r_gpgkeys_err);
void *import_new_stats_handle (void);
void import_release_stats_handle (void *p);
void import_print_stats (void *hd);

int collapse_uids( KBNODE *keyblock );

int auto_create_card_key_stub ( const char *serialnostr,
                                const unsigned char *fpr1,
                                const unsigned char *fpr2,
                                const unsigned char *fpr3);


int parse_export_options(char *str,unsigned int *options,int noisy);
int export_pubkeys( STRLIST users, unsigned int options );
int export_pubkeys_stream( IOBUF out, STRLIST users,
      KBNODE *keyblock_out, unsigned int options );
int export_seckeys( STRLIST users );
int export_secsubkeys( STRLIST users );


int dearmor_file( const char *fname );
int enarmor_file( const char *fname );


struct revocation_reason_info;
int gen_revoke( const char *uname );
int gen_desig_revoke( const char *uname, STRLIST locusr);
int revocation_reason_build_cb( PKT_signature *sig, void *opaque );
struct revocation_reason_info *
  ask_revocation_reason( int key_rev, int cert_rev, int hint );
void release_revocation_reason_info( struct revocation_reason_info *reason );


void public_key_list( STRLIST list );
void secret_key_list( STRLIST list );
void print_subpackets_colon(PKT_signature *sig);
void reorder_keyblock (KBNODE keyblock);
void list_keyblock( KBNODE keyblock, int secret, int fpr, void *opaque );
void print_fingerprint (PKT_public_key *pk, PKT_secret_key *sk, int mode);
void print_revokers(PKT_public_key *pk);
void show_policy_url(PKT_signature *sig,int indent,int mode);
void show_keyserver_url(PKT_signature *sig,int indent,int mode);
void show_notation(PKT_signature *sig,int indent,int mode,int which);
void dump_attribs(const PKT_user_id *uid,
    PKT_public_key *pk,PKT_secret_key *sk);
void set_attrib_fd(int fd);
void print_seckey_info (PKT_secret_key *sk);
void print_pubkey_info (FILE *fp, PKT_public_key *pk);
void print_card_key_info (FILE *fp, KBNODE keyblock);


void print_file_status( int status, const char *name, int what );
int verify_signatures( int nfiles, char **files );
int verify_files( int nfiles, char **files );


int decrypt_message( const char *filename );
void decrypt_messages(int nfiles, char *files[]);


int hash_datafiles( MD_HANDLE md, MD_HANDLE md2,
      STRLIST files, const char *sigfilename, int textmode );
PKT_plaintext *setup_plaintext_name(const char *filename,IOBUF iobuf);


void run_in_pipemode (void);


void init_signals(void);
void pause_on_sigusr( int which );
void block_all_signals(void);
void unblock_all_signals(void);




void change_pin (int no, int allow_admin);
void card_status (FILE *fp, char *serialno, size_t serialnobuflen);
void card_edit (STRLIST commands);
int card_generate_subkey (KBNODE pub_keyblock, KBNODE sec_keyblock);
int card_store_subkey (KBNODE node, int use);
# 26 "./options.h" 2
# 39 "./options.h"
struct
{
  int verbose;
  int quiet;
  unsigned debug;
  int armor;
  char *outfile;
  off_t max_output;
  int dry_run;
  int list_only;
  int textmode;
  int expert;
  const char *def_sig_expire;
  int ask_sig_expire;
  const char *def_cert_expire;
  int ask_cert_expire;
  int batch;
  int answer_yes;
  int answer_no;
  int check_sigs;
  int with_colons;
  int with_key_data;
  int with_fingerprint;
  int fingerprint;
  int list_sigs;
  int no_armor;
  int list_packets;
  int def_cipher_algo;
  int force_v3_sigs;
  int force_v4_certs;
  int force_mdc;
  int disable_mdc;
  int def_digest_algo;
  int cert_digest_algo;
  int compress_algo;
  int compress_level;
  int bz2_compress_level;
  int bz2_decompress_lowmem;
  const char *def_secret_key;
  char *def_recipient;
  int def_recipient_self;
  int def_cert_level;
  int min_cert_level;
  int ask_cert_level;
  int emit_version;




  int marginals_needed;
  int completes_needed;
  int max_cert_depth;
  const char *homedir;

  char *display;
  char *ttyname;
  char *ttytype;
  char *lc_ctype;
  char *lc_messages;

  int skip_verify;
  int compress_keys;
  int compress_sigs;


  enum
    {
      TM_CLASSIC=0, TM_PGP=1, TM_EXTERNAL=2, TM_ALWAYS, TM_DIRECT, TM_AUTO
    } trust_model;
  int force_ownertrust;
  enum
    {
      CO_GNUPG, CO_RFC4880, CO_RFC2440, CO_RFC1991, CO_PGP2,
      CO_PGP6, CO_PGP7, CO_PGP8
    } compliance;
  enum
    {
      KF_SHORT, KF_LONG, KF_0xSHORT, KF_0xLONG
    } keyid_format;
  int pgp2_workarounds;
  int shm_coprocess;
  const char *set_filename;
  STRLIST comments;
  int throw_keyid;
  const char *photo_viewer;
  int s2k_mode;
  int s2k_digest_algo;
  int s2k_cipher_algo;
  unsigned char s2k_count;

  int simple_sk_checksum;

  int not_dash_escaped;
  int escape_from;
  int lock_once;
  struct keyserver_spec
  {
    char *uri;
    char *scheme;
    char *auth;
    char *host;
    char *port;
    char *path;
    char *opaque;
    STRLIST options;
    struct
    {
      unsigned int direct_uri:1;
    } flags;
    struct keyserver_spec *next;
  } *keyserver;
  struct
  {
    unsigned int options;
    unsigned int import_options;
    unsigned int export_options;
    STRLIST other;
  } keyserver_options;
  int exec_disable;
  int exec_path_set;
  unsigned int import_options;
  unsigned int export_options;
  unsigned int list_options;
  unsigned int verify_options;
  const char *def_preference_list;
  const char *def_keyserver_url;
  prefitem_t *personal_cipher_prefs;
  prefitem_t *personal_digest_prefs;
  prefitem_t *personal_compress_prefs;
  struct weakhash *weak_digests;
  int no_perm_warn;
  int no_mdc_warn;
  char *temp_dir;
  int no_encrypt_to;
  int interactive;
  struct notation *sig_notations;
  struct notation *cert_notations;
  STRLIST sig_policy_url;
  STRLIST cert_policy_url;
  STRLIST sig_keyserver_url;
  STRLIST cert_subpackets;
  STRLIST sig_subpackets;
  int allow_non_selfsigned_uid;
  int allow_freeform_uid;
  int no_literal;
  ulong set_filesize;
  int fast_list_mode;
  int fixed_list_mode;
  int ignore_time_conflict;
  int ignore_valid_from;
  int ignore_crc_error;
  int ignore_mdc_error;
  int command_fd;
  const char *override_session_key;
  int show_session_key;
  int use_agent;
  const char *gpg_agent_info;
  int try_all_secrets;
  int no_expensive_trust_checks;
  int no_sig_cache;
  int no_auto_check_trustdb;
  int preserve_permissions;
  int no_homedir_creation;
  struct groupitem *grouplist;
  int strict;
  int mangle_dos_filenames;
  int enable_progress_filter;
  unsigned int screen_columns;
  unsigned int screen_lines;
  byte *show_subpackets;
  int rfc2440_text;


  int exit_on_status_write_error;



  int limit_card_insert_tries;


  const char *ctapi_driver;
  const char *pcsc_driver;
  int disable_ccid;
  int disable_keypad;


  struct
  {



    unsigned int require_cross_cert:1;
    unsigned int use_embedded_filename:1;
    unsigned int utf8_filename:1;
    unsigned int dsa2:1;
    unsigned int allow_multiple_messages:1;
    unsigned int allow_weak_digest_algos:1;
    unsigned int large_rsa:1;
  } flags;



  struct akl
  {
    enum {AKL_CERT, AKL_PKA, AKL_LDAP, AKL_KEYSERVER, AKL_SPEC} type;
    struct keyserver_spec *spec;
    struct akl *next;
  } *auto_key_locate;

  int passwd_repeat;
} opt;





struct {
  int in_auto_key_retrieve;

} glo_ctrl;
# 36 "parse-packet.c" 2

# 1 "../include/i18n.h" 1
# 32 "../include/i18n.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 1 3
# 26 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 3
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;

 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_p_sep_by_space;
 char int_n_cs_precedes;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};


char *setlocale (int, const char *);
struct lconv *localeconv(void);







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 65 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 2 3
# 76 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 3
locale_t duplocale(locale_t);
void freelocale(locale_t);
locale_t newlocale(int, const char *, locale_t);
locale_t uselocale(locale_t);
# 33 "../include/i18n.h" 2




# 1 "../intl/libintl.h" 1
# 58 "../intl/libintl.h"
extern int libintl_version;
# 134 "../intl/libintl.h"
extern char *gettext (const char *__msgid)
       __asm__ ("" "libintl_gettext")
       __attribute__ ((__format_arg__ (1)));
# 152 "../intl/libintl.h"
extern char *dgettext (const char *__domainname, const char *__msgid)
       __asm__ ("" "libintl_dgettext")
       __attribute__ ((__format_arg__ (2)));
# 172 "../intl/libintl.h"
extern char *dcgettext (const char *__domainname, const char *__msgid,
                        int __category)
       __asm__ ("" "libintl_dcgettext")
       __attribute__ ((__format_arg__ (2)));
# 194 "../intl/libintl.h"
extern char *ngettext (const char *__msgid1, const char *__msgid2,
                       unsigned long int __n)
       __asm__ ("" "libintl_ngettext")
       __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));
# 215 "../intl/libintl.h"
extern char *dngettext (const char *__domainname,
                        const char *__msgid1, const char *__msgid2,
                        unsigned long int __n)
       __asm__ ("" "libintl_dngettext")
       __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
# 239 "../intl/libintl.h"
extern char *dcngettext (const char *__domainname,
                         const char *__msgid1, const char *__msgid2,
                         unsigned long int __n, int __category)
       __asm__ ("" "libintl_dcngettext")
       __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
# 261 "../intl/libintl.h"
extern char *textdomain (const char *__domainname)
       __asm__ ("" "libintl_textdomain");
# 279 "../intl/libintl.h"
extern char *bindtextdomain (const char *__domainname, const char *__dirname)
       __asm__ ("" "libintl_bindtextdomain");
# 297 "../intl/libintl.h"
extern char *bind_textdomain_codeset (const char *__domainname,
                                      const char *__codeset)
       __asm__ ("" "libintl_bind_textdomain_codeset");
# 455 "../intl/libintl.h"
extern void
       libintl_set_relocation_prefix (const char *orig_prefix,
                                      const char *curr_prefix);
# 38 "../include/i18n.h" 2
# 38 "parse-packet.c" 2
# 1 "../include/host2net.h" 1
# 37 "../include/host2net.h"
static inline unsigned long
buf16_to_ulong (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned long)p[0] << 8) | p[1]);
}

static inline unsigned int
buf16_to_uint (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned int)p[0] << 8) | p[1]);
}

static inline unsigned short
buf16_to_ushort (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned short)p[0] << 8) | p[1]);
}

static inline u16
buf16_to_u16 (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((u16)p[0] << 8) | p[1]);
}

static inline size_t
buf32_to_size_t (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((size_t)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}

static inline unsigned long
buf32_to_ulong (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned long)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}

static inline unsigned int
buf32_to_uint (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned int)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}

static inline u32
buf32_to_u32 (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((u32)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}
# 39 "parse-packet.c" 2
# 51 "parse-packet.c"
static int mpi_print_mode;
static int list_mode;
static FILE *listfp;

static int parse( IOBUF inp, PACKET *pkt, int onlykeypkts,
                  off_t *retpos, int *skip, IOBUF out, int do_skip

     ,const char *dbg_w, const char *dbg_f, int dbg_l

   );
static int copy_packet( IOBUF inp, IOBUF out, int pkttype,
    unsigned long pktlen, int partial );
static void skip_packet( IOBUF inp, int pkttype,
    unsigned long pktlen, int partial );
static void *read_rest( IOBUF inp, size_t pktlen, int partial );
static int parse_marker( IOBUF inp, int pkttype, unsigned long pktlen );
static int parse_symkeyenc( IOBUF inp, int pkttype, unsigned long pktlen,
            PACKET *packet );
static int parse_pubkeyenc( IOBUF inp, int pkttype, unsigned long pktlen,
            PACKET *packet );
static int parse_onepass_sig( IOBUF inp, int pkttype, unsigned long pktlen,
       PKT_onepass_sig *ops );
static int parse_key( IOBUF inp, int pkttype, unsigned long pktlen,
          byte *hdr, int hdrlen, PACKET *packet );
static int parse_user_id( IOBUF inp, int pkttype, unsigned long pktlen,
          PACKET *packet );
static int parse_attribute( IOBUF inp, int pkttype, unsigned long pktlen,
          PACKET *packet );
static int parse_comment( IOBUF inp, int pkttype, unsigned long pktlen,
          PACKET *packet );
static void parse_trust( IOBUF inp, int pkttype, unsigned long pktlen,
          PACKET *packet );
static int parse_plaintext( IOBUF inp, int pkttype, unsigned long pktlen,
        PACKET *packet, int new_ctb, int partial);
static int parse_compressed( IOBUF inp, int pkttype, unsigned long pktlen,
            PACKET *packet, int new_ctb );
static int parse_encrypted( IOBUF inp, int pkttype, unsigned long pktlen,
        PACKET *packet, int new_ctb, int partial);
static int parse_mdc( IOBUF inp, int pkttype, unsigned long pktlen,
            PACKET *packet, int new_ctb);
static int parse_gpg_control( IOBUF inp, int pkttype, unsigned long pktlen,
                               PACKET *packet, int partial );

static unsigned short
read_16(IOBUF inp)
{
    unsigned short a;
    a = (unsigned short)(( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff) << 8;
    a |= (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
    return a;
}

static unsigned long
read_32(IOBUF inp)
{
    unsigned long a;
    a = (unsigned long)(( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff) << 24;
    a |= (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff) << 16;
    a |= (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff) << 8;
    a |= (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
    return a;
}


int
set_packet_list_mode( int mode )
{
    int old = list_mode;
    list_mode = mode;
    mpi_print_mode = mpi_debug_mode;
# 136 "parse-packet.c"
    if (!listfp)
        listfp = opt.list_packets ? (stdout) : (stderr);
    return old;
}

static void
unknown_pubkey_warning( int algo )
{
    static byte unknown_pubkey_algos[256];

    algo &= 0xff;
    if( !unknown_pubkey_algos[algo] ) {
 if( opt.verbose )
     g10_log_info(gettext ("can't handle public key algorithm %d\n"), algo );
 unknown_pubkey_algos[algo] = 1;
    }
}
# 163 "parse-packet.c"
int
dbg_parse_packet( IOBUF inp, PACKET *pkt, const char *dbg_f, int dbg_l )
{
    int skip, rc;

    do {
 rc = parse( inp, pkt, 0, ((void*)0), &skip, ((void*)0), 0, "parse", dbg_f, dbg_l );
    } while( skip );
    return rc;
}
# 190 "parse-packet.c"
int
dbg_search_packet( IOBUF inp, PACKET *pkt, off_t *retpos, int with_uid,
     const char *dbg_f, int dbg_l )
{
    int skip, rc;

    do {
 rc = parse( inp, pkt, with_uid?2:1, retpos, &skip, ((void*)0), 0, "search", dbg_f, dbg_l );
    } while( skip );
    return rc;
}
# 218 "parse-packet.c"
int
dbg_copy_all_packets( IOBUF inp, IOBUF out,
     const char *dbg_f, int dbg_l )
{
    PACKET pkt;
    int skip, rc=0;
    do {
 do { (&pkt)->pkttype = 0; (&pkt)->pkt.generic = ((void*)0); } while(0);
    } while( !(rc = parse( inp, &pkt, 0, ((void*)0), &skip, out, 0, "copy", dbg_f, dbg_l )));
    return rc;
}
# 247 "parse-packet.c"
int
dbg_copy_some_packets( IOBUF inp, IOBUF out, off_t stopoff,
     const char *dbg_f, int dbg_l )
{
    PACKET pkt;
    int skip, rc=0;
    do {
 if( iobuf_tell(inp) >= stopoff )
     return 0;
 do { (&pkt)->pkttype = 0; (&pkt)->pkt.generic = ((void*)0); } while(0);
    } while( !(rc = parse( inp, &pkt, 0, ((void*)0), &skip, out, 0,
         "some", dbg_f, dbg_l )) );
    return rc;
}
# 280 "parse-packet.c"
int
dbg_skip_some_packets( IOBUF inp, unsigned n,
     const char *dbg_f, int dbg_l )
{
    int skip, rc=0;
    PACKET pkt;

    for( ;n && !rc; n--) {
 do { (&pkt)->pkttype = 0; (&pkt)->pkt.generic = ((void*)0); } while(0);
 rc = parse( inp, &pkt, 0, ((void*)0), &skip, ((void*)0), 1, "skip", dbg_f, dbg_l );
    }
    return rc;
}
# 316 "parse-packet.c"
static int
parse( IOBUF inp, PACKET *pkt, int onlykeypkts, off_t *retpos,
       int *skip, IOBUF out, int do_skip

       ,const char *dbg_w, const char *dbg_f, int dbg_l

     )
{
    int rc=0, c, ctb, pkttype, lenbytes;
    unsigned long pktlen;
    byte hdr[8];
    int hdrlen;
    int new_ctb = 0, partial=0;
    int with_uid = (onlykeypkts == 2);

    *skip = 0;
    ((void)((!pkt->pkt.generic) || (__assert_fail("!pkt->pkt.generic", "parse-packet.c", 332, __func__),0)));
    if( retpos )
 *retpos = iobuf_tell(inp);

    if( (ctb = ( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )) == -1 ) {
 rc = -1;
 goto leave;
    }
    hdrlen=0;
    hdr[hdrlen++] = ctb;
    if( !(ctb & 0x80) ) {
        g10_log_error("%s: invalid packet (ctb=%02x)\n", "[don't know]", ctb );
 rc = 14;
 goto leave;
    }
    pktlen = 0;
    new_ctb = !!(ctb & 0x40);
    if( new_ctb ) {
        pkttype = ctb & 0x3f;
 if( (c = ( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )) == -1 ) {
     g10_log_error("%s: 1st length byte missing\n", "[don't know]" );
     rc = 14;
     goto leave;
 }
# 368 "parse-packet.c"
        {
             hdr[hdrlen++] = c;
             if( c < 192 )
        pktlen = c;
             else if( c < 224 )
        {
   pktlen = (c - 192) * 256;
   if( (c = ( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )) == -1 )
     {
       g10_log_error("%s: 2nd length byte missing\n",
          "[don't know]" );
       rc = 14;
       goto leave;
     }
   hdr[hdrlen++] = c;
   pktlen += c + 192;
        }
             else if( c == 255 )
        {
   pktlen =
                   (unsigned long)(hdr[hdrlen++] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff)) << 24;
   pktlen |= (hdr[hdrlen++] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff)) << 16;
   pktlen |= (hdr[hdrlen++] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff)) << 8;
   if( (c = ( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )) == -1 )
     {
       g10_log_error("%s: 4 byte length invalid\n",
          "[don't know]" );
       rc = 14;
       goto leave;
     }
   pktlen |= (hdr[hdrlen++] = c );
        }
             else
        {

   switch (pkttype)
                   {
                   case PKT_PLAINTEXT:
                   case PKT_ENCRYPTED:
                   case PKT_ENCRYPTED_MDC:
                   case PKT_COMPRESSED:
       iobuf_set_partial_block_mode (inp, (c & 0xff));
       pktlen = 0;
       partial= 1;
       break;

                   default:
       g10_log_error ("%s: partial length for invalid"
                                " packet type %d\n", "[don't know]",pkttype);
       rc = 14;
       goto leave;
     }
        }
 }
    }
    else
      {
 pkttype = (ctb>>2)&0xf;
 lenbytes = ((ctb&3)==3)? 0 : (1<<(ctb & 3));
 if( !lenbytes )
   {
     pktlen = 0;


     partial=1;
     if(pkttype!=PKT_ENCRYPTED && pkttype!=PKT_PLAINTEXT
        && pkttype!=PKT_COMPRESSED)
       {
  g10_log_error ("%s: indeterminate length for invalid"
      " packet type %d\n", "[don't know]", pkttype );
  rc = 14;
  goto leave;
       }
   }
 else
   {
     for( ; lenbytes; lenbytes-- )
       {
  pktlen <<= 8;
  pktlen |= hdr[hdrlen++] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
       }
   }
      }

    if (pktlen == (unsigned long)(-1)) {



        g10_log_error ("%s: garbled packet detected\n", "[don't know]" );
 g10_exit (2);
    }

    if( out && pkttype ) {
 if( iobuf_write( out, hdr, hdrlen ) == -1 )
     rc = 22;
 else
     rc = copy_packet(inp, out, pkttype, pktlen, partial );
 goto leave;
    }

    if (with_uid && pkttype == PKT_USER_ID)
        ;
    else if( do_skip
        || !pkttype
        || (onlykeypkts && pkttype != PKT_PUBLIC_SUBKEY
                        && pkttype != PKT_PUBLIC_KEY
                        && pkttype != PKT_SECRET_SUBKEY
                        && pkttype != PKT_SECRET_KEY ) ) {
 iobuf_skip_rest(inp, pktlen, partial);
 *skip = 1;
 rc = 0;
 goto leave;
    }

    if( (opt.debug & 1) ) {

 g10_log_debug("parse_packet(iob=%d): type=%d length=%lu%s (%s.%s.%d)\n",
     ((inp)->no), pkttype, pktlen, new_ctb?" (new_ctb)":"",
      dbg_w, dbg_f, dbg_l );




    }
    pkt->pkttype = pkttype;
    rc = 2;
    switch( pkttype ) {
      case PKT_PUBLIC_KEY:
      case PKT_PUBLIC_SUBKEY:
 pkt->pkt.public_key = xmalloc_clear(sizeof *pkt->pkt.public_key );
 rc = parse_key(inp, pkttype, pktlen, hdr, hdrlen, pkt );
 break;
      case PKT_SECRET_KEY:
      case PKT_SECRET_SUBKEY:
 pkt->pkt.secret_key = xmalloc_clear(sizeof *pkt->pkt.secret_key );
 rc = parse_key(inp, pkttype, pktlen, hdr, hdrlen, pkt );
 break;
      case PKT_SYMKEY_ENC:
 rc = parse_symkeyenc( inp, pkttype, pktlen, pkt );
 break;
      case PKT_PUBKEY_ENC:
 rc = parse_pubkeyenc(inp, pkttype, pktlen, pkt );
 break;
      case PKT_SIGNATURE:
 pkt->pkt.signature = xmalloc_clear(sizeof *pkt->pkt.signature );
 rc = parse_signature(inp, pkttype, pktlen, pkt->pkt.signature );
 break;
      case PKT_ONEPASS_SIG:
 pkt->pkt.onepass_sig = xmalloc_clear(sizeof *pkt->pkt.onepass_sig );
 rc = parse_onepass_sig(inp, pkttype, pktlen, pkt->pkt.onepass_sig );
 break;
      case PKT_USER_ID:
 rc = parse_user_id(inp, pkttype, pktlen, pkt );
 break;
      case PKT_ATTRIBUTE:
 pkt->pkttype = pkttype = PKT_USER_ID;
 rc = parse_attribute(inp, pkttype, pktlen, pkt);
 break;
      case PKT_OLD_COMMENT:
      case PKT_COMMENT:
 rc = parse_comment(inp, pkttype, pktlen, pkt);
 break;
      case PKT_RING_TRUST:
 parse_trust(inp, pkttype, pktlen, pkt);
 rc = 0;
 break;
      case PKT_PLAINTEXT:
 rc = parse_plaintext(inp, pkttype, pktlen, pkt, new_ctb, partial );
 break;
      case PKT_COMPRESSED:
 rc = parse_compressed(inp, pkttype, pktlen, pkt, new_ctb );
 break;
      case PKT_ENCRYPTED:
      case PKT_ENCRYPTED_MDC:
 rc = parse_encrypted(inp, pkttype, pktlen, pkt, new_ctb, partial );
 break;
      case PKT_MDC:
 rc = parse_mdc(inp, pkttype, pktlen, pkt, new_ctb );
 break;
      case PKT_GPG_CONTROL:
        rc = parse_gpg_control(inp, pkttype, pktlen, pkt, partial );
        break;
    case PKT_MARKER:
        rc = parse_marker(inp,pkttype,pktlen);
 break;
      default:
 skip_packet(inp, pkttype, pktlen, partial);
 break;
    }

  leave:
    if( !rc && ((inp)->error) )
 rc = 32;
    return rc;
}

static void
dump_hex_line( int c, int *i )
{
    if( *i && !(*i%8) ) {
 if( *i && !(*i%24) )
     fprintf (listfp, "\n%4d:", *i );
 else
     putc (' ', listfp);
    }
    if( c == -1 )
 fprintf (listfp, " EOF" );
    else
 fprintf (listfp, " %02x", c );
    ++*i;
}


static int
copy_packet( IOBUF inp, IOBUF out, int pkttype,
      unsigned long pktlen, int partial )
{
    int n;
    char buf[100];

    if( partial ) {
 while( (n = iobuf_read( inp, buf, 100 )) != -1 )
     if( iobuf_write(out, buf, n ) )
  return 22;
    }
    else if( !pktlen && pkttype == PKT_COMPRESSED ) {
 g10_log_debug("copy_packet: compressed!\n");

 while( (n = iobuf_read( inp, buf, 100 )) != -1 )
     if( iobuf_write(out, buf, n ) )
  return 22;
    }
    else {
 for( ; pktlen; pktlen -= n ) {
     n = pktlen > 100 ? 100 : pktlen;
     n = iobuf_read( inp, buf, n );
     if( n == -1 )
  return 21;
     if( iobuf_write(out, buf, n ) )
  return 22;
 }
    }
    return 0;
}


static void
skip_packet( IOBUF inp, int pkttype, unsigned long pktlen, int partial )
{
  if( list_mode )
    {
      fprintf (listfp, ":unknown packet: type %2d, length %lu\n",
        pkttype, pktlen);
      if( pkttype )
 {
   int c, i=0 ;
   fputs("dump:", listfp );
   if( partial )
     {
       while( (c=( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )) != -1 )
  dump_hex_line(c, &i);
     }
   else
     {
       for( ; pktlen; pktlen-- )
                {
                  dump_hex_line ((c=( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )), &i);
                  if (c==-1)
                    break;
                }
     }
   putc ('\n', listfp);
   return;
 }
    }
  iobuf_skip_rest(inp,pktlen,partial);
}

static void *
read_rest( IOBUF inp, size_t pktlen, int partial )
{
    byte *p;
    int i;

    if( partial ) {
 g10_log_error("read_rest: can't store stream data\n");
 p = ((void*)0);
    }
    else {
 p = xmalloc( pktlen );
 for(i=0; pktlen; pktlen--, i++ )
     p[i] = ( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) );
    }
    return p;
}

static int
parse_marker( IOBUF inp, int pkttype, unsigned long pktlen )
{
  if(pktlen!=3)
    goto fail;

  if(( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )!='P')
    {
      pktlen--;
      goto fail;
    }

  if(( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )!='G')
    {
      pktlen--;
      goto fail;
    }

  if(( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )!='P')
    {
      pktlen--;
      goto fail;
    }

  if(list_mode)
    fputs(":marker packet: PGP\n", listfp );

  return 0;

 fail:
  g10_log_error("invalid marker packet\n");
  iobuf_skip_rest(inp,pktlen,0);
  return 14;
}

static int
parse_symkeyenc( IOBUF inp, int pkttype, unsigned long pktlen, PACKET *packet )
{
    PKT_symkey_enc *k;
    int rc = 0;
    int i, version, s2kmode, cipher_algo, hash_algo, seskeylen, minlen;

    if( pktlen < 4 ) {
 g10_log_error("packet(%d) too short\n", pkttype);
        rc = 14;
 goto leave;
    }
    version = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    if( version != 4 ) {
 g10_log_error("packet(%d) with unknown version %d\n", pkttype, version);
        rc = 14;
 goto leave;
    }
    if( pktlen > 200 ) {
 g10_log_error("packet(%d) too large\n", pkttype);
        rc = 14;
 goto leave;
    }
    cipher_algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    s2kmode = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    hash_algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    switch( s2kmode ) {
      case 0:
 minlen = 0;
 break;
      case 1:
 minlen = 8;
 break;
      case 3:
 minlen = 9;
 break;
      default:
 g10_log_error("unknown S2K %d\n", s2kmode );
 goto leave;
    }
    if( minlen > pktlen ) {
 g10_log_error("packet with S2K %d too short\n", s2kmode );
        rc = 14;
 goto leave;
    }
    seskeylen = pktlen - minlen;
    k = packet->pkt.symkey_enc = xmalloc_clear( sizeof *packet->pkt.symkey_enc
      + seskeylen - 1 );
    k->version = version;
    k->cipher_algo = cipher_algo;
    k->s2k.mode = s2kmode;
    k->s2k.hash_algo = hash_algo;
    if( s2kmode == 1 || s2kmode == 3 ) {
 for(i=0; i < 8 && pktlen; i++, pktlen-- )
     k->s2k.salt[i] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
    }
    if( s2kmode == 3 ) {
 k->s2k.count = ( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) ); pktlen--;
    }
    k->seskeylen = seskeylen;
    if(k->seskeylen)
      {
 for(i=0; i < seskeylen && pktlen; i++, pktlen-- )
   k->seskey[i] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);




 if(s2kmode!=1 && s2kmode!=3)
   g10_log_info(gettext ("WARNING: potentially insecure symmetrically" " encrypted session key\n"));

      }
    ((void)((!pktlen) || (__assert_fail("!pktlen", "parse-packet.c", 771, __func__),0)));

    if( list_mode ) {
 fprintf (listfp, ":symkey enc packet: version %d, cipher %d, s2k %d, hash %d",
        version, cipher_algo, s2kmode, hash_algo);
 if(seskeylen)
   fprintf (listfp, ", seskey %d bits",(seskeylen-1)*8);
 fprintf (listfp, "\n");
 if( s2kmode == 1 || s2kmode == 3 ) {
     fprintf (listfp, "\tsalt ");
     for(i=0; i < 8; i++ )
  fprintf (listfp, "%02x", k->s2k.salt[i]);
     if( s2kmode == 3 )
  fprintf (listfp, ", count %lu (%lu)",
    ((16ul + (((ulong)k->s2k.count) & 15)) << ((((ulong)k->s2k.count) >> 4) + 6)),
    (ulong)k->s2k.count );
     fprintf (listfp, "\n");
 }
    }

  leave:
    iobuf_skip_rest(inp, pktlen, 0);
    return rc;
}

static int
parse_pubkeyenc( IOBUF inp, int pkttype, unsigned long pktlen, PACKET *packet )
{
    unsigned int n;
    int rc = 0;
    int i, ndata;
    PKT_pubkey_enc *k;

    k = packet->pkt.pubkey_enc = xmalloc_clear(sizeof *packet->pkt.pubkey_enc);
    if( pktlen < 12 ) {
 g10_log_error("packet(%d) too short\n", pkttype);
        rc = 14;
 goto leave;
    }
    k->version = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    if( k->version != 2 && k->version != 3 ) {
 g10_log_error("packet(%d) with unknown version %d\n", pkttype, k->version);
        rc = 14;
 goto leave;
    }
    k->keyid[0] = read_32(inp); pktlen -= 4;
    k->keyid[1] = read_32(inp); pktlen -= 4;
    k->pubkey_algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    k->throw_keyid = 0;
    if( list_mode )
 fprintf (listfp, ":pubkey enc packet: version %d, algo %d, keyid %08lX%08lX\n",
   k->version, k->pubkey_algo, (ulong)k->keyid[0], (ulong)k->keyid[1]);

    ndata = pubkey_get_nenc(k->pubkey_algo);
    if( !ndata ) {
 if( list_mode )
     fprintf (listfp, "\tunsupported algorithm %d\n", k->pubkey_algo );
 unknown_pubkey_warning( k->pubkey_algo );
 k->data[0] = ((void*)0);
    }
    else {
 for( i=0; i < ndata; i++ ) {
     n = pktlen;
     k->data[i] = mpi_read(inp, &n, 0); pktlen -=n;
     if( list_mode ) {
  fprintf (listfp, "\tdata: ");
  mpi_print(listfp, k->data[i], mpi_print_mode );
  putc ('\n', listfp);
     }
            if (!k->data[i])
                rc = 14;
 }
    }

  leave:
    iobuf_skip_rest(inp, pktlen, 0);
    return rc;
}


static void
dump_sig_subpkt( int hashed, int type, int critical,
   const byte *buffer, size_t buflen, size_t length )
{
    const char *p=((void*)0);
    int i;




    if ( type == SIGSUBPKT_ARR && !hashed ) {
        fprintf (listfp,
                 "\tsubpkt %d len %u (additional recipient request)\n"
                 "WARNING: PGP versions > 5.0 and < 6.5.8 will automagically "
                 "encrypt to this key and thereby reveal the plaintext to "
                 "the owner of this ARR key. Detailed info follows:\n",
                 type, (unsigned)length );
    }

    buffer++;
    length--;

    fprintf (listfp, "\t%s%ssubpkt %d len %u (",
       critical ? "critical ":"",
       hashed ? "hashed ":"", type, (unsigned)length );
    if( length > buflen ) {
 fprintf (listfp, "too short: buffer is only %u)\n", (unsigned)buflen );
 return;
    }
    switch( type ) {
      case SIGSUBPKT_SIG_CREATED:
 if( length >= 4 )
     fprintf (listfp, "sig created %s",
                     strtimestamp (buf32_to_u32(buffer)) );
 break;
      case SIGSUBPKT_SIG_EXPIRE:
 if( length >= 4 )
   {
     if(buf32_to_u32(buffer))
       fprintf (listfp, "sig expires after %s",
         strtimevalue( buf32_to_u32(buffer) ) );
     else
       fprintf (listfp, "sig does not expire");
   }
 break;
      case SIGSUBPKT_EXPORTABLE:
 if( length )
     fprintf (listfp, "%sexportable", *buffer? "":"not ");
 break;
      case SIGSUBPKT_TRUST:
 if(length!=2)
   p="[invalid trust subpacket]";
 else
   fprintf (listfp, "trust signature of depth %d, value %d",
                   buffer[0],buffer[1]);
 break;
      case SIGSUBPKT_REGEXP:
 if(!length)
   p="[invalid regexp subpacket]";
 else
          {
            fprintf (listfp, "regular expression: \"");
            print_string (listfp, buffer, length, '\"');
            p = "\"";
          }
 break;
      case SIGSUBPKT_REVOCABLE:
 if( length )
     fprintf (listfp, "%srevocable", *buffer? "":"not ");
 break;
      case SIGSUBPKT_KEY_EXPIRE:
 if( length >= 4 )
   {
     if(buf32_to_u32(buffer))
       fprintf (listfp, "key expires after %s",
         strtimevalue( buf32_to_u32(buffer) ) );
     else
       fprintf (listfp, "key does not expire");
   }
 break;
      case SIGSUBPKT_PREF_SYM:
 fputs("pref-sym-algos:", listfp );
 for( i=0; i < length; i++ )
     fprintf (listfp, " %d", buffer[i] );
 break;
      case SIGSUBPKT_REV_KEY:
 fputs("revocation key: ", listfp );
 if( length < 22 )
     p = "[too short]";
 else {
     fprintf (listfp, "c=%02x a=%d f=", buffer[0], buffer[1] );
     for( i=2; i < length; i++ )
  fprintf (listfp, "%02X", buffer[i] );
 }
 break;
      case SIGSUBPKT_ISSUER:
 if( length >= 8 )
     fprintf (listfp, "issuer key ID %08lX%08lX",
                     buf32_to_ulong (buffer),
                     buf32_to_ulong (buffer+4));
 break;
      case SIGSUBPKT_NOTATION:
 {
     fputs("notation: ", listfp );
     if( length < 8 )
  p = "[too short]";
     else {
  const byte *s = buffer;
  size_t n1, n2;

  n1 = (s[4] << 8) | s[5];
  n2 = (s[6] << 8) | s[7];
  s += 8;
  if( 8+n1+n2 != length )
      p = "[error]";
  else {
      print_string( listfp, s, n1, ')' );
      putc( '=', listfp );

      if( *buffer & 0x80 )
        print_string( listfp, s+n1, n2, ')' );
      else
        p = "[not human readable]";
  }
     }
 }
 break;
      case SIGSUBPKT_PREF_HASH:
 fputs("pref-hash-algos:", listfp );
 for( i=0; i < length; i++ )
     fprintf (listfp, " %d", buffer[i] );
 break;
      case SIGSUBPKT_PREF_COMPR:
 fputs("pref-zip-algos:", listfp );
 for( i=0; i < length; i++ )
     fprintf (listfp, " %d", buffer[i] );
 break;
      case SIGSUBPKT_KS_FLAGS:
 fputs("key server preferences:",listfp);
 for(i=0;i<length;i++)
   fprintf (listfp, " %02X", buffer[i]);
 break;
      case SIGSUBPKT_PREF_KS:
 fputs("preferred key server: ", listfp );
 print_string( listfp, buffer, length, ')' );
 break;
      case SIGSUBPKT_PRIMARY_UID:
 p = "primary user ID";
 break;
      case SIGSUBPKT_POLICY:
 fputs("policy: ", listfp );
 print_string( listfp, buffer, length, ')' );
 break;
      case SIGSUBPKT_KEY_FLAGS:
        fputs ( "key flags:", listfp );
        for( i=0; i < length; i++ )
            fprintf (listfp, " %02X", buffer[i] );
 break;
      case SIGSUBPKT_SIGNERS_UID:
 p = "signer's user ID";
 break;
      case SIGSUBPKT_REVOC_REASON:
        if( length ) {
     fprintf (listfp, "revocation reason 0x%02x (", *buffer );
     print_string( listfp, buffer+1, length-1, ')' );
     p = ")";
 }
 break;
      case SIGSUBPKT_ARR:
        fputs("Big Brother's key (ignored): ", listfp );
 if( length < 22 )
     p = "[too short]";
 else {
     fprintf (listfp, "c=%02x a=%d f=", buffer[0], buffer[1] );
     for( i=2; i < length; i++ )
  fprintf (listfp, "%02X", buffer[i] );
 }
        break;
      case SIGSUBPKT_FEATURES:
        fputs ( "features:", listfp );
        for( i=0; i < length; i++ )
            fprintf (listfp, " %02x", buffer[i] );
 break;
      case SIGSUBPKT_SIGNATURE:
 fputs("signature: ",listfp);
 if(length<17)
   p="[too short]";
 else
   fprintf (listfp, "v%d, class 0x%02X, algo %d, digest algo %d",
   buffer[0],
   buffer[0]==3?buffer[2]:buffer[1],
   buffer[0]==3?buffer[15]:buffer[2],
   buffer[0]==3?buffer[16]:buffer[3]);
 break;
      default:
 if(type>=100 && type<=110)
   p="experimental / private subpacket";
 else
   p = "?";
 break;
    }

    fprintf (listfp, "%s)\n", p? p: "");
}






int
parse_one_sig_subpkt( const byte *buffer, size_t n, int type )
{
  switch( type )
    {
    case SIGSUBPKT_REV_KEY:
      if(n < 22)
 break;
      return 0;
    case SIGSUBPKT_SIG_CREATED:
    case SIGSUBPKT_SIG_EXPIRE:
    case SIGSUBPKT_KEY_EXPIRE:
      if( n < 4 )
 break;
      return 0;
    case SIGSUBPKT_KEY_FLAGS:
    case SIGSUBPKT_KS_FLAGS:
    case SIGSUBPKT_PREF_SYM:
    case SIGSUBPKT_PREF_HASH:
    case SIGSUBPKT_PREF_COMPR:
    case SIGSUBPKT_POLICY:
    case SIGSUBPKT_PREF_KS:
    case SIGSUBPKT_FEATURES:
    case SIGSUBPKT_REGEXP:
      return 0;
    case SIGSUBPKT_SIGNATURE:
    case SIGSUBPKT_EXPORTABLE:
    case SIGSUBPKT_REVOCABLE:
    case SIGSUBPKT_REVOC_REASON:
      if( !n )
 break;
      return 0;
    case SIGSUBPKT_ISSUER:
      if( n < 8 )
 break;
      return 0;
    case SIGSUBPKT_NOTATION:



      if(n<8 || 8+((buffer[4]<<8)|buffer[5])+((buffer[6]<<8)|buffer[7]) != n)
 break;
      return 0;
    case SIGSUBPKT_PRIMARY_UID:
      if ( n != 1 )
 break;
      return 0;
    case SIGSUBPKT_TRUST:
      if ( n != 2 )
 break;
      return 0;
    default: return 0;
    }
  return -2;
}


static int
can_handle_critical_notation(const byte *name,size_t len)
{
  if(len==32 && memcmp(name,"preferred-email-encoding@pgp.com",32)==0)
    return 1;
  if(len==21 && memcmp(name,"pka-address@gnupg.org",21)==0)
    return 1;

  return 0;
}

static int
can_handle_critical( const byte *buffer, size_t n, int type )
{
  switch( type )
    {
    case SIGSUBPKT_NOTATION:
      if (n >= 8)
 {
   size_t notation_len = ((buffer[4] << 8) | buffer[5]);
   if (n - 8 >= notation_len)
     return can_handle_critical_notation (buffer + 8, notation_len);
 }
      return 0;
    case SIGSUBPKT_SIGNATURE:
    case SIGSUBPKT_SIG_CREATED:
    case SIGSUBPKT_SIG_EXPIRE:
    case SIGSUBPKT_KEY_EXPIRE:
    case SIGSUBPKT_EXPORTABLE:
    case SIGSUBPKT_REVOCABLE:
    case SIGSUBPKT_REV_KEY:
    case SIGSUBPKT_ISSUER:
    case SIGSUBPKT_PREF_SYM:
    case SIGSUBPKT_PREF_HASH:
    case SIGSUBPKT_PREF_COMPR:
    case SIGSUBPKT_KEY_FLAGS:
    case SIGSUBPKT_PRIMARY_UID:
    case SIGSUBPKT_FEATURES:
    case SIGSUBPKT_TRUST:
    case SIGSUBPKT_REGEXP:

    case SIGSUBPKT_POLICY:
    case SIGSUBPKT_PREF_KS:
      return 1;

    default:
      return 0;
    }
}


const byte *
enum_sig_subpkt( const subpktarea_t *pktbuf, sigsubpkttype_t reqtype,
   size_t *ret_n, int *start, int *critical )
{
    const byte *buffer;
    int buflen;
    int type;
    int critical_dummy;
    int offset;
    size_t n;
    int seq = 0;
    int reqseq = start? *start: 0;

    if(!critical)
      critical=&critical_dummy;

    if( !pktbuf || reqseq == -1 ) {
 static char dummy[] = "x";


 return reqtype == SIGSUBPKT_TEST_CRITICAL ? dummy : ((void*)0);
    }
    buffer = pktbuf->data;
    buflen = pktbuf->len;
    while( buflen ) {
 n = *buffer++; buflen--;
 if( n == 255 ) {
     if( buflen < 4 )
  goto too_short;
            n = buf32_to_size_t (buffer);
     buffer += 4;
     buflen -= 4;
 }
 else if( n >= 192 ) {
     if( buflen < 2 )
  goto too_short;
     n = (( n - 192 ) << 8) + *buffer + 192;
     buffer++;
     buflen--;
 }
 if( buflen < n )
     goto too_short;
 type = *buffer;
 if( type & 0x80 ) {
     type &= 0x7f;
     *critical = 1;
 }
 else
     *critical = 0;
 if( !(++seq > reqseq) )
     ;
 else if( reqtype == SIGSUBPKT_TEST_CRITICAL ) {
     if( *critical ) {
  if( n-1 > buflen+1 )
      goto too_short;
  if( !can_handle_critical(buffer+1, n-1, type ) )
    {
      if(opt.verbose)
        g10_log_info(gettext ("subpacket of type %d has " "critical bit set\n"),type);

      if( start )
        *start = seq;
      return ((void*)0);
    }
     }
 }
 else if( reqtype < 0 )
     dump_sig_subpkt( reqtype == SIGSUBPKT_LIST_HASHED,
        type, *critical, buffer, buflen, n );
 else if( type == reqtype ) {
     buffer++;
     n--;
     if( n > buflen )
  goto too_short;
     if( ret_n )
  *ret_n = n;
     offset = parse_one_sig_subpkt(buffer, n, type );
     switch( offset ) {
       case -2:
  g10_log_error("subpacket of type %d too short\n", type);
  return ((void*)0);
       case -1:
  return ((void*)0);
       default:
  break;
     }
     if( start )
  *start = seq;
     return buffer+offset;
 }
 buffer += n; buflen -=n;
    }
    if( reqtype == SIGSUBPKT_TEST_CRITICAL )
 return buffer;

    if( start )
 *start = -1;
    return ((void*)0);

  too_short:
    if(opt.verbose)
      g10_log_info("buffer shorter than subpacket\n");
    if( start )
 *start = -1;
    return ((void*)0);
}


const byte *
parse_sig_subpkt (const subpktarea_t *buffer, sigsubpkttype_t reqtype,
                  size_t *ret_n)
{
    return enum_sig_subpkt( buffer, reqtype, ret_n, ((void*)0), ((void*)0) );
}

const byte *
parse_sig_subpkt2 (PKT_signature *sig, sigsubpkttype_t reqtype,
                   size_t *ret_n )
{
    const byte *p;

    p = parse_sig_subpkt (sig->hashed, reqtype, ret_n );
    if( !p )
 p = parse_sig_subpkt (sig->unhashed, reqtype, ret_n );
    return p;
}


void parse_revkeys(PKT_signature *sig)
{
  struct revocation_key *revkey;
  int seq=0;
  size_t len;

  if(sig->sig_class!=0x1F)
    return;

  while((revkey=
  (struct revocation_key *)enum_sig_subpkt(sig->hashed,
        SIGSUBPKT_REV_KEY,
        &len,&seq,((void*)0))))
    {
      if(len==sizeof(struct revocation_key) &&
  (revkey->class&0x80))
 {
   sig->revkey=xrealloc(sig->revkey,
     sizeof(struct revocation_key *)*(sig->numrevkeys+1));
   sig->revkey[sig->numrevkeys]=revkey;
   sig->numrevkeys++;
 }
    }
}

int
parse_signature( IOBUF inp, int pkttype, unsigned long pktlen,
       PKT_signature *sig )
{
    int md5_len=0;
    unsigned n;
    int is_v4=0;
    int rc=0;
    int i, ndata;

    if( pktlen < 16 ) {
 g10_log_error("packet(%d) too short\n", pkttype);
 goto leave;
    }
    sig->version = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    if( sig->version == 4 )
 is_v4=1;
    else if( sig->version != 2 && sig->version != 3 ) {
 g10_log_error("packet(%d) with unknown version %d\n", pkttype, sig->version);
        rc = 14;
 goto leave;
    }

    if( !is_v4 ) {
 md5_len = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    }
    sig->sig_class = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    if( !is_v4 ) {
 sig->timestamp = read_32(inp); pktlen -= 4;
 sig->keyid[0] = read_32(inp); pktlen -= 4;
 sig->keyid[1] = read_32(inp); pktlen -= 4;
    }
    sig->pubkey_algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    sig->digest_algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    sig->flags.exportable=1;
    sig->flags.revocable=1;
    if( is_v4 ) {
 n = read_16(inp); pktlen -= 2;
 if( n > 10000 ) {
     g10_log_error("signature packet: hashed data too long\n");
     rc = 14;
     goto leave;
 }
 if( n ) {
     sig->hashed = xmalloc (sizeof (*sig->hashed) + n - 1 );
            sig->hashed->size = n;
     sig->hashed->len = n;
     if( iobuf_read (inp, sig->hashed->data, n ) != n ) {
  g10_log_error ("premature eof while reading "
                           "hashed signature data\n");
  rc = -1;
  goto leave;
     }
     pktlen -= n;
 }
 n = read_16(inp); pktlen -= 2;
 if( n > 10000 ) {
     g10_log_error("signature packet: unhashed data too long\n");
     rc = 14;
     goto leave;
 }
 if( n ) {
     sig->unhashed = xmalloc (sizeof(*sig->unhashed) + n - 1 );
            sig->unhashed->size = n;
     sig->unhashed->len = n;
     if( iobuf_read(inp, sig->unhashed->data, n ) != n ) {
  g10_log_error("premature eof while reading "
                          "unhashed signature data\n");
  rc = -1;
  goto leave;
     }
     pktlen -= n;
 }
    }

    if( pktlen < 5 ) {
 g10_log_error("packet(%d) too short\n", pkttype);
 rc = 14;
 goto leave;
    }

    sig->digest_start[0] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    sig->digest_start[1] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;

    if( is_v4 && sig->pubkey_algo )
      {
 const byte *p;
 size_t len;



 if( !parse_sig_subpkt (sig->hashed, SIGSUBPKT_TEST_CRITICAL, ((void*)0))
     || !parse_sig_subpkt (sig->unhashed, SIGSUBPKT_TEST_CRITICAL,
      ((void*)0)) )
   sig->flags.unknown_critical = 1;

 p = parse_sig_subpkt (sig->hashed, SIGSUBPKT_SIG_CREATED, ((void*)0) );
 if(p)
   sig->timestamp = buf32_to_u32 (p);
 else if(!(sig->pubkey_algo>=100 && sig->pubkey_algo<=110)
  && opt.verbose)
   g10_log_info ("signature packet without timestamp\n");

 p = parse_sig_subpkt2( sig, SIGSUBPKT_ISSUER, ((void*)0) );
 if(p)
   {
     sig->keyid[0] = buf32_to_u32 (p);
     sig->keyid[1] = buf32_to_u32 (p+4);
   }
 else if(!(sig->pubkey_algo>=100 && sig->pubkey_algo<=110)
  && opt.verbose)
   g10_log_info ("signature packet without keyid\n");

 p=parse_sig_subpkt(sig->hashed,SIGSUBPKT_SIG_EXPIRE,((void*)0));
 if(p && buf32_to_u32 (p))
   sig->expiredate = sig->timestamp + buf32_to_u32 (p);
 if(sig->expiredate && sig->expiredate<=make_timestamp())
   sig->flags.expired=1;

 p=parse_sig_subpkt(sig->hashed,SIGSUBPKT_POLICY,((void*)0));
 if(p)
   sig->flags.policy_url=1;

 p=parse_sig_subpkt(sig->hashed,SIGSUBPKT_PREF_KS,((void*)0));
 if(p)
   sig->flags.pref_ks=1;

 p=parse_sig_subpkt(sig->hashed,SIGSUBPKT_NOTATION,((void*)0));
 if(p)
   sig->flags.notation=1;

 p=parse_sig_subpkt(sig->hashed,SIGSUBPKT_REVOCABLE,((void*)0));
 if(p && *p==0)
   sig->flags.revocable=0;

 p=parse_sig_subpkt(sig->hashed,SIGSUBPKT_TRUST,&len);
 if(p && len==2)
   {
     sig->trust_depth=p[0];
     sig->trust_value=p[1];



     sig->trust_regexp=
       parse_sig_subpkt(sig->hashed,SIGSUBPKT_REGEXP,&len);



     if(len==0)
       sig->trust_regexp=((void*)0);
   }






 p=parse_sig_subpkt2(sig,SIGSUBPKT_EXPORTABLE,((void*)0));
 if(p && *p==0)
   sig->flags.exportable=0;


 if(sig->sig_class==0x1F)
   parse_revkeys(sig);
      }

    if( list_mode ) {
 fprintf (listfp, ":signature packet: algo %d, keyid %08lX%08lX\n"
        "\tversion %d, created %lu, md5len %d, sigclass 0x%02x\n"
        "\tdigest algo %d, begin of digest %02x %02x\n",
  sig->pubkey_algo,
  (ulong)sig->keyid[0], (ulong)sig->keyid[1],
  sig->version, (ulong)sig->timestamp, md5_len, sig->sig_class,
  sig->digest_algo,
  sig->digest_start[0], sig->digest_start[1] );
 if( is_v4 ) {
     parse_sig_subpkt (sig->hashed, SIGSUBPKT_LIST_HASHED, ((void*)0) );
     parse_sig_subpkt (sig->unhashed, SIGSUBPKT_LIST_UNHASHED, ((void*)0));
 }
    }

    ndata = pubkey_get_nsig(sig->pubkey_algo);
    if( !ndata ) {
 if( list_mode )
     fprintf (listfp, "\tunknown algorithm %d\n", sig->pubkey_algo );
 unknown_pubkey_warning( sig->pubkey_algo );


        if (pktlen > (5 * 16384/8))
          {


     g10_log_error ("signature packet: too much data\n");
     rc = 14;
          }
        else
          {
            sig->data[0]= mpi_set_opaque (((void*)0), read_rest(inp, pktlen, 0),
                                          pktlen );
            pktlen = 0;
          }
    }
    else {
 for( i=0; i < ndata; i++ ) {
     n = pktlen;
     sig->data[i] = mpi_read(inp, &n, 0 );
     pktlen -=n;
     if( list_mode ) {
  fprintf (listfp, "\tdata: ");
  mpi_print(listfp, sig->data[i], mpi_print_mode );
  putc ('\n', listfp);
     }
            if (!sig->data[i])
                rc = 14;
 }
    }

  leave:
    iobuf_skip_rest(inp, pktlen, 0);
    return rc;
}


static int
parse_onepass_sig( IOBUF inp, int pkttype, unsigned long pktlen,
          PKT_onepass_sig *ops )
{
    int version;
    int rc = 0;

    if( pktlen < 13 ) {
 g10_log_error("packet(%d) too short\n", pkttype);
        rc = 14;
 goto leave;
    }
    version = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    if( version != 3 ) {
 g10_log_error("onepass_sig with unknown version %d\n", version);
        rc = 14;
 goto leave;
    }
    ops->sig_class = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    ops->digest_algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    ops->pubkey_algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    ops->keyid[0] = read_32(inp); pktlen -= 4;
    ops->keyid[1] = read_32(inp); pktlen -= 4;
    ops->last = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    if( list_mode )
 fprintf (listfp, ":onepass_sig packet: keyid %08lX%08lX\n"
       "\tversion %d, sigclass 0x%02x, digest %d, pubkey %d, last=%d\n",
  (ulong)ops->keyid[0], (ulong)ops->keyid[1],
  version, ops->sig_class,
  ops->digest_algo, ops->pubkey_algo, ops->last );


  leave:
    iobuf_skip_rest(inp, pktlen, 0);
    return rc;
}


static MPI
read_protected_v3_mpi (IOBUF inp, unsigned long *length)
{
  int c;
  unsigned int nbits, nbytes;
  unsigned char *buf, *p;
  MPI val;

  if (*length < 2)
    {
      g10_log_error ("mpi too small\n");
      return ((void*)0);
    }

  if ((c=( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )) == -1)
    return ((void*)0);
  --*length;
  nbits = c << 8;
  if ((c=( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )) == -1)
    return ((void*)0);
  --*length;
  nbits |= c;

  if (nbits > 16384)
    {
      g10_log_error ("mpi too large (%u bits)\n", nbits);
      return ((void*)0);
    }
  nbytes = (nbits+7) / 8;
  buf = p = xmalloc (2 + nbytes);
  *p++ = nbits >> 8;
  *p++ = nbits;
  for (; nbytes && *length; nbytes--, --*length)
    *p++ = ( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) );
  if (nbytes)
    {
      g10_log_error ("packet shorter tham mpi\n");
      xfree (buf);
      return ((void*)0);
    }


  val = mpi_set_opaque (((void*)0), buf, p-buf);
  return val;
}


static int
parse_key( IOBUF inp, int pkttype, unsigned long pktlen,
         byte *hdr, int hdrlen, PACKET *pkt )
{
    int i, version, algorithm;
    unsigned n;
    unsigned long timestamp, expiredate, max_expiredate;
    int npkey, nskey;
    int is_v4=0;
    int rc=0;
    u32 keyid[2];

    version = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    if( pkttype == PKT_PUBLIC_SUBKEY && version == '#' ) {


 if( list_mode ) {
     fprintf (listfp, ":rfc1991 comment packet: \"" );
     for( ; pktlen; pktlen-- ) {
  int c;
  c = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
  if( c >= ' ' && c <= 'z' )
      putc (c, listfp);
  else
      fprintf (listfp, "\\x%02x", c );
     }
     fprintf (listfp, "\"\n");
 }
 iobuf_skip_rest(inp, pktlen, 0);
 return 0;
    }
    else if( version == 4 )
 is_v4=1;
    else if( version != 2 && version != 3 ) {
 g10_log_error("packet(%d) with unknown version %d\n", pkttype, version);
        rc = 14;
 goto leave;
    }

    if( pktlen < 11 ) {
 g10_log_error("packet(%d) too short\n", pkttype);
        rc = 14;
 goto leave;
    }
    else if (pktlen > (256 * 1024)) {
        g10_log_error ("packet(%d) too large\n", pkttype);
        if (list_mode)
            fputs (":key packet: [too large]\n", listfp);
        rc = 14;
        goto leave;
    }

    timestamp = read_32(inp); pktlen -= 4;
    if( is_v4 ) {
 expiredate = 0;
 max_expiredate = 0;
    }
    else {
 unsigned short ndays;
 ndays = read_16(inp); pktlen -= 2;
 if( ndays )
     expiredate = timestamp + ndays * 86400L;
 else
     expiredate = 0;

 max_expiredate=expiredate;
    }
    algorithm = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    if( list_mode )
 fprintf (listfp, ":%s key packet:\n"
        "\tversion %d, algo %d, created %lu, expires %lu\n",
  pkttype == PKT_PUBLIC_KEY? "public" :
  pkttype == PKT_SECRET_KEY? "secret" :
  pkttype == PKT_PUBLIC_SUBKEY? "public sub" :
  pkttype == PKT_SECRET_SUBKEY? "secret sub" : "??",
  version, algorithm, timestamp, expiredate );

    if( pkttype == PKT_SECRET_KEY || pkttype == PKT_SECRET_SUBKEY ) {
 PKT_secret_key *sk = pkt->pkt.secret_key;

 sk->timestamp = timestamp;
 sk->expiredate = expiredate;
 sk->max_expiredate = max_expiredate;
 sk->hdrbytes = hdrlen;
 sk->version = version;
 sk->is_primary = pkttype == PKT_SECRET_KEY;
 sk->pubkey_algo = algorithm;
 sk->req_usage = 0;
 sk->pubkey_usage = 0;
    }
    else {
 PKT_public_key *pk = pkt->pkt.public_key;

 pk->timestamp = timestamp;
 pk->expiredate = expiredate;
 pk->max_expiredate = max_expiredate;
 pk->hdrbytes = hdrlen;
 pk->version = version;
 pk->is_primary = pkttype == PKT_PUBLIC_KEY;
 pk->pubkey_algo = algorithm;
 pk->req_usage = 0;
 pk->pubkey_usage = 0;
        pk->is_revoked = 0;
 pk->is_disabled = 0;
 pk->keyid[0] = 0;
 pk->keyid[1] = 0;
    }
    nskey = pubkey_get_nskey( algorithm );
    npkey = pubkey_get_npkey( algorithm );
    if( !npkey ) {
 if( list_mode )
     fprintf (listfp, "\tunknown algorithm %d\n", algorithm );
 unknown_pubkey_warning( algorithm );
    }

    if( pkttype == PKT_SECRET_KEY || pkttype == PKT_SECRET_SUBKEY ) {
 PKT_secret_key *sk = pkt->pkt.secret_key;
 byte temp[16];
        size_t snlen = 0;

        if (pktlen < 1)
          {
            rc = 14;
            goto leave;
          }

 if( !npkey ) {
     sk->skey[0] = mpi_set_opaque( ((void*)0),
       read_rest(inp, pktlen, 0), pktlen );
     pktlen = 0;
     goto leave;
 }

 for(i=0; i < npkey; i++ ) {
     n = pktlen;
            sk->skey[i] = mpi_read(inp, &n, 0 );
            pktlen -=n;
     if( list_mode ) {
  fprintf (listfp, "\tskey[%d]: ", i);
  mpi_print(listfp, sk->skey[i], mpi_print_mode );
  putc ('\n', listfp);
     }
            if (!sk->skey[i])
                rc = 14;
 }
        if (rc)
            goto leave;
        if (list_mode && npkey)
            keyid_from_sk (sk, keyid);

 sk->protect.algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
        pktlen--;
        sk->protect.sha1chk = 0;
 if( sk->protect.algo ) {
     sk->is_protected = 1;
     sk->protect.s2k.count = 0;
     if( sk->protect.algo == 254 || sk->protect.algo == 255 ) {
  if( pktlen < 3 ) {
      rc = 14;
      goto leave;
  }
                sk->protect.sha1chk = (sk->protect.algo == 254);
  sk->protect.algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
                pktlen--;



  sk->protect.s2k.mode = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
                pktlen--;
  sk->protect.s2k.hash_algo = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
                pktlen--;

  if( is_v4 && sk->protect.s2k.mode == 101 ) {
      for(i=0; i < 4 && pktlen; i++, pktlen-- )
   temp[i] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
      if( i < 4 || memcmp( temp, "GNU", 3 ) ) {
   if( list_mode )
       fprintf (listfp, "\tunknown S2K %d\n",
      sk->protect.s2k.mode );
   rc = 14;
   goto leave;
      }





      sk->protect.s2k.mode = 1000 + temp[3];
  }
  switch( sk->protect.s2k.mode ) {
    case 1:
    case 3:
      for(i=0; i < 8 && pktlen; i++, pktlen-- )
   temp[i] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
      memcpy(sk->protect.s2k.salt, temp, 8 );
      break;
  }
  switch( sk->protect.s2k.mode ) {
    case 0: if( list_mode ) fprintf (listfp, "\tsimple S2K" );
      break;
    case 1: if( list_mode ) fprintf (listfp, "\tsalted S2K" );
      break;
    case 3: if( list_mode ) fprintf (listfp, "\titer+salt S2K" );
      break;
    case 1001: if( list_mode ) fprintf (listfp,
                                                      "\tgnu-dummy S2K" );
      break;
    case 1002: if (list_mode) fprintf (listfp,
                                                  "\tgnu-divert-to-card S2K");
      break;
    default:
      if( list_mode )
   fprintf (listfp, "\tunknown %sS2K %d\n",
     sk->protect.s2k.mode < 1000? "":"GNU ",
         sk->protect.s2k.mode );
      rc = 14;
      goto leave;
  }

  if( list_mode ) {
      fprintf (listfp, ", algo: %d,%s hash: %d",
         sk->protect.algo,
                                     sk->protect.sha1chk?" SHA1 protection,"
                                                        :" simple checksum,",
         sk->protect.s2k.hash_algo );
      if( sk->protect.s2k.mode == 1
   || sk->protect.s2k.mode == 3 ) {
   fprintf (listfp, ", salt: ");
   for(i=0; i < 8; i++ )
       fprintf (listfp, "%02x", sk->protect.s2k.salt[i]);
      }
      putc ('\n', listfp);
  }

  if( sk->protect.s2k.mode == 3 ) {
      if( pktlen < 1 ) {
   rc = 14;
   goto leave;
      }
      sk->protect.s2k.count = ( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) );
      pktlen--;
      if( list_mode )
   fprintf (listfp, "\tprotect count: %lu (%lu)\n",
                                (ulong)((16ul + (((ulong)sk->protect.s2k.count) & 15)) << ((((ulong)sk->protect.s2k.count) >> 4) + 6)),

                                 (ulong)sk->protect.s2k.count);
  }
  else if( sk->protect.s2k.mode == 1002 ) {

                    if (pktlen < 1) {
                      rc = 14;
   goto leave;
      }
      snlen = ( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) );
      pktlen--;
                    if (pktlen < snlen || snlen == (size_t)(-1)) {
   rc = 14;
   goto leave;
                    }
  }
     }



     else {
  sk->protect.s2k.mode = 0;
  sk->protect.s2k.hash_algo = 1;
  if( list_mode )
      fprintf (listfp, "\tprotect algo: %d  (hash algo: %d)\n",
    sk->protect.algo, sk->protect.s2k.hash_algo );
     }
# 1909 "parse-packet.c"
     switch( sk->protect.algo ) {
       case 7: case 8: case 9:
       case 10:
       case 11: case 12: case 13:
  sk->protect.ivlen = 16;
  break;
       default:
  sk->protect.ivlen = 8;
     }
     if( sk->protect.s2k.mode == 1001 )
  sk->protect.ivlen = 0;
     else if( sk->protect.s2k.mode == 1002 )
  sk->protect.ivlen = snlen < 16? snlen : 16;

     if( pktlen < sk->protect.ivlen ) {
  rc = 14;
  goto leave;
     }
     for(i=0; i < sk->protect.ivlen && pktlen; i++, pktlen-- )
  temp[i] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
     if( list_mode ) {
  fprintf (listfp,
                         sk->protect.s2k.mode == 1002? "\tserial-number: "
                                                     : "\tprotect IV: ");
  for(i=0; i < sk->protect.ivlen; i++ )
      fprintf (listfp, " %02x", temp[i] );
  putc ('\n', listfp);
     }
     memcpy(sk->protect.iv, temp, sk->protect.ivlen );
 }
 else
     sk->is_protected = 0;




 if( sk->protect.s2k.mode == 1001
            || sk->protect.s2k.mode == 1002 ) {

     sk->skey[npkey] = mpi_set_opaque(((void*)0), xstrdup("dummydata"), 10);
     pktlen = 0;
 }
 else if( is_v4 && sk->is_protected ) {



     if (pktlen < 2)
       {
                rc = 14;
                goto leave;
       }
     sk->skey[npkey] = mpi_set_opaque(((void*)0),
          read_rest(inp, pktlen, 0),pktlen);
     pktlen = 0;
     if( list_mode ) {
  fprintf (listfp, "\tencrypted stuff follows\n");
     }
 }
 else {
     for(i=npkey; i < nskey; i++ ) {
                if ( sk->is_protected ) {
                    sk->skey[i] = read_protected_v3_mpi (inp, &pktlen);
                    if( list_mode )
                        fprintf (listfp, "\tskey[%d]: [encrypted]\n", i);
                }
                else {
                    if (pktlen < 2)
                      {
                        rc = 14;
                        goto leave;
               }
                    n = pktlen;
                    sk->skey[i] = mpi_read(inp, &n, 0 );
                    pktlen -=n;
                    if( list_mode ) {
                        fprintf (listfp, "\tskey[%d]: ", i);
                        mpi_print(listfp, sk->skey[i], mpi_print_mode );
                        putc ('\n', listfp);
                    }
                }

                if (!sk->skey[i])
                    rc = 14;
     }
            if (rc)
                goto leave;

            if (pktlen < 2)
              {
                rc = 14;
                goto leave;
              }
     sk->csum = read_16(inp);
            pktlen -= 2;
     if( list_mode ) {
  fprintf (listfp, "\tchecksum: %04hx\n", sk->csum);
     }
 }
    }
    else {
 PKT_public_key *pk = pkt->pkt.public_key;

        if (pktlen < 1)
          {
            rc = 14;
            goto leave;
          }

 if( !npkey ) {
     pk->pkey[0] = mpi_set_opaque( ((void*)0),
       read_rest(inp, pktlen, 0), pktlen );
     pktlen = 0;
     goto leave;
 }

 for(i=0; i < npkey; i++ ) {
     n = pktlen;
            pk->pkey[i] = mpi_read(inp, &n, 0 );
            pktlen -=n;
     if( list_mode ) {
  fprintf (listfp, "\tpkey[%d]: ", i);
  mpi_print(listfp, pk->pkey[i], mpi_print_mode );
  putc ('\n', listfp);
     }
            if (!pk->pkey[i])
                rc = 14;
 }
        if (rc)
            goto leave;

        if (list_mode)
            keyid_from_pk (pk, keyid);
    }

  if (list_mode && npkey)
      fprintf (listfp, "\tkeyid: %08lX%08lX\n",
              (ulong) keyid[0], (ulong) keyid[1]);

  leave:
    iobuf_skip_rest(inp, pktlen, 0);
    return rc;
}




int
parse_attribute_subpkts(PKT_user_id *uid)
{
  size_t n;
  int count=0;
  struct user_attribute *attribs=((void*)0);
  const byte *buffer=uid->attrib_data;
  int buflen=uid->attrib_len;
  byte type;

  xfree(uid->attribs);

  while(buflen)
    {
      n = *buffer++; buflen--;
      if( n == 255 ) {
 if( buflen < 4 )
   goto too_short;
        n = buf32_to_size_t (buffer);
        buffer += 4;
 buflen -= 4;
      }
      else if( n >= 192 ) {
 if( buflen < 2 )
   goto too_short;
 n = (( n - 192 ) << 8) + *buffer + 192;
 buffer++;
 buflen--;
      }
      if( buflen < n )
 goto too_short;

      if (!n)
        {

          if (opt.verbose)
            g10_log_info ("attribute subpacket too short\n");
          break;
        }

      attribs=xrealloc(attribs,(count+1)*sizeof(struct user_attribute));
      memset(&attribs[count],0,sizeof(struct user_attribute));

      type=*buffer;
      buffer++;
      buflen--;
      n--;

      attribs[count].type=type;
      attribs[count].data=buffer;
      attribs[count].len=n;
      buffer+=n;
      buflen-=n;
      count++;
    }

  uid->attribs=attribs;
  uid->numattribs=count;
  return count;

 too_short:
  if(opt.verbose)
    g10_log_info("buffer shorter than attribute subpacket\n");
  uid->attribs=attribs;
  uid->numattribs=count;
  return count;
}


static int
parse_user_id( IOBUF inp, int pkttype, unsigned long pktlen, PACKET *packet )
{
    byte *p;
# 2136 "parse-packet.c"
    if (pktlen > ( 2 * 1024))
      {
 g10_log_error("packet(%d) too large\n", pkttype);
 iobuf_skip_rest(inp, pktlen, 0);
 return 14;
      }

    packet->pkt.user_id = xmalloc_clear(sizeof *packet->pkt.user_id + pktlen);
    packet->pkt.user_id->len = pktlen;
    packet->pkt.user_id->ref=1;

    p = packet->pkt.user_id->name;
    for( ; pktlen; pktlen--, p++ )
 *p = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
    *p = 0;

    if( list_mode ) {
 int n = packet->pkt.user_id->len;
 fprintf (listfp, ":user ID packet: \"");

 for(p=packet->pkt.user_id->name; n; p++, n-- ) {
     if( *p >= ' ' && *p <= 'z' )
  putc (*p, listfp);
     else
  fprintf (listfp, "\\x%02x", *p );
 }
 fprintf (listfp, "\"\n");
    }
    return 0;
}


void
make_attribute_uidname(PKT_user_id *uid, size_t max_namelen)
{
  ((void)((max_namelen > 70) || (__assert_fail("max_namelen > 70", "parse-packet.c", 2171, __func__),0)));
  if(uid->numattribs<=0)
    sprintf(uid->name,"[bad attribute packet of size %lu]",uid->attrib_len);
  else if(uid->numattribs>1)
    sprintf(uid->name,"[%d attributes of size %lu]",
     uid->numattribs,uid->attrib_len);
  else
    {


      if(uid->attribs->type==1)
 {
   u32 len;
   byte type;

   if(parse_image_header(uid->attribs,&type,&len))
     sprintf(uid->name,"[%.20s image of size %lu]",
      image_type_to_string(type,1),(ulong)len);
   else
     sprintf(uid->name,"[invalid image]");
 }
      else
 sprintf(uid->name,"[unknown attribute of size %lu]",
  (ulong)uid->attribs->len);
    }

  uid->len = strlen(uid->name);
}

static int
parse_attribute( IOBUF inp, int pkttype, unsigned long pktlen, PACKET *packet )
{
    byte *p;

    (void)pkttype;




    if (pktlen > ( 16 * 1024*1024)) {
        g10_log_error ("packet(%d) too large\n", pkttype);
        if (list_mode)
          fprintf (listfp, ":attribute packet: [too large]\n");
        iobuf_skip_rest (inp, pktlen, 0);
        return 14;
      }


    packet->pkt.user_id = xmalloc_clear(sizeof *packet->pkt.user_id
     + 71);
    packet->pkt.user_id->ref=1;
    packet->pkt.user_id->attrib_data = xmalloc(pktlen);
    packet->pkt.user_id->attrib_len = pktlen;

    p = packet->pkt.user_id->attrib_data;
    for( ; pktlen; pktlen--, p++ )
 *p = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);




    parse_attribute_subpkts(packet->pkt.user_id);

    make_attribute_uidname(packet->pkt.user_id, 71);

    if( list_mode ) {
 fprintf (listfp, ":attribute packet: %s\n", packet->pkt.user_id->name );
    }
    return 0;
}


static int
parse_comment( IOBUF inp, int pkttype, unsigned long pktlen, PACKET *packet )
{
    byte *p;





    if (pktlen > ( 64 * 1024))
      {
 g10_log_error ("packet(%d) too large\n", pkttype);
 iobuf_skip_rest (inp, pktlen, 0);
 return 14;
      }
    packet->pkt.comment = xmalloc(sizeof *packet->pkt.comment + pktlen - 1);
    packet->pkt.comment->len = pktlen;
    p = packet->pkt.comment->data;
    for( ; pktlen; pktlen--, p++ )
 *p = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);

    if( list_mode ) {
 int n = packet->pkt.comment->len;
 fprintf (listfp, ":%scomment packet: \"", pkttype == PKT_OLD_COMMENT?
      "OpenPGP draft " : "GnuPG " );
 for(p=packet->pkt.comment->data; n; p++, n-- ) {
     if( *p >= ' ' && *p <= 'z' )
  putc (*p, listfp);
     else
  fprintf (listfp, "\\x%02x", *p );
 }
 fprintf (listfp, "\"\n");
    }
    return 0;
}


static void
parse_trust( IOBUF inp, int pkttype, unsigned long pktlen, PACKET *pkt )
{
  int c;

  (void)pkttype;

  pkt->pkt.ring_trust = xmalloc( sizeof *pkt->pkt.ring_trust );
  if (pktlen)
    {
      c = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
      pktlen--;
      pkt->pkt.ring_trust->trustval = c;
      pkt->pkt.ring_trust->sigcache = 0;
      if (!c && pktlen==1)
        {
          c = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
          pktlen--;

          if ( !(c & 0x80) )
            pkt->pkt.ring_trust->sigcache = c;
        }
      if( list_mode )
 fprintf (listfp, ":trust packet: flag=%02x sigcache=%02x\n",
               pkt->pkt.ring_trust->trustval,
               pkt->pkt.ring_trust->sigcache);
    }
  else
    {
      pkt->pkt.ring_trust->trustval = 0;
      pkt->pkt.ring_trust->sigcache = 0;
      if (list_mode)
        fprintf (listfp, ":trust packet: empty\n");
    }
  iobuf_skip_rest (inp, pktlen, 0);
}


static int
parse_plaintext( IOBUF inp, int pkttype, unsigned long pktlen,
   PACKET *pkt, int new_ctb, int partial )
{
    int rc = 0;
    int mode, namelen;
    PKT_plaintext *pt;
    byte *p;
    int c, i;

    if( !partial && pktlen < 6 ) {
 g10_log_error("packet(%d) too short (%lu)\n", pkttype, (ulong)pktlen);
        rc = 14;
 goto leave;
    }
    mode = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); if( pktlen ) pktlen--;
    namelen = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); if( pktlen ) pktlen--;

    pt = pkt->pkt.plaintext = xmalloc(sizeof *pkt->pkt.plaintext + namelen -1);
    pt->new_ctb = new_ctb;
    pt->mode = mode;
    pt->namelen = namelen;
    pt->is_partial = partial;
    if( pktlen ) {
 for( i=0; pktlen > 4 && i < namelen; pktlen--, i++ )
     pt->name[i] = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
    }
    else {
 for( i=0; i < namelen; i++ )
     if( (c=( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )) == -1 )
  break;
     else
  pt->name[i] = c;
    }
    pt->timestamp = read_32(inp); if( pktlen) pktlen -= 4;
    pt->len = pktlen;
    pt->buf = inp;
    pktlen = 0;

    if( list_mode ) {
 fprintf (listfp, ":literal data packet:\n"
        "\tmode %c (%X), created %lu, name=\"",
             mode >= ' ' && mode <'z'? mode : '?', mode,
      (ulong)pt->timestamp );
 for(p=pt->name,i=0; i < namelen; p++, i++ ) {
     if( *p >= ' ' && *p <= 'z' )
  putc (*p, listfp);
     else
  fprintf (listfp, "\\x%02x", *p );
 }
 fprintf (listfp, "\",\n\traw data: ");
 if(partial)
   fprintf (listfp, "unknown length\n");
 else
   fprintf (listfp, "%lu bytes\n", (ulong)pt->len );
    }

  leave:
    return rc;
}


static int
parse_compressed( IOBUF inp, int pkttype, unsigned long pktlen,
    PACKET *pkt, int new_ctb )
{
    PKT_compressed *zd;





    zd = pkt->pkt.compressed = xmalloc(sizeof *pkt->pkt.compressed );
    zd->algorithm = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
    zd->len = 0;
    zd->new_ctb = new_ctb;
    zd->buf = inp;
    if( list_mode )
 fprintf (listfp, ":compressed packet: algo=%d\n", zd->algorithm);
    return 0;
}


static int
parse_encrypted( IOBUF inp, int pkttype, unsigned long pktlen,
   PACKET *pkt, int new_ctb, int partial )
{
    int rc = 0;
    PKT_encrypted *ed;
    unsigned long orig_pktlen = pktlen;

    ed = pkt->pkt.encrypted = xmalloc(sizeof *pkt->pkt.encrypted );
    ed->len = pktlen;





    ed->extralen = 0;
    ed->buf = ((void*)0);
    ed->new_ctb = new_ctb;
    ed->is_partial = partial;
    ed->mdc_method = 0;
    if( pkttype == PKT_ENCRYPTED_MDC ) {

 int version;

 version = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);
        if (orig_pktlen)
            pktlen--;
 if( version != 1 ) {
     g10_log_error("encrypted_mdc packet with unknown version %d\n",
        version);

            rc = 14;
     goto leave;
 }
 ed->mdc_method = 2;
    }
    if( orig_pktlen && pktlen < 10 ) {
 g10_log_error("packet(%d) too short\n", pkttype);
        rc = 14;
 iobuf_skip_rest(inp, pktlen, partial);
 goto leave;
    }
    if( list_mode ) {
 if( orig_pktlen )
     fprintf (listfp, ":encrypted data packet:\n\tlength: %lu\n",
                     orig_pktlen);
 else
     fprintf (listfp, ":encrypted data packet:\n\tlength: unknown\n");
 if( ed->mdc_method )
     fprintf (listfp, "\tmdc_method: %d\n", ed->mdc_method );
    }

    ed->buf = inp;

  leave:
    return rc;
}


static int
parse_mdc( IOBUF inp, int pkttype, unsigned long pktlen,
       PACKET *pkt, int new_ctb )
{
    int rc = 0;
    PKT_mdc *mdc;
    byte *p;

    mdc = pkt->pkt.mdc= xmalloc(sizeof *pkt->pkt.mdc );
    if( list_mode )
 fprintf (listfp, ":mdc packet: length=%lu\n", pktlen);
    if( !new_ctb || pktlen != 20 ) {
 g10_log_error("mdc_packet with invalid encoding\n");
        rc = 14;
 goto leave;
    }
    p = mdc->hash;
    for( ; pktlen; pktlen--, p++ )
 *p = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);

  leave:
    return rc;
}
# 2496 "parse-packet.c"
static int
parse_gpg_control( IOBUF inp, int pkttype,
     unsigned long pktlen, PACKET *packet, int partial )
{
    byte *p;
    const byte *sesmark;
    size_t sesmarklen;
    int i;

    if ( list_mode )
        fprintf (listfp, ":packet 63: length %lu ", pktlen);

    sesmark = get_session_marker ( &sesmarklen );
    if ( pktlen < sesmarklen+1 )
        goto skipit;
    for( i=0; i < sesmarklen; i++, pktlen-- ) {
 if ( sesmark[i] != (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff) )
            goto skipit;
    }
    if (pktlen > 4096)
      goto skipit;

    if ( list_mode )
        puts ("- gpg control packet");

    packet->pkt.gpg_control = xmalloc(sizeof *packet->pkt.gpg_control
                                      + pktlen - 1);
    packet->pkt.gpg_control->control = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff); pktlen--;
    packet->pkt.gpg_control->datalen = pktlen;
    p = packet->pkt.gpg_control->data;
    for( ; pktlen; pktlen--, p++ )
 *p = (( (((inp))->nofast || ((inp))->d.start >= ((inp))->d.len )? iobuf_readbyte(((inp))) : ( ((inp))->nbytes++, ((inp))->d.buf[((inp))->d.start++] ) )&0xff);

    return 0;

 skipit:
    if ( list_mode ) {
        int c;

        i=0;
        fprintf (listfp, "- private (rest length %lu)\n", pktlen);
        if( partial ) {
            while( (c=( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )) != -1 )
                dump_hex_line(c, &i);
        }
        else {
            for( ; pktlen; pktlen-- )
              {
                dump_hex_line ((c=( ((inp)->nofast || (inp)->d.start >= (inp)->d.len )? iobuf_readbyte((inp)) : ( (inp)->nbytes++, (inp)->d.buf[(inp)->d.start++] ) )), &i);
                if (c == -1)
                  break;
              }
        }
        putc ('\n', listfp);
    }
    iobuf_skip_rest(inp,pktlen, 0);
    return 14;
}


PACKET *
create_gpg_control( ctrlpkttype_t type, const byte *data, size_t datalen )
{
    PACKET *packet;
    byte *p;

    packet = xmalloc( sizeof *packet );
    do { (packet)->pkttype = 0; (packet)->pkt.generic = ((void*)0); } while(0);
    packet->pkttype = PKT_GPG_CONTROL;
    packet->pkt.gpg_control = xmalloc(sizeof *packet->pkt.gpg_control
                                      + datalen - 1);
    packet->pkt.gpg_control->control = type;
    packet->pkt.gpg_control->datalen = datalen;
    p = packet->pkt.gpg_control->data;
    for( ; datalen; datalen--, p++ )
 *p = *data++;

    return packet;
}
