# 1 "app-openpgp.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 363 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "app-openpgp.c" 2
# 46 "app-openpgp.c"
# 1 "../config.h" 1
# 47 "app-openpgp.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/errno.h" 1 3







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/features.h" 1 3
# 9 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/errno.h" 2 3

# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/errno.h" 1 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 1 3
# 29 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 1 3
# 84 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_header_macro.h" 1 3
# 85 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3



# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 89 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_size_t.h" 1 3
# 18 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 94 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 103 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_wchar_t.h" 1 3
# 24 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_wchar_t.h" 3
typedef int wchar_t;
# 104 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_null.h" 1 3
# 109 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 123 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_max_align_t.h" 1 3
# 19 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 124 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_offsetof.h" 1 3
# 129 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 30 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 2 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 1 3
# 56 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 1 3
# 20 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 146 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long int uintptr_t;
# 161 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int intptr_t;
# 177 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef signed char int8_t;




typedef short int16_t;




typedef int int32_t;




typedef long long int int64_t;




typedef long long int intmax_t;




typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long int uint64_t;
# 227 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int uintmax_t;
# 21 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 2 3

typedef int8_t int_fast8_t;
typedef int64_t int_fast64_t;

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;

typedef uint8_t uint_fast8_t;
typedef uint64_t uint_fast64_t;

typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
# 95 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/stdint.h" 1 3
typedef int32_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef uint32_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
# 96 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 2 3
# 57 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 2 3
# 31 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 2 3





                                                             ;
                                                              ;
                                                              ;
                                                               ;
                                                              ;
                                                               ;
                                                              ;
                                                               ;
                                                            ;







typedef long unsigned int __wasi_size_t;

                                                                  ;
                                                                     ;




typedef uint64_t __wasi_filesize_t;

                                                                      ;
                                                                         ;




typedef uint64_t __wasi_timestamp_t;

                                                                       ;
                                                                          ;




typedef uint32_t __wasi_clockid_t;
# 102 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;







typedef uint16_t __wasi_errno_t;
# 498 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                   ;
                                                                      ;




typedef uint64_t __wasi_rights_t;
# 663 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint32_t __wasi_fd_t;

                                                                ;
                                                                   ;




typedef struct __wasi_iovec_t {



    uint8_t * buf;




    __wasi_size_t buf_len;

} __wasi_iovec_t;

                                                                   ;
                                                                      ;
                                                                            ;
                                                                                ;




typedef struct __wasi_ciovec_t {



    const uint8_t * buf;




    __wasi_size_t buf_len;

} __wasi_ciovec_t;

                                                                    ;
                                                                       ;
                                                                             ;
                                                                                 ;




typedef int64_t __wasi_filedelta_t;

                                                                       ;
                                                                          ;




typedef uint8_t __wasi_whence_t;
# 744 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;






typedef uint64_t __wasi_dircookie_t;

                                                                       ;
                                                                          ;




typedef uint32_t __wasi_dirnamlen_t;

                                                                       ;
                                                                          ;




typedef uint64_t __wasi_inode_t;

                                                                   ;
                                                                      ;




typedef uint8_t __wasi_filetype_t;
# 818 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                      ;
                                                                         ;




typedef struct __wasi_dirent_t {



    __wasi_dircookie_t d_next;




    __wasi_inode_t d_ino;




    __wasi_dirnamlen_t d_namlen;




    __wasi_filetype_t d_type;

} __wasi_dirent_t;

                                                                     ;
                                                                       ;
                                                                                ;
                                                                               ;
                                                                                   ;
                                                                                 ;




typedef uint8_t __wasi_advice_t;
# 889 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint16_t __wasi_fdflags_t;
# 924 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef struct __wasi_fdstat_t {



    __wasi_filetype_t fs_filetype;




    __wasi_fdflags_t fs_flags;




    __wasi_rights_t fs_rights_base;





    __wasi_rights_t fs_rights_inheriting;

} __wasi_fdstat_t;

                                                                     ;
                                                                       ;
                                                                                     ;
                                                                                  ;
                                                                                        ;
                                                                                               ;





typedef uint64_t __wasi_device_t;

                                                                    ;
                                                                       ;




typedef uint16_t __wasi_fstflags_t;
# 995 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                      ;
                                                                         ;




typedef uint32_t __wasi_lookupflags_t;






                                                                         ;
                                                                            ;




typedef uint16_t __wasi_oflags_t;
# 1036 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint64_t __wasi_linkcount_t;

                                                                       ;
                                                                          ;




typedef struct __wasi_filestat_t {



    __wasi_device_t dev;




    __wasi_inode_t ino;




    __wasi_filetype_t filetype;




    __wasi_linkcount_t nlink;




    __wasi_filesize_t size;




    __wasi_timestamp_t atim;




    __wasi_timestamp_t mtim;




    __wasi_timestamp_t ctim;

} __wasi_filestat_t;

                                                                       ;
                                                                         ;
                                                                               ;
                                                                               ;
                                                                                     ;
                                                                                  ;
                                                                                 ;
                                                                                 ;
                                                                                 ;
                                                                                 ;





typedef uint64_t __wasi_userdata_t;

                                                                      ;
                                                                         ;




typedef uint8_t __wasi_eventtype_t;
# 1136 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                       ;
                                                                          ;





typedef uint16_t __wasi_eventrwflags_t;






                                                                          ;
                                                                             ;





typedef struct __wasi_event_fd_readwrite_t {



    __wasi_filesize_t nbytes;




    __wasi_eventrwflags_t flags;

} __wasi_event_fd_readwrite_t;

                                                                                 ;
                                                                                   ;
                                                                                            ;
                                                                                           ;




typedef union __wasi_event_u_t {



    __wasi_event_fd_readwrite_t fd_readwrite;

} __wasi_event_u_t;

                                                                      ;
                                                                        ;




typedef struct __wasi_event_t {



    __wasi_userdata_t userdata;




    __wasi_errno_t error;




    __wasi_eventtype_t type;




    __wasi_event_u_t u;

} __wasi_event_t;

                                                                    ;
                                                                      ;
                                                                                 ;
                                                                              ;
                                                                              ;
                                                                           ;





typedef uint16_t __wasi_subclockflags_t;
# 1237 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                           ;
                                                                              ;




typedef struct __wasi_subscription_clock_t {



    __wasi_clockid_t id;




    __wasi_timestamp_t timeout;





    __wasi_timestamp_t precision;




    __wasi_subclockflags_t flags;

} __wasi_subscription_clock_t;

                                                                                 ;
                                                                                   ;
                                                                                        ;
                                                                                             ;
                                                                                                ;
                                                                                            ;





typedef struct __wasi_subscription_fd_readwrite_t {



    __wasi_fd_t file_descriptor;

} __wasi_subscription_fd_readwrite_t;

                                                                                       ;
                                                                                          ;
                                                                                                            ;




typedef union __wasi_subscription_u_t {



    __wasi_subscription_clock_t clock;




    __wasi_subscription_fd_readwrite_t fd_readwrite;

} __wasi_subscription_u_t;

                                                                             ;
                                                                               ;




typedef struct __wasi_subscription_t {




    __wasi_userdata_t userdata;




    __wasi_eventtype_t type;




    __wasi_subscription_u_t u;

} __wasi_subscription_t;

                                                                           ;
                                                                             ;
                                                                                        ;
                                                                                    ;
                                                                                  ;




typedef uint32_t __wasi_exitcode_t;

                                                                      ;
                                                                         ;




typedef uint8_t __wasi_signal_t;
# 1536 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint16_t __wasi_riflags_t;
# 1554 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef uint16_t __wasi_roflags_t;






                                                                     ;
                                                                        ;





typedef uint16_t __wasi_siflags_t;

                                                                     ;
                                                                        ;




typedef uint8_t __wasi_sdflags_t;
# 1594 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef uint8_t __wasi_preopentype_t;






                                                                         ;
                                                                            ;




typedef struct __wasi_prestat_dir_t {



    __wasi_size_t pr_name_len;

} __wasi_prestat_dir_t;

                                                                         ;
                                                                            ;
                                                                                          ;




typedef union __wasi_prestat_u_t {



    __wasi_prestat_dir_t dir;

} __wasi_prestat_u_t;

                                                                       ;
                                                                          ;




typedef struct __wasi_prestat_t {



    __wasi_preopentype_t pr_type;




    __wasi_prestat_u_t u;

} __wasi_prestat_t;

                                                                     ;
                                                                        ;
                                                                                  ;
                                                                            ;
# 1669 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_args_get(
    uint8_t * * argv,

    uint8_t * argv_buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("args_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_args_sizes_get(



    __wasi_size_t *argc,



    __wasi_size_t *argv_buf_size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("args_sizes_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_environ_get(
    uint8_t * * environ,

    uint8_t * environ_buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("environ_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_environ_sizes_get(



    __wasi_size_t *argc,



    __wasi_size_t *argv_buf_size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("environ_sizes_get"),
    __warn_unused_result__
));







__wasi_errno_t __wasi_clock_res_get(



    __wasi_clockid_t id,




    __wasi_timestamp_t *resolution
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("clock_res_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_clock_time_get(



    __wasi_clockid_t id,




    __wasi_timestamp_t precision,




    __wasi_timestamp_t *time
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("clock_time_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_advise(
    __wasi_fd_t fd,




    __wasi_filesize_t offset,




    __wasi_filesize_t len,




    __wasi_advice_t advice
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_advise"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_allocate(
    __wasi_fd_t fd,




    __wasi_filesize_t offset,




    __wasi_filesize_t len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_allocate"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_close(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_close"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_datasync(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_datasync"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_get(
    __wasi_fd_t fd,




    __wasi_fdstat_t *stat
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_set_flags(
    __wasi_fd_t fd,




    __wasi_fdflags_t flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_set_flags"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_set_rights(
    __wasi_fd_t fd,




    __wasi_rights_t fs_rights_base,

    __wasi_rights_t fs_rights_inheriting
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_set_rights"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_filestat_get(
    __wasi_fd_t fd,




    __wasi_filestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_filestat_set_size(
    __wasi_fd_t fd,




    __wasi_filesize_t size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_set_size"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_filestat_set_times(
    __wasi_fd_t fd,




    __wasi_timestamp_t atim,




    __wasi_timestamp_t mtim,




    __wasi_fstflags_t fst_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_set_times"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_pread(
    __wasi_fd_t fd,




    const __wasi_iovec_t *iovs,




    size_t iovs_len,




    __wasi_filesize_t offset,




    __wasi_size_t *nread
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_pread"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_prestat_get(
    __wasi_fd_t fd,




    __wasi_prestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_prestat_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_prestat_dir_name(
    __wasi_fd_t fd,




    uint8_t * path,

    __wasi_size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_prestat_dir_name"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_pwrite(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *iovs,




    size_t iovs_len,




    __wasi_filesize_t offset,




    __wasi_size_t *nwritten
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_pwrite"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_read(
    __wasi_fd_t fd,




    const __wasi_iovec_t *iovs,




    size_t iovs_len,




    __wasi_size_t *nread
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_read"),
    __warn_unused_result__
));
# 2098 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_fd_readdir(
    __wasi_fd_t fd,




    uint8_t * buf,

    __wasi_size_t buf_len,




    __wasi_dircookie_t cookie,




    __wasi_size_t *bufused
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_readdir"),
    __warn_unused_result__
));
# 2133 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_fd_renumber(
    __wasi_fd_t fd,




    __wasi_fd_t to
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_renumber"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_seek(
    __wasi_fd_t fd,




    __wasi_filedelta_t offset,




    __wasi_whence_t whence,




    __wasi_filesize_t *newoffset
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_seek"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_sync(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_sync"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_tell(
    __wasi_fd_t fd,




    __wasi_filesize_t *offset
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_tell"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_write(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *iovs,




    size_t iovs_len,




    __wasi_size_t *nwritten
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_write"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_create_directory(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_create_directory"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_filestat_get(
    __wasi_fd_t fd,




    __wasi_lookupflags_t flags,




    const char *path,




    size_t path_len,




    __wasi_filestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_filestat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_filestat_set_times(
    __wasi_fd_t fd,




    __wasi_lookupflags_t flags,




    const char *path,




    size_t path_len,




    __wasi_timestamp_t atim,




    __wasi_timestamp_t mtim,




    __wasi_fstflags_t fst_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_filestat_set_times"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_link(
    __wasi_fd_t old_fd,




    __wasi_lookupflags_t old_flags,




    const char *old_path,




    size_t old_path_len,




    __wasi_fd_t new_fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_link"),
    __warn_unused_result__
));
# 2376 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_path_open(
    __wasi_fd_t fd,




    __wasi_lookupflags_t dirflags,





    const char *path,




    size_t path_len,




    __wasi_oflags_t oflags,
# 2409 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
    __wasi_rights_t fs_rights_base,

    __wasi_rights_t fs_rights_inherting,

    __wasi_fdflags_t fdflags,




    __wasi_fd_t *opened_fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_open"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_readlink(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len,




    uint8_t * buf,

    __wasi_size_t buf_len,




    __wasi_size_t *bufused
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_readlink"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_path_remove_directory(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_remove_directory"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_rename(
    __wasi_fd_t fd,




    const char *old_path,




    size_t old_path_len,




    __wasi_fd_t new_fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_rename"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_symlink(



    const char *old_path,




    size_t old_path_len,

    __wasi_fd_t fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_symlink"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_path_unlink_file(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_unlink_file"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_poll_oneoff(



    const __wasi_subscription_t * in,




    __wasi_event_t * out,




    __wasi_size_t nsubscriptions,




    __wasi_size_t *nevents
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("poll_oneoff"),
    __warn_unused_result__
));






_Noreturn void __wasi_proc_exit(



    __wasi_exitcode_t rval
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("proc_exit")));





__wasi_errno_t __wasi_proc_raise(



    __wasi_signal_t sig
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("proc_raise"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_sched_yield(
    void
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sched_yield"),
    __warn_unused_result__
));
# 2652 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_random_get(



    uint8_t * buf,

    __wasi_size_t buf_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("random_get"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_sock_recv(
    __wasi_fd_t fd,




    const __wasi_iovec_t *ri_data,




    size_t ri_data_len,




    __wasi_riflags_t ri_flags,




    __wasi_size_t *ro_datalen,



    __wasi_roflags_t *ro_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_recv"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_sock_send(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *si_data,




    size_t si_data_len,




    __wasi_siflags_t si_flags,




    __wasi_size_t *so_datalen
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_send"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_sock_shutdown(
    __wasi_fd_t fd,




    __wasi_sdflags_t how
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_shutdown"),
    __warn_unused_result__
));
# 2 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/errno.h" 2 3
# 11 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/errno.h" 2 3


__attribute__((const))

int *__errno_location(void);



extern char *program_invocation_short_name, *program_invocation_name;
# 48 "app-openpgp.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 1 3
# 30 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef __builtin_va_list va_list;




typedef __builtin_va_list __isoc_va_list;
# 141 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long int size_t;
# 156 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int ssize_t;
# 243 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long long int off_t;
# 400 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct _IO_FILE FILE;
# 31 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 2 3
# 66 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 3
typedef union _G_fpos64_t {
 char __opaque[16];
 long long __lldata;
 double __align;
} fpos_t;

extern FILE *const stdin;
extern FILE *const stdout;
extern FILE *const stderr;





FILE *fopen(const char *restrict, const char *restrict);
FILE *freopen(const char *restrict, const char *restrict, FILE *restrict);
int fclose(FILE *);

int remove(const char *);
int rename(const char *, const char *);

int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
void clearerr(FILE *);

int fseek(FILE *, long, int);
long ftell(FILE *);
void rewind(FILE *);

int fgetpos(FILE *restrict, fpos_t *restrict);
int fsetpos(FILE *, const fpos_t *);

size_t fread(void *restrict, size_t, size_t, FILE *restrict);
size_t fwrite(const void *restrict, size_t, size_t, FILE *restrict);

int fgetc(FILE *);
int getc(FILE *);
int getchar(void);
int ungetc(int, FILE *);

int fputc(int, FILE *);
int putc(int, FILE *);
int putchar(int);

char *fgets(char *restrict, int, FILE *restrict);




int fputs(const char *restrict, FILE *restrict);
int puts(const char *);

int printf(const char *restrict, ...);
int fprintf(FILE *restrict, const char *restrict, ...);
int sprintf(char *restrict, const char *restrict, ...);
int snprintf(char *restrict, size_t, const char *restrict, ...);

int vprintf(const char *restrict, __isoc_va_list);
int vfprintf(FILE *restrict, const char *restrict, __isoc_va_list);
int vsprintf(char *restrict, const char *restrict, __isoc_va_list);
int vsnprintf(char *restrict, size_t, const char *restrict, __isoc_va_list);

int scanf(const char *restrict, ...);
int fscanf(FILE *restrict, const char *restrict, ...);
int sscanf(const char *restrict, const char *restrict, ...);
int vscanf(const char *restrict, __isoc_va_list);
int vfscanf(FILE *restrict, const char *restrict, __isoc_va_list);
int vsscanf(const char *restrict, const char *restrict, __isoc_va_list);

void perror(const char *);

int setvbuf(FILE *restrict, char *restrict, int, size_t);
void setbuf(FILE *restrict, char *restrict);

char *tmpnam(char *);
FILE *tmpfile(void);




FILE *fmemopen(void *restrict, size_t, const char *restrict);
FILE *open_memstream(char **, size_t *);
FILE *fdopen(int, const char *);
FILE *popen(const char *, const char *);
int pclose(FILE *);
int fileno(FILE *);
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
int dprintf(int, const char *restrict, ...);
int vdprintf(int, const char *restrict, __isoc_va_list);
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);
ssize_t getdelim(char **restrict, size_t *restrict, int, FILE *restrict);
ssize_t getline(char **restrict, size_t *restrict, FILE *restrict);
int renameat(int, const char *, int, const char *);
char *ctermid(char *);







char *tempnam(const char *, const char *);




char *cuserid(char *);
void setlinebuf(FILE *);
void setbuffer(FILE *, char *, size_t);
int fgetc_unlocked(FILE *);
int fputc_unlocked(int, FILE *);
int fflush_unlocked(FILE *);
size_t fread_unlocked(void *, size_t, size_t, FILE *);
size_t fwrite_unlocked(const void *, size_t, size_t, FILE *);
void clearerr_unlocked(FILE *);
int feof_unlocked(FILE *);
int ferror_unlocked(FILE *);
int fileno_unlocked(FILE *);
int getw(FILE *);
int putw(int, FILE *);
char *fgetln(FILE *, size_t *);
int asprintf(char **, const char *, ...);
int vasprintf(char **, const char *, __isoc_va_list);



char *fgets_unlocked(char *, int, FILE *);
int fputs_unlocked(const char *, FILE *);

typedef ssize_t (cookie_read_function_t)(void *, char *, size_t);
typedef ssize_t (cookie_write_function_t)(void *, const char *, size_t);
typedef int (cookie_seek_function_t)(void *, off_t *, int);
typedef int (cookie_close_function_t)(void *);

typedef struct _IO_cookie_io_functions_t {
 cookie_read_function_t *read;
 cookie_write_function_t *write;
 cookie_seek_function_t *seek;
 cookie_close_function_t *close;
} cookie_io_functions_t;

FILE *fopencookie(void *, const char *, cookie_io_functions_t);
# 49 "app-openpgp.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h" 1 3







int getloadavg(double loadavg[], int nelem);





# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 1 3
# 21 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 40 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int wchar_t;
# 22 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 2 3

int atoi (const char *);
long atol (const char *);
long long atoll (const char *);
double atof (const char *);

float strtof (const char *restrict, char **restrict);
double strtod (const char *restrict, char **restrict);
long double strtold (const char *restrict, char **restrict);

long strtol (const char *restrict, char **restrict, int);
unsigned long strtoul (const char *restrict, char **restrict, int);
long long strtoll (const char *restrict, char **restrict, int);
unsigned long long strtoull (const char *restrict, char **restrict, int);

int rand (void);
void srand (unsigned);

void *malloc (size_t);
void *calloc (size_t, size_t);
void *realloc (void *, size_t);
void free (void *);
void *aligned_alloc(size_t, size_t);

_Noreturn void abort (void);
int atexit (void (*) (void));
_Noreturn void exit (int);
_Noreturn void _Exit (int);
int at_quick_exit (void (*) (void));
_Noreturn void quick_exit (int);

char *getenv (const char *);

int system (const char *);

void *bsearch (const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
void qsort (void *, size_t, size_t, int (*)(const void *, const void *));

int abs (int);
long labs (long);
long long llabs (long long);

typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;
typedef struct { long long quot, rem; } lldiv_t;

div_t div (int, int);
ldiv_t ldiv (long, long);
lldiv_t lldiv (long long, long long);

int mblen (const char *, size_t);
int mbtowc (wchar_t *restrict, const char *restrict, size_t);
int wctomb (char *, wchar_t);
size_t mbstowcs (wchar_t *restrict, const char *restrict, size_t);
size_t wcstombs (char *restrict, const wchar_t *restrict, size_t);




size_t __ctype_get_mb_cur_max(void);
# 101 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 3
int posix_memalign (void **, size_t, size_t);
int setenv (const char *, const char *, int);
int unsetenv (const char *);
int mkstemp (char *);
int mkostemp (char *, int);
char *mkdtemp (char *);
int getsubopt (char **, char *const *, char **);
int rand_r (unsigned *);






char *realpath (const char *restrict, char *restrict);
long int random (void);
void srandom (unsigned int);
char *initstate (unsigned int, char *, size_t);
char *setstate (char *);
int putenv (char *);
int posix_openpt (int);
int grantpt (int);
int unlockpt (int);
char *ptsname (int);
char *l64a (long);
long a64l (const char *);
void setkey (const char *);
double drand48 (void);
double erand48 (unsigned short [3]);
long int lrand48 (void);
long int nrand48 (unsigned short [3]);
long mrand48 (void);
long jrand48 (unsigned short [3]);
void srand48 (long);
unsigned short *seed48 (unsigned short [3]);
void lcong48 (unsigned short [7]);



# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h" 1 3








# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h" 2 3

void *alloca(size_t);
# 141 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 2 3
char *mktemp (char *);
int mkstemps (char *, int);
int mkostemps (char *, int, int);
void *valloc (size_t);
void *memalign(size_t, size_t);
int getloadavg(double *, int);
int clearenv(void);


void *reallocarray (void *, size_t, size_t);
void qsort_r (void *, size_t, size_t, int (*)(const void *, const void *, void *), void *);



int ptsname_r(int, char *, size_t);
char *ecvt(double, int, int *, int *);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
char *secure_getenv(const char *);
struct __locale_struct;
float strtof_l(const char *restrict, char **restrict, struct __locale_struct *);
double strtod_l(const char *restrict, char **restrict, struct __locale_struct *);
long double strtold_l(const char *restrict, char **restrict, struct __locale_struct *);
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h" 2 3
# 50 "app-openpgp.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/string.h" 1 3







extern char* strlwr(char *);
extern char* strupr(char *);





# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 1 3
# 25 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 412 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __locale_struct * locale_t;
# 26 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 2 3

void *memcpy (void *restrict, const void *restrict, size_t);
void *memmove (void *, const void *, size_t);
void *memset (void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void *memchr (const void *, int, size_t);

char *strcpy (char *restrict, const char *restrict);
char *strncpy (char *restrict, const char *restrict, size_t);

char *strcat (char *restrict, const char *restrict);
char *strncat (char *restrict, const char *restrict, size_t);

int strcmp (const char *, const char *);
int strncmp (const char *, const char *, size_t);

int strcoll (const char *, const char *);
size_t strxfrm (char *restrict, const char *restrict, size_t);

char *strchr (const char *, int);
char *strrchr (const char *, int);

size_t strcspn (const char *, const char *);
size_t strspn (const char *, const char *);
char *strpbrk (const char *, const char *);
char *strstr (const char *, const char *);
char *strtok (char *restrict, const char *restrict);

size_t strlen (const char *);

char *strerror (int);


# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 2 3




int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
char *index (const char *, int);
char *rindex (const char *, int);



int ffs (int);
int ffsl (long);
int ffsll (long long);


int strcasecmp (const char *, const char *);
int strncasecmp (const char *, const char *, size_t);

int strcasecmp_l (const char *, const char *, locale_t);
int strncasecmp_l (const char *, const char *, size_t, locale_t);
# 60 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 2 3





char *strtok_r (char *restrict, const char *restrict, char **restrict);
int strerror_r (int, char *, size_t);
char *stpcpy(char *restrict, const char *restrict);
char *stpncpy(char *restrict, const char *restrict, size_t);
size_t strnlen (const char *, size_t);
char *strdup (const char *);
char *strndup (const char *, size_t);
char *strsignal(int);
char *strerror_l (int, locale_t);
int strcoll_l (const char *, const char *, locale_t);
size_t strxfrm_l (char *restrict, const char *restrict, size_t, locale_t);
void *memmem(const void *, size_t, const void *, size_t);




void *memccpy (void *restrict, const void *restrict, int, size_t);



char *strsep(char **, const char *);
size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
void explicit_bzero (void *, size_t);




int strverscmp (const char *, const char *);
char *strchrnul(const char *, int);
char *strcasestr(const char *, const char *);
void *memrchr(const void *, int, size_t);
void *mempcpy(void *, const void *, size_t);
# 16 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/string.h" 2 3
# 51 "app-openpgp.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/assert.h" 1 3
# 19 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/assert.h" 3
_Noreturn void __assert_fail (const char *, const char *, int, const char *);
# 52 "app-openpgp.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/time.h" 1 3







int dysize(int year);







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 1 3
# 33 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 83 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long long int time_t;
# 289 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef void * timer_t;




typedef int clockid_t;




typedef int clock_t;
# 314 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
struct timespec { time_t tv_sec; long tv_nsec; };





typedef int pid_t;
# 34 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 2 3






struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 const char *tm_zone;
};

clock_t clock (void);
time_t time (time_t *);
double difftime (time_t, time_t);
time_t mktime (struct tm *);
size_t strftime (char *restrict, size_t, const char *restrict, const struct tm *restrict);
struct tm *gmtime (const time_t *);
struct tm *localtime (const time_t *);
char *asctime (const struct tm *);
char *ctime (const time_t *);
int timespec_get(struct timespec *, int);
# 73 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 3
size_t strftime_l (char * restrict, size_t, const char * restrict, const struct tm * restrict, locale_t);

struct tm *gmtime_r (const time_t *restrict, struct tm *restrict);
struct tm *localtime_r (const time_t *restrict, struct tm *restrict);
char *asctime_r (const struct tm *restrict, char *restrict);
char *ctime_r (const time_t *, char *);

void tzset (void);

struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};
# 102 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 3
int nanosleep (const struct timespec *, struct timespec *);
int clock_getres (clockid_t, struct timespec *);
int clock_gettime (clockid_t, struct timespec *);
int clock_settime (clockid_t, const struct timespec *);
int clock_nanosleep (clockid_t, int, const struct timespec *, struct timespec *);
int clock_getcpuclockid (pid_t, clockid_t *);

struct sigevent;
int timer_create (clockid_t, struct sigevent *restrict, timer_t *restrict);
int timer_delete (timer_t);
int timer_settime (timer_t, int, const struct itimerspec *restrict, struct itimerspec *restrict);
int timer_gettime (timer_t, struct itimerspec *);
int timer_getoverrun (timer_t);

extern char *tzname[2];





char *strptime (const char *restrict, const char *restrict, struct tm *restrict);
extern int daylight;
extern long timezone;
extern int getdate_err;
struct tm *getdate (const char *);




int stime(const time_t *);
time_t timegm(struct tm *);
# 17 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/time.h" 2 3
# 53 "app-openpgp.c" 2





# 1 "./options.h" 1
# 23 "./options.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 1 3
# 57 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 88 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int suseconds_t;





typedef struct {
    union {
        int __i[10];
        volatile int __vi[10];
        unsigned long __s[10];
    } __u;



    const char *_a_transferredcanvases;

} pthread_attr_t;




typedef struct { union { int __i[6]; volatile int __vi[6]; volatile void *__p[6]; } __u; } pthread_mutex_t;
# 120 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct { union { int __i[12]; volatile int __vi[12]; void *__p[12]; } __u; } pthread_cond_t;
# 130 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct { union { int __i[sizeof(long)==8?14:8]; volatile int __vi[sizeof(long)==8?14:8]; void *__p[sizeof(long)==8?7:8]; } __u; } pthread_rwlock_t;




typedef struct { union { int __i[5]; volatile int __vi[5]; void *__p[5]; } __u; } pthread_barrier_t;
# 171 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int register_t;
# 222 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int u_int64_t;
# 233 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned mode_t;




typedef unsigned long int nlink_t;
# 248 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int ino_t;




typedef unsigned int dev_t;




typedef int blksize_t;




typedef int blkcnt_t;




typedef unsigned int fsblkcnt_t;




typedef unsigned int fsfilcnt_t;
# 325 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned id_t;




typedef unsigned uid_t;




typedef unsigned gid_t;




typedef int key_t;




typedef unsigned useconds_t;
# 358 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __pthread * pthread_t;





typedef int pthread_once_t;




typedef unsigned pthread_key_t;




typedef int pthread_spinlock_t;




typedef struct { unsigned __attr; } pthread_mutexattr_t;




typedef struct { unsigned __attr; } pthread_condattr_t;




typedef struct { unsigned __attr; } pthread_barrierattr_t;




typedef struct { unsigned __attr[2]; } pthread_rwlockattr_t;
# 58 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3


typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned u_int32_t;
typedef char *caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short, ushort;
typedef unsigned u_int, uint;
typedef unsigned long u_long, ulong;
typedef long long quad_t;
typedef unsigned long long u_quad_t;
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 11 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 2 3








static inline uint16_t __bswap16(uint16_t __x)
{
 return __x<<8 | __x>>8;
}

static inline uint32_t __bswap32(uint32_t __x)
{
 return __x>>24 | __x>>8&0xff00 | __x<<8&0xff0000 | __x<<24;
}

static inline uint64_t __bswap64(uint64_t __x)
{
 return __bswap32(__x)+0ULL<<32 | __bswap32(__x>>32);
}
# 71 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 1 3
# 16 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 309 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
struct timeval { time_t tv_sec; suseconds_t tv_usec; };
# 418 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __sigset_t { unsigned long __bits[128/sizeof(long)]; } sigset_t;
# 17 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 2 3



typedef unsigned long fd_mask;

typedef struct {
 unsigned long fds_bits[1024 / 8 / sizeof(long)];
} fd_set;






int select (int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict);
int pselect (int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict);
# 72 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3
# 24 "./options.h" 2
# 1 "../include/types.h" 1
# 24 "../include/types.h"
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 1 3
# 24 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 2 3

typedef struct { intmax_t quot, rem; } imaxdiv_t;

intmax_t imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);

intmax_t strtoimax(const char *restrict, char **restrict, int);
uintmax_t strtoumax(const char *restrict, char **restrict, int);

intmax_t wcstoimax(const wchar_t *restrict, wchar_t **restrict, int);
uintmax_t wcstoumax(const wchar_t *restrict, wchar_t **restrict, int);
# 25 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 2 3
# 25 "../include/types.h" 2
# 49 "../include/types.h"
typedef unsigned char byte;
# 76 "../include/types.h"
typedef unsigned short u16;
# 86 "../include/types.h"
typedef unsigned int u32;
# 103 "../include/types.h"
typedef uint64_t u64;
# 126 "../include/types.h"
typedef union {
    int a;
    short b;
    char c[1];
    long d;

    u64 e;

    float f;
    double g;
} PROPERLY_ALIGNED_TYPE;

struct string_list {
    struct string_list *next;
    unsigned int flags;
    char d[1];
};
typedef struct string_list *STRLIST;
typedef struct string_list *strlist_t;
# 25 "./options.h" 2
# 1 "./main.h" 1
# 23 "./main.h"
# 1 "../include/iobuf.h" 1
# 36 "../include/iobuf.h"
typedef struct iobuf_struct *IOBUF;
typedef struct iobuf_struct *iobuf_t;


struct iobuf_struct {
    int use;
    off_t nlimit;
    off_t nbytes;
    off_t ntotal;
    int nofast;
    void *directfp;
    struct {
 size_t size;
 size_t start;
 size_t len;
 byte *buf;
    } d;
    int filter_eof;
    int error;
    int (*filter)( void *opaque, int control,
     IOBUF chain, byte *buf, size_t *len);
    void *filter_ov;
    int filter_ov_owner;
    char *real_fname;
    IOBUF chain;
    int no, subno;
    void *opaque;

    struct {
 size_t size;
 size_t start;
 size_t len;
 byte *buf;
    } unget;
};
# 81 "../include/iobuf.h"
int iobuf_debug_mode;

void iobuf_enable_special_filenames ( int yes );
int iobuf_is_pipe_filename (const char *fname);
IOBUF iobuf_alloc(int use, size_t bufsize);
IOBUF iobuf_temp(void);
IOBUF iobuf_temp_with_content( const char *buffer, size_t length );
IOBUF iobuf_open( const char *fname );
IOBUF iobuf_fdopen( int fd, const char *mode );
IOBUF iobuf_sockopen( int fd, const char *mode );
IOBUF iobuf_create( const char *fname );
IOBUF iobuf_append( const char *fname );
IOBUF iobuf_openrw( const char *fname );
int iobuf_ioctl ( IOBUF a, int cmd, int intval, void *ptrval );
int iobuf_close( IOBUF iobuf );
int iobuf_cancel( IOBUF iobuf );

int iobuf_push_filter( IOBUF a, int (*f)(void *opaque, int control,
         IOBUF chain, byte *buf, size_t *len), void *ov );
int iobuf_push_filter2( IOBUF a,
      int (*f)(void *opaque, int control,
      IOBUF chain, byte *buf, size_t *len),
      void *ov, int rel_ov );
int iobuf_flush(IOBUF a);
void iobuf_clear_eof(IOBUF a);



void iobuf_set_limit( IOBUF a, off_t nlimit );

off_t iobuf_tell( IOBUF a );
int iobuf_seek( IOBUF a, off_t newpos );

int iobuf_readbyte(IOBUF a);
int iobuf_read(IOBUF a, byte *buf, unsigned buflen );
unsigned iobuf_read_line( IOBUF a, byte **addr_of_buffer,
     unsigned *length_of_buffer, unsigned *max_length );
int iobuf_peek(IOBUF a, byte *buf, unsigned buflen );
int iobuf_writebyte(IOBUF a, unsigned c);
int iobuf_write(IOBUF a, byte *buf, unsigned buflen );
int iobuf_writestr(IOBUF a, const char *buf );

void iobuf_flush_temp( IOBUF temp );
int iobuf_write_temp( IOBUF a, IOBUF temp );
size_t iobuf_temp_to_buffer( IOBUF a, byte *buffer, size_t buflen );
void iobuf_unget_and_close_temp( IOBUF a, IOBUF temp );

int iobuf_get_fd (IOBUF a);
off_t iobuf_get_filelength (IOBUF a, int *overflow);

const char *iobuf_get_real_fname( IOBUF a );
const char *iobuf_get_fname( IOBUF a );

void iobuf_set_partial_block_mode( IOBUF a, size_t len );

int iobuf_translate_file_handle ( int fd, int for_write );
# 160 "../include/iobuf.h"
void iobuf_skip_rest (IOBUF a, unsigned long n, int partial);
# 24 "./main.h" 2
# 1 "../include/mpi.h" 1
# 32 "../include/mpi.h"
# 1 "../config.h" 1
# 33 "../include/mpi.h" 2



# 1 "../include/memory.h" 1
# 57 "../include/memory.h"
void *xmalloc( size_t n );
void *xtrymalloc (size_t n);
void *xmalloc_clear( size_t n );
void *xmalloc_secure( size_t n );
void *xmalloc_secure_clear( size_t n );
void *xrealloc( void *a, size_t n );
void xfree( void *p );
void m_check( const void *a );

char *xstrdup( const char * a);
char *xtrystrdup (const char *a);


size_t m_size( const void *a );
void m_print_stats(const char *prefix);


void *xcalloc (size_t n, size_t m);
void *xcalloc_secure (size_t n, size_t m);



int secmem_init( size_t npool );
void secmem_term( void );
void *secmem_malloc( size_t size );
void *secmexrealloc( void *a, size_t newsize );
void secmem_free( void *a );
int m_is_secure( const void *p );
void secmem_dump_stats(void);
void secmem_set_flags( unsigned flags );
unsigned secmem_get_flags(void);
# 102 "../include/memory.h"
int memory_debug_mode;
int memory_stat_debug_mode;
# 37 "../include/mpi.h" 2
# 49 "../include/mpi.h"
int mpi_debug_mode;


struct gcry_mpi;
typedef struct gcry_mpi *MPI;
# 72 "../include/mpi.h"
MPI mpi_alloc( unsigned nlimbs );
MPI mpi_alloc_secure( unsigned nlimbs );
MPI mpi_alloc_like( MPI a );
void mpi_free( MPI a );
void mpi_resize( MPI a, unsigned nlimbs );
MPI mpi_copy( MPI a );


MPI mpi_set_opaque( MPI a, void *p, unsigned int len );
void *mpi_get_opaque( MPI a, unsigned int *len );

void mpi_set_secure( MPI a );
void mpi_clear( MPI a );
void mpi_set( MPI w, MPI u);
void mpi_set_cond( MPI w, MPI u, unsigned long set);
void mpi_set_ui( MPI w, ulong u);
MPI mpi_alloc_set_ui( unsigned long u);
void mpi_m_check( MPI a );
void mpi_swap( MPI a, MPI b);
int mpi_get_nlimbs (MPI a);
int mpi_is_neg (MPI a);
unsigned int mpi_nlimb_hint_from_nbytes (unsigned int nbytes);
unsigned int mpi_nlimb_hint_from_nbits (unsigned int nbits);
unsigned int mpi_get_flags (MPI a);


int mpi_write( IOBUF out, MPI a );




MPI mpi_read(IOBUF inp, unsigned *nread, int secure);

MPI mpi_read_from_buffer(byte *buffer, unsigned *ret_nread, int secure);
int mpi_fromstr(MPI val, const char *str);
int mpi_print( FILE *fp, MPI a, int mode );
void g10_log_mpidump( const char *text, MPI a );
u32 mpi_get_keyid( MPI a, u32 *keyid );
byte *mpi_get_buffer( MPI a, unsigned *nbytes, int *sign );
byte *mpi_get_secure_buffer( MPI a, unsigned *nbytes, int *sign );
void mpi_set_buffer( MPI a, const byte *buffer, unsigned nbytes, int sign );




void mpi_add_ui(MPI w, MPI u, ulong v );
void mpi_add(MPI w, MPI u, MPI v);
void mpi_addm(MPI w, MPI u, MPI v, MPI m);
void mpi_sub_ui(MPI w, MPI u, ulong v );
void mpi_sub( MPI w, MPI u, MPI v);
void mpi_subm( MPI w, MPI u, MPI v, MPI m);


void mpi_mul_ui(MPI w, MPI u, ulong v );
void mpi_mul_2exp( MPI w, MPI u, ulong cnt);
void mpi_mul( MPI w, MPI u, MPI v);
void mpi_mulm( MPI w, MPI u, MPI v, MPI m);


ulong mpi_fdiv_r_ui( MPI rem, MPI dividend, ulong divisor );
void mpi_fdiv_r( MPI rem, MPI dividend, MPI divisor );
void mpi_fdiv_q( MPI quot, MPI dividend, MPI divisor );
void mpi_fdiv_qr( MPI quot, MPI rem, MPI dividend, MPI divisor );
void mpi_tdiv_r( MPI rem, MPI num, MPI den);
void mpi_tdiv_qr( MPI quot, MPI rem, MPI num, MPI den);
void mpi_tdiv_q_2exp( MPI w, MPI u, unsigned count );
int mpi_divisible_ui(MPI dividend, ulong divisor );


int mpi_gcd( MPI g, MPI a, MPI b );


void mpi_pow( MPI w, MPI u, MPI v);
void mpi_powm( MPI res, MPI base, MPI exponent, MPI mod);


void mpi_mulpowm( MPI res, MPI *basearray, MPI *exparray, MPI mod);


int mpi_cmp_ui( MPI u, ulong v );
int mpi_cmp( MPI u, MPI v );


int mpi_getbyte( MPI a, unsigned idx );
void mpi_putbyte( MPI a, unsigned idx, int value );
unsigned mpi_trailing_zeros( MPI a );


void mpi_normalize( MPI a );
unsigned mpi_get_nbits( MPI a );
int mpi_test_bit( MPI a, unsigned n );
void mpi_set_bit( MPI a, unsigned n );
void mpi_set_highbit( MPI a, unsigned n );
void mpi_clear_highbit( MPI a, unsigned n );
void mpi_clear_bit( MPI a, unsigned n );
void mpi_rshift( MPI x, MPI a, unsigned n );


void mpi_invm( MPI x, MPI u, MPI v );
# 25 "./main.h" 2
# 1 "../include/cipher.h" 1
# 26 "../include/cipher.h"
# 1 "../include/../cipher/random.h" 1
# 25 "../include/../cipher/random.h"
void random_dump_stats(void);
void secure_randoxmalloc(void);
void set_random_seed_file(const char *);
void update_random_seed_file(void);
int quick_random_gen( int onoff );
int random_is_faked(void);
void random_disable_locking (void);
void randomize_buffer( byte *buffer, size_t length, int level );
void randomize_mpi (MPI mpi, size_t nbits, int level);
byte *get_random_bits( size_t nbits, int level, int secure );
void fast_random_poll( void );
# 27 "../include/cipher.h" 2
# 82 "../include/cipher.h"
typedef struct
{
  int algo;
  int keylen;
  int algo_info_printed;
  int use_mdc;
  int symmetric;
  byte key[32];
} DEK;

struct cipher_handle_s;
typedef struct cipher_handle_s *CIPHER_HANDLE;
# 103 "../include/cipher.h"
struct md_digest_list_s;

struct gcry_md_context {
    int secure;
    FILE *debug;
    int finalized;
    struct md_digest_list_s *list;
    int bufcount;
    int bufsize;
    byte buffer[1];
};

typedef struct gcry_md_context *MD_HANDLE;
# 126 "../include/cipher.h"
int g10c_debug_mode;
int g10_opt_verbose;
const char *g10_opt_homedir;



void register_cipher_extension( const char *mainpgm, const char *fname );


int string_to_digest_algo( const char *string );
const char * digest_algo_to_string( int algo );
int check_digest_algo( int algo );
MD_HANDLE md_open( int algo, int secure );
void md_enable( MD_HANDLE hd, int algo );
MD_HANDLE md_copy( MD_HANDLE a );
void md_reset( MD_HANDLE a );
void md_close(MD_HANDLE a);
void md_write( MD_HANDLE a, const byte *inbuf, size_t inlen);
void md_final(MD_HANDLE a);
byte *md_read( MD_HANDLE a, int algo );
int md_digest( MD_HANDLE a, int algo, byte *buffer, int buflen );
int md_get_algo( MD_HANDLE a );
int md_algo_present( MD_HANDLE a, int algo );
int md_digest_length( int algo );
const byte *md_asn_oid( int algo, size_t *asnlen, size_t *mdlen );
void md_start_debug( MD_HANDLE a, const char *suffix );
void md_stop_debug( MD_HANDLE a );
# 161 "../include/cipher.h"
void rmd160_hash_buffer (char *outbuf, const char *buffer, size_t length);
void sha1_hash_buffer (char *outbuf, const char *buffer, size_t length);



int string_to_cipher_algo( const char *string );
const char * cipher_algo_to_string( int algo );
void disable_cipher_algo( int algo );
int check_cipher_algo( int algo );
unsigned cipher_get_keylen( int algo );
unsigned cipher_get_blocksize( int algo );
CIPHER_HANDLE cipher_open( int algo, int mode, int secure );
void cipher_close( CIPHER_HANDLE c );
int cipher_setkey( CIPHER_HANDLE c, byte *key, unsigned keylen );
void cipher_setiv( CIPHER_HANDLE c, const byte *iv, unsigned ivlen );
void cipher_encrypt( CIPHER_HANDLE c, byte *out, byte *in, unsigned nbytes );
void cipher_decrypt( CIPHER_HANDLE c, byte *out, byte *in, unsigned nbytes );
void cipher_sync( CIPHER_HANDLE c );







int string_to_pubkey_algo( const char *string );
const char * pubkey_algo_to_string( int algo );
void disable_pubkey_algo( int algo );
int check_pubkey_algo( int algo );
int check_pubkey_algo2( int algo, unsigned use );
int pubkey_get_npkey( int algo );
int pubkey_get_nskey( int algo );
int pubkey_get_nsig( int algo );
int pubkey_get_nenc( int algo );
unsigned pubkey_nbits( int algo, MPI *pkey );
int pubkey_generate( int algo, unsigned nbits, MPI *skey, MPI **retfactors );
int dsa2_generate( int algo, unsigned nbits, unsigned qbits,
     MPI *skey, MPI **retfactors );
int pubkey_check_secret_key( int algo, MPI *skey );
int pubkey_encrypt( int algo, MPI *resarr, MPI data, MPI *pkey );
int pubkey_decrypt( int algo, MPI *result, MPI *data, MPI *skey );
int pubkey_sign( int algo, MPI *resarr, MPI hash, MPI *skey );
int pubkey_verify( int algo, MPI hash, MPI *data, MPI *pkey );


extern ushort small_prime_numbers[];


void register_primegen_progress ( void (*cb)( void *, int), void *cb_data );
MPI generate_secret_prime( unsigned nbits );
MPI generate_public_prime( unsigned nbits );
MPI generate_elg_prime( int mode, unsigned pbits, unsigned qbits,
        MPI g, MPI **factors );


void register_pk_dsa_progress ( void (*cb)( void *, int), void *cb_data );
void register_pk_elg_progress ( void (*cb)( void *, int), void *cb_data );
# 26 "./main.h" 2
# 1 "./keydb.h" 1
# 25 "./keydb.h"
# 1 "./global.h" 1
# 25 "./global.h"
typedef struct kbnode_struct *KBNODE;
typedef struct kbnode_struct *kbnode_t;
typedef struct keydb_search_desc KEYDB_SEARCH_DESC;
# 26 "./keydb.h" 2
# 1 "./packet.h" 1
# 28 "./packet.h"
# 1 "./filter.h" 1
# 26 "./filter.h"
typedef struct {
    MD_HANDLE md;
    MD_HANDLE md2;
    size_t maxbuf_size;
} md_filter_context_t;

typedef struct {
    int refcount;



    int what;
    int only_keyblocks;
    const char *hdrlines;


    int no_openpgp_data;
    int key_failed_code;



    int inp_checked;
    int inp_bypass;
    int in_cleartext;
    int not_dash_escaped;
    int hashes;
    int faked;
    int truncated;
    int qp_detected;
    int pgp2mode;
    byte eol[3];




    byte *buffer;
    unsigned buffer_size;
    unsigned buffer_len;
    unsigned buffer_pos;

    byte radbuf[4];
    int idx, idx2;
    u32 crc;

    int status;
    int cancel;
    int any_data;
    int pending_lf;
} armor_filter_context_t;

struct unarmor_pump_s;
typedef struct unarmor_pump_s *UnarmorPump;


struct compress_filter_context_s {
    int status;
    void *opaque;
    byte *inbuf;
    unsigned inbufsize;
    byte *outbuf;
    unsigned outbufsize;
    int algo;
    int algo1hack;
    int new_ctb;
    void (*release)(struct compress_filter_context_s*);
};
typedef struct compress_filter_context_s compress_filter_context_t;


typedef struct {
    DEK *dek;
    u32 datalen;
    CIPHER_HANDLE cipher_hd;
    int header;
    MD_HANDLE mdc_hash;
    byte enchash[20];
    int create_mdc;
} cipher_filter_context_t;



typedef struct {
    byte *buffer;
    unsigned buffer_size;
    unsigned buffer_len;
    unsigned buffer_pos;
    int truncated;
    int not_dash_escaped;
    int escape_from;
    MD_HANDLE md;
    int pending_lf;
    int pending_esc;
} text_filter_context_t;


typedef struct {
    char *what;
    u32 last_time;
    unsigned long last;
    unsigned long offset;
    unsigned long total;
} progress_filter_context_t;




int md_filter( void *opaque, int control, IOBUF a, byte *buf, size_t *ret_len);
void free_md_filter_context( md_filter_context_t *mfx );


armor_filter_context_t *new_armor_context (void);
void release_armor_context (armor_filter_context_t *afx);
int push_armor_filter (armor_filter_context_t *afx, IOBUF iobuf);
int use_armor_filter( IOBUF a );
int armor_filter( void *opaque, int control,
    IOBUF chain, byte *buf, size_t *ret_len);
UnarmorPump unarmor_pump_new (void);
void unarmor_pump_release (UnarmorPump x);
int unarmor_pump (UnarmorPump x, int c);


void push_compress_filter(IOBUF out,compress_filter_context_t *zfx,int algo);
void push_compress_filter2(IOBUF out,compress_filter_context_t *zfx,
      int algo,int rel);


int cipher_filter( void *opaque, int control,
     IOBUF chain, byte *buf, size_t *ret_len);


int text_filter( void *opaque, int control,
   IOBUF chain, byte *buf, size_t *ret_len);
int copy_clearsig_text( IOBUF out, IOBUF inp, MD_HANDLE md,
     int escape_dash, int escape_from, int pgp2mode );


int progress_filter (void *opaque, int control,
       IOBUF a, byte *buf, size_t *ret_len);
void handle_progress (progress_filter_context_t *pfx,
        IOBUF inp, const char *name);
# 29 "./packet.h" 2




typedef enum {
 PKT_NONE =0,
 PKT_PUBKEY_ENC =1,
 PKT_SIGNATURE =2,
 PKT_SYMKEY_ENC =3,
 PKT_ONEPASS_SIG =4,
 PKT_SECRET_KEY =5,
 PKT_PUBLIC_KEY =6,
 PKT_SECRET_SUBKEY =7,
 PKT_COMPRESSED =8,
 PKT_ENCRYPTED =9,
 PKT_MARKER =10,
 PKT_PLAINTEXT =11,
 PKT_RING_TRUST =12,
 PKT_USER_ID =13,
 PKT_PUBLIC_SUBKEY =14,
 PKT_OLD_COMMENT =16,
 PKT_ATTRIBUTE =17,
 PKT_ENCRYPTED_MDC =18,
 PKT_MDC =19,
 PKT_COMMENT =61,
        PKT_GPG_CONTROL =63
} pkttype_t;

typedef struct packet_struct PACKET;


typedef enum {
    CTRLPKT_CLEARSIGN_START = 1,
    CTRLPKT_PIPEMODE = 2,
    CTRLPKT_PLAINTEXT_MARK =3
} ctrlpkttype_t;

typedef enum {
    PREFTYPE_NONE = 0,
    PREFTYPE_SYM = 1,
    PREFTYPE_HASH = 2,
    PREFTYPE_ZIP = 3
} preftype_t;

typedef struct {
    byte type;
    byte value;
} prefitem_t;

typedef struct {
    int mode;
    byte hash_algo;
    byte salt[8];
    u32 count;
} STRING2KEY;

typedef struct {
    byte version;
    byte cipher_algo;
    STRING2KEY s2k;
    byte seskeylen;
    byte seskey[1];
} PKT_symkey_enc;

typedef struct {
    u32 keyid[2];
    byte version;
    byte pubkey_algo;
    byte throw_keyid;
    MPI data[2];
} PKT_pubkey_enc;


typedef struct {
    u32 keyid[2];
    byte sig_class;
    byte digest_algo;
    byte pubkey_algo;
    byte last;
} PKT_onepass_sig;


typedef struct {
    size_t size;
    size_t len;
    byte data[1];
} subpktarea_t;

struct revocation_key {
  byte class;
  byte algid;
  byte fpr[20];
};



typedef struct
{
  int valid;
  int checked;

  char *uri;

  unsigned char fpr[20];
  char email[1];
} pka_info_t;



typedef struct
{
  struct
  {
    unsigned checked:1;
    unsigned valid:1;
    unsigned chosen_selfsig:1;
    unsigned unknown_critical:1;
    unsigned exportable:1;
    unsigned revocable:1;
    unsigned policy_url:1;
    unsigned notation:1;
    unsigned pref_ks:1;
    unsigned expired:1;
    unsigned pka_tried:1;
  } flags;
  u32 keyid[2];
  u32 timestamp;
  u32 expiredate;
  byte version;
  byte sig_class;
  byte pubkey_algo;

  byte digest_algo;
  byte trust_depth;
  byte trust_value;
  const byte *trust_regexp;
  struct revocation_key **revkey;
  int numrevkeys;
  pka_info_t *pka_info;

  subpktarea_t *hashed;
  subpktarea_t *unhashed;
  byte digest_start[2];
  MPI data[2];
} PKT_signature;




struct user_attribute {
  byte type;
  const byte *data;
  u32 len;
};

typedef struct
{
  int ref;
  int len;
  struct user_attribute *attribs;
  int numattribs;
  byte *attrib_data;
  unsigned long attrib_len;
  byte *namehash;
  int help_key_usage;
  u32 help_key_expire;
  int help_full_count;
  int help_marginal_count;
  int is_primary;
  int is_revoked;
  int is_expired;
  u32 expiredate;
  prefitem_t *prefs;
  u32 created;
  byte selfsigversion;
  struct
  {

    unsigned mdc:1;
    unsigned ks_modify:1;
    unsigned compacted:1;
  } flags;
  char name[1];
} PKT_user_id;

struct revoke_info
{

  u32 date;

  u32 keyid[2];

  byte algo;
};







typedef struct {
    u32 timestamp;
    u32 expiredate;
    u32 max_expiredate;
    struct revoke_info revoked;
    byte hdrbytes;
    byte version;
    byte selfsigversion;
    byte pubkey_algo;
    byte pubkey_usage;
    byte req_usage;
    byte req_algo;
    u32 has_expired;
    int is_revoked;

    int maybe_revoked;

    int is_valid;
    int dont_cache;
    byte backsig;
    u32 main_keyid[2];
    u32 keyid[2];
    byte is_primary;
    byte is_disabled;
    prefitem_t *prefs;
    int mdc_feature;
    PKT_user_id *user_id;
    struct revocation_key *revkey;
    int numrevkeys;
    u32 trust_timestamp;
    byte trust_depth;
    byte trust_value;
    const byte *trust_regexp;
    MPI pkey[4];
} PKT_public_key;





typedef struct {
    u32 timestamp;
    u32 expiredate;
    u32 max_expiredate;
    byte hdrbytes;
    byte version;
    byte pubkey_algo;
    byte pubkey_usage;
    byte req_usage;
    byte req_algo;
    u32 has_expired;
    int is_revoked;
    int is_valid;
    u32 main_keyid[2];
    u32 keyid[2];
    byte is_primary;
    byte is_protected;



    struct {
 byte algo;
        byte sha1chk;
 STRING2KEY s2k;
 byte ivlen;
 byte iv[16];
    } protect;
    MPI skey[6];
    u16 csum;
} PKT_secret_key;


typedef struct {
    int len;
    char data[1];
} PKT_comment;

typedef struct {
    u32 len;
    byte new_ctb;
    byte algorithm;
    IOBUF buf;
} PKT_compressed;

typedef struct {
    u32 len;
    int extralen;
    byte new_ctb;
    byte is_partial;
    byte mdc_method;
    IOBUF buf;
} PKT_encrypted;

typedef struct {
    byte hash[20];
} PKT_mdc;

typedef struct {
    unsigned int trustval;
    unsigned int sigcache;
} PKT_ring_trust;

typedef struct {
    u32 len;
    IOBUF buf;
    byte new_ctb;
    byte is_partial;
    int mode;
    u32 timestamp;
    int namelen;
    char name[1];
} PKT_plaintext;

typedef struct {
    int control;
    size_t datalen;
    char data[1];
} PKT_gpg_control;


struct packet_struct {
    pkttype_t pkttype;
    union {
 void *generic;
 PKT_symkey_enc *symkey_enc;
 PKT_pubkey_enc *pubkey_enc;
 PKT_onepass_sig *onepass_sig;
 PKT_signature *signature;
 PKT_public_key *public_key;
 PKT_secret_key *secret_key;
 PKT_comment *comment;
 PKT_user_id *user_id;
 PKT_compressed *compressed;
 PKT_encrypted *encrypted;
 PKT_mdc *mdc;
 PKT_ring_trust *ring_trust;
 PKT_plaintext *plaintext;
        PKT_gpg_control *gpg_control;
    } pkt;
};





typedef enum {
    SIGSUBPKT_TEST_CRITICAL=-3,
    SIGSUBPKT_LIST_UNHASHED=-2,
    SIGSUBPKT_LIST_HASHED =-1,
    SIGSUBPKT_NONE = 0,
    SIGSUBPKT_SIG_CREATED = 2,
    SIGSUBPKT_SIG_EXPIRE = 3,
    SIGSUBPKT_EXPORTABLE = 4,
    SIGSUBPKT_TRUST = 5,
    SIGSUBPKT_REGEXP = 6,
    SIGSUBPKT_REVOCABLE = 7,
    SIGSUBPKT_KEY_EXPIRE = 9,
    SIGSUBPKT_ARR =10,
    SIGSUBPKT_PREF_SYM =11,
    SIGSUBPKT_REV_KEY =12,
    SIGSUBPKT_ISSUER =16,
    SIGSUBPKT_NOTATION =20,
    SIGSUBPKT_PREF_HASH =21,
    SIGSUBPKT_PREF_COMPR =22,
    SIGSUBPKT_KS_FLAGS =23,
    SIGSUBPKT_PREF_KS =24,
    SIGSUBPKT_PRIMARY_UID =25,
    SIGSUBPKT_POLICY =26,
    SIGSUBPKT_KEY_FLAGS =27,
    SIGSUBPKT_SIGNERS_UID =28,
    SIGSUBPKT_REVOC_REASON =29,
    SIGSUBPKT_FEATURES =30,

    SIGSUBPKT_SIGNATURE =32,

    SIGSUBPKT_FLAG_CRITICAL=128
} sigsubpkttype_t;

struct notation
{
  char *name;
  char *value;
  char *altvalue;
  unsigned char *bdat;
  size_t blen;
  struct
  {
    unsigned int critical:1;
    unsigned int ignore:1;
  } flags;
  struct notation *next;
};


void reset_literals_seen(void);
int proc_packets( void *ctx, IOBUF a );
int proc_signature_packets( void *ctx, IOBUF a,
       STRLIST signedfiles, const char *sigfile );
int proc_encryption_packets( void *ctx, IOBUF a );
int list_packets( IOBUF a );


int set_packet_list_mode( int mode );


int dbg_search_packet( IOBUF inp, PACKET *pkt, off_t *retpos, int with_uid,
                       const char* file, int lineno );
int dbg_parse_packet( IOBUF inp, PACKET *ret_pkt,
                      const char* file, int lineno );
int dbg_copy_all_packets( IOBUF inp, IOBUF out,
                          const char* file, int lineno );
int dbg_copy_some_packets( IOBUF inp, IOBUF out, off_t stopoff,
                           const char* file, int lineno );
int dbg_skip_some_packets( IOBUF inp, unsigned n,
                           const char* file, int lineno );
# 463 "./packet.h"
int parse_signature( IOBUF inp, int pkttype, unsigned long pktlen,
       PKT_signature *sig );
const byte *enum_sig_subpkt ( const subpktarea_t *subpkts,
                              sigsubpkttype_t reqtype,
                              size_t *ret_n, int *start, int *critical );
const byte *parse_sig_subpkt ( const subpktarea_t *buffer,
                               sigsubpkttype_t reqtype,
                               size_t *ret_n );
const byte *parse_sig_subpkt2 ( PKT_signature *sig,
                                sigsubpkttype_t reqtype,
                                size_t *ret_n );
int parse_one_sig_subpkt( const byte *buffer, size_t n, int type );
void parse_revkeys(PKT_signature *sig);
int parse_attribute_subpkts(PKT_user_id *uid);
void make_attribute_uidname(PKT_user_id *uid, size_t max_namelen);
PACKET *create_gpg_control ( ctrlpkttype_t type,
                             const byte *data,
                             size_t datalen );


int build_packet( IOBUF inp, PACKET *pkt );
u32 calc_packet_length( PACKET *pkt );
void build_sig_subpkt( PKT_signature *sig, sigsubpkttype_t type,
   const byte *buffer, size_t buflen );
void build_sig_subpkt_from_sig( PKT_signature *sig );
int delete_sig_subpkt(subpktarea_t *buffer, sigsubpkttype_t type );
void build_attribute_subpkt(PKT_user_id *uid,byte type,
       const void *buf,u32 buflen,
       const void *header,u32 headerlen);
struct notation *string_to_notation(const char *string,int is_utf8);
struct notation *sig_to_notation(PKT_signature *sig);
void free_notation(struct notation *notation);


void free_symkey_enc( PKT_symkey_enc *enc );
void free_pubkey_enc( PKT_pubkey_enc *enc );
void free_seckey_enc( PKT_signature *enc );
int digest_algo_from_sig( PKT_signature *sig );
void release_public_key_parts( PKT_public_key *pk );
void free_public_key( PKT_public_key *key );
void release_secret_key_parts( PKT_secret_key *sk );
void free_secret_key( PKT_secret_key *sk );
void free_attributes(PKT_user_id *uid);
void free_user_id( PKT_user_id *uid );
void free_comment( PKT_comment *rem );
void free_packet( PACKET *pkt );
prefitem_t *copy_prefs (const prefitem_t *prefs);
PKT_public_key *copy_public_key( PKT_public_key *d, PKT_public_key *s );
void copy_public_parts_to_secret_key( PKT_public_key *pk, PKT_secret_key *sk );
PKT_secret_key *copy_secret_key( PKT_secret_key *d, PKT_secret_key *s );
PKT_signature *copy_signature( PKT_signature *d, PKT_signature *s );
PKT_user_id *scopy_user_id (PKT_user_id *sd );
int cmp_public_keys( PKT_public_key *a, PKT_public_key *b );
int cmp_secret_keys( PKT_secret_key *a, PKT_secret_key *b );
int cmp_signatures( PKT_signature *a, PKT_signature *b );
int cmp_public_secret_key( PKT_public_key *pk, PKT_secret_key *sk );
int cmp_user_ids( PKT_user_id *a, PKT_user_id *b );



int signature_check( PKT_signature *sig, MD_HANDLE digest );
int signature_check2( PKT_signature *sig, MD_HANDLE digest, u32 *r_expiredate,
        int *r_expired, int *r_revoked, PKT_public_key *ret_pk );


int is_secret_key_protected( PKT_secret_key *sk );
int check_secret_key( PKT_secret_key *sk, int retries );
int protect_secret_key( PKT_secret_key *sk, DEK *dek );


int get_session_key( PKT_pubkey_enc *k, DEK *dek );
int get_override_session_key( DEK *dek, const char *string );


int handle_compressed( void *ctx, PKT_compressed *cd,
         int (*callback)(IOBUF, void *), void *passthru );


int decrypt_data( void *ctx, PKT_encrypted *ed, DEK *dek );


int handle_plaintext( PKT_plaintext *pt, md_filter_context_t *mfx,
     int nooutput, int clearsig );
int ask_for_detached_datafile( MD_HANDLE md, MD_HANDLE md2,
          const char *inname, int textmode );


int make_keysig_packet( PKT_signature **ret_sig, PKT_public_key *pk,
   PKT_user_id *uid, PKT_public_key *subpk,
   PKT_secret_key *sk, int sigclass, int digest_algo,
   int sigversion, u32 timestamp, u32 duration,
   int (*mksubpkt)(PKT_signature *, void *),
   void *opaque );
int update_keysig_packet( PKT_signature **ret_sig,
                      PKT_signature *orig_sig,
                      PKT_public_key *pk,
                      PKT_user_id *uid,
                      PKT_public_key *subpk,
                      PKT_secret_key *sk,
                      int (*mksubpkt)(PKT_signature *, void *),
                      void *opaque );


PKT_user_id *generate_user_id(void);
# 27 "./keydb.h" 2
# 43 "./keydb.h"
struct getkey_ctx_s;
typedef struct getkey_ctx_s *GETKEY_CTX;
# 54 "./keydb.h"
struct kbnode_struct {
    KBNODE next;
    PACKET *pkt;
    int flag;
    int private_flag;
    ulong recno;
};





enum resource_type {
    rt_UNKNOWN = 0,
    rt_RING = 1
};






struct keyblock_pos_struct {
    int resno;
    enum resource_type rt;
    off_t offset;
    unsigned count;
    IOBUF fp;
    int secret;
    PACKET *pkt;
    int valid;
};
typedef struct keyblock_pos_struct KBPOS;


typedef struct pk_list *PK_LIST;
struct pk_list {
    PK_LIST next;
    PKT_public_key *pk;
    int flags;
};


typedef struct sk_list *SK_LIST;
struct sk_list {
    SK_LIST next;
    PKT_secret_key *sk;
    int mark;
};



typedef struct pubkey_find_info *PUBKEY_FIND_INFO;
struct pubkey_find_info {
    u32 keyid[2];
    unsigned nbits;
    byte pubkey_algo;
    byte fingerprint[20];
    char userid[1];
};


typedef struct keydb_handle *KEYDB_HANDLE;

typedef enum {
    KEYDB_SEARCH_MODE_NONE,
    KEYDB_SEARCH_MODE_EXACT,
    KEYDB_SEARCH_MODE_SUBSTR,
    KEYDB_SEARCH_MODE_MAIL,
    KEYDB_SEARCH_MODE_MAILSUB,
    KEYDB_SEARCH_MODE_MAILEND,
    KEYDB_SEARCH_MODE_WORDS,
    KEYDB_SEARCH_MODE_SHORT_KID,
    KEYDB_SEARCH_MODE_LONG_KID,
    KEYDB_SEARCH_MODE_FPR16,
    KEYDB_SEARCH_MODE_FPR20,
    KEYDB_SEARCH_MODE_FPR,
    KEYDB_SEARCH_MODE_FIRST,
    KEYDB_SEARCH_MODE_NEXT
} KeydbSearchMode;

struct keydb_search_desc {
    KeydbSearchMode mode;
    int (*skipfnc)(void *,u32*,PKT_user_id*);
    void *skipfncvalue;
    union {
        const char *name;
        byte fpr[20];
        u32 kid[2];
    } u;
    int exact;
};







int keydb_add_resource (const char *url, int flags, int secret);
KEYDB_HANDLE keydb_new (int secret);
void keydb_release (KEYDB_HANDLE hd);
const char *keydb_get_resource_name (KEYDB_HANDLE hd);
int keydb_get_keyblock (KEYDB_HANDLE hd, KBNODE *ret_kb);
int keydb_update_keyblock (KEYDB_HANDLE hd, KBNODE kb);
int keydb_insert_keyblock (KEYDB_HANDLE hd, KBNODE kb);
int keydb_delete_keyblock (KEYDB_HANDLE hd);
int keydb_locate_writable (KEYDB_HANDLE hd, const char *reserved);
void keydb_rebuild_caches (int noisy);
int keydb_search_reset (KEYDB_HANDLE hd);

int keydb_search2 (KEYDB_HANDLE hd, KEYDB_SEARCH_DESC *desc,
     size_t ndesc, size_t *descindex);
int keydb_search_first (KEYDB_HANDLE hd);
int keydb_search_next (KEYDB_HANDLE hd);
int keydb_search_kid (KEYDB_HANDLE hd, u32 *kid);
int keydb_search_fpr (KEYDB_HANDLE hd, const byte *fpr);



void show_revocation_reason( PKT_public_key *pk, int mode );
int check_signatures_trust( PKT_signature *sig );
void release_pk_list( PK_LIST pk_list );
int build_pk_list( STRLIST rcpts, PK_LIST *ret_pk_list, unsigned use );
union pref_hint
{
  int digest_length;
};
int algo_available( preftype_t preftype, int algo,
       const union pref_hint *hint );
int select_algo_from_prefs( PK_LIST pk_list, int preftype,
        int request, const union pref_hint *hint );
int select_mdc_from_pklist (PK_LIST pk_list);


void release_sk_list( SK_LIST sk_list );
int build_sk_list( STRLIST locusr, SK_LIST *ret_sk_list,
         int unlock, unsigned use );
# 200 "./keydb.h"
typedef int assuan_error_t;
typedef void *assuan_context_t;

int have_static_passphrase(void);
void set_passphrase_from_string(const char *pass);
void read_passphrase_from_fd( int fd );
void passphrase_clear_cache ( u32 *keyid, const char *cacheid, int algo );
char *ask_passphrase (const char *description,
                      const char *tryagain_text,
                      const char *promptid,
                      const char *prompt,
                      const char *cacheid, int *canceled);
DEK *passphrase_to_dek( u32 *keyid, int pubkey_algo,
   int cipher_algo, STRING2KEY *s2k, int mode,
                        const char *tryagain_text, int *canceled);
void set_next_passphrase( const char *s );
char *get_last_passphrase(void);
void next_to_last_passphrase(void);


int classify_user_id( const char *name, KEYDB_SEARCH_DESC *desc);
void cache_public_key( PKT_public_key *pk );
void getkey_disable_caches(void);
int get_pubkey( PKT_public_key *pk, u32 *keyid );
int get_pubkey_fast ( PKT_public_key *pk, u32 *keyid );
KBNODE get_pubkeyblock( u32 *keyid );
int get_pubkey_byname( PKT_public_key *pk, const char *name,
                       KBNODE *ret_keyblock, KEYDB_HANDLE *ret_kdbhd,
         int include_unusable );
int get_pubkey_bynames( GETKEY_CTX *rx, PKT_public_key *pk,
   STRLIST names, KBNODE *ret_keyblock );
int get_pubkey_next( GETKEY_CTX ctx, PKT_public_key *pk, KBNODE *ret_keyblock );
void get_pubkey_end( GETKEY_CTX ctx );
int get_seckey( PKT_secret_key *sk, u32 *keyid );
int get_primary_seckey( PKT_secret_key *sk, u32 *keyid );
int get_pubkey_byfprint( PKT_public_key *pk, const byte *fprint,
       size_t fprint_len );
int get_pubkey_byfprint_fast (PKT_public_key *pk,
                              const byte *fprint, size_t fprint_len);
int get_keyblock_byfprint( KBNODE *ret_keyblock, const byte *fprint,
       size_t fprint_len );
int get_keyblock_bylid( KBNODE *ret_keyblock, ulong lid );
int seckey_available( u32 *keyid );
int get_seckey_byname( PKT_secret_key *sk, const char *name, int unlock );
int get_seckey_bynames( GETKEY_CTX *rx, PKT_secret_key *sk,
   STRLIST names, KBNODE *ret_keyblock );
int get_seckey_next (GETKEY_CTX ctx, PKT_secret_key *sk, KBNODE *ret_keyblock);
void get_seckey_end( GETKEY_CTX ctx );

int get_seckey_byfprint( PKT_secret_key *sk,
    const byte *fprint, size_t fprint_len);
int get_seckeyblock_byfprint (KBNODE *ret_keyblock, const byte *fprint,
                              size_t fprint_len );


int enum_secret_keys( void **context, PKT_secret_key *sk,
        int with_subkeys, int with_spm );
void merge_keys_and_selfsig( KBNODE keyblock );
char*get_user_id_string( u32 *keyid );
char*get_user_id_string_native( u32 *keyid );
char*get_long_user_id_string( u32 *keyid );
char*get_user_id( u32 *keyid, size_t *rn );
char*get_user_id_native( u32 *keyid );
KEYDB_HANDLE get_ctx_handle(GETKEY_CTX ctx);
void release_akl(void);
int parse_auto_key_locate(char *options);


int pubkey_letter( int algo );
void hash_public_key( MD_HANDLE md, PKT_public_key *pk );
size_t keystrlen(void);
const char *keystr(u32 *keyid);
const char *keystr_from_pk(PKT_public_key *pk);
const char *keystr_from_sk(PKT_secret_key *sk);
const char *keystr_from_desc(KEYDB_SEARCH_DESC *desc);
u32 keyid_from_sk( PKT_secret_key *sk, u32 *keyid );
u32 keyid_from_pk( PKT_public_key *pk, u32 *keyid );
u32 keyid_from_sig( PKT_signature *sig, u32 *keyid );
u32 keyid_from_fingerprint(const byte *fprint, size_t fprint_len, u32 *keyid);
byte *namehash_from_uid(PKT_user_id *uid);
unsigned nbits_from_pk( PKT_public_key *pk );
unsigned nbits_from_sk( PKT_secret_key *sk );
const char *datestr_from_pk( PKT_public_key *pk );
const char *datestr_from_sk( PKT_secret_key *sk );
const char *datestr_from_sig( PKT_signature *sig );
const char *expirestr_from_pk( PKT_public_key *pk );
const char *expirestr_from_sk( PKT_secret_key *sk );
const char *expirestr_from_sig( PKT_signature *sig );
const char *revokestr_from_pk( PKT_public_key *pk );
const char *usagestr_from_pk( PKT_public_key *pk );
const char *colon_strtime (u32 t);
const char *colon_datestr_from_pk (PKT_public_key *pk);
const char *colon_datestr_from_sk (PKT_secret_key *sk);
const char *colon_datestr_from_sig (PKT_signature *sig);
const char *colon_expirestr_from_sig (PKT_signature *sig);
byte *fingerprint_from_sk( PKT_secret_key *sk, byte *buf, size_t *ret_len );
byte *fingerprint_from_pk( PKT_public_key *pk, byte *buf, size_t *ret_len );


KBNODE new_kbnode( PACKET *pkt );
KBNODE clone_kbnode( KBNODE node );
void release_kbnode( KBNODE n );
void delete_kbnode( KBNODE node );
void add_kbnode( KBNODE root, KBNODE node );
void insert_kbnode( KBNODE root, KBNODE node, int pkttype );
void move_kbnode( KBNODE *root, KBNODE node, KBNODE where );
void remove_kbnode( KBNODE *root, KBNODE node );
KBNODE find_prev_kbnode( KBNODE root, KBNODE node, int pkttype );
KBNODE find_next_kbnode( KBNODE node, int pkttype );
KBNODE find_kbnode( KBNODE node, int pkttype );
KBNODE walk_kbnode( KBNODE root, KBNODE *context, int all );
void clear_kbnode_flags( KBNODE n );
int commit_kbnode( KBNODE *root );
void dump_kbnode( KBNODE node );
# 27 "./main.h" 2
# 47 "./main.h"
typedef struct
{
  int header_okay;
  PK_LIST pk_list;
  DEK *symkey_dek;
  STRING2KEY *symkey_s2k;
  cipher_filter_context_t cfx;
} encrypt_filter_context_t;

struct groupitem
{
  char *name;
  STRLIST values;
  struct groupitem *next;
};

struct weakhash
{
  int algo;
  int rejection_shown;
  struct weakhash *next;
};



extern int g10_errors_seen;


  void g10_exit(int rc) __attribute__ ((noreturn));



void print_pubkey_algo_note( int algo );
void print_cipher_algo_note( int algo );
void print_digest_algo_note( int algo );
void additional_weak_digest (const char* digestname);


char *make_radix64_string( const byte *data, size_t len );
int parse_key_failed_line (const void *lineptr, unsigned int len);


void trap_unaligned(void);
int disable_core_dumps(void);
void register_secured_file (const char *fname);
void unregister_secured_file (const char *fname);
int is_secured_file (int fd);
int is_secured_filename (const char *fname);
u16 checksum_u16( unsigned n );
u16 checksum( byte *p, unsigned n );
u16 checksum_mpi( MPI a );
u32 buffer_to_u32( const byte *buffer );
const byte *get_session_marker( size_t *rlen );
int openpgp_cipher_test_algo( int algo );
int openpgp_pk_test_algo( int algo, unsigned int usage_flags );
int openpgp_pk_algo_usage ( int algo );
int openpgp_md_test_algo( int algo );

void md5_digest_warn (int show);

void not_in_gpg1_notice (void);

struct expando_args
{
  PKT_public_key *pk;
  PKT_secret_key *sk;
  byte imagetype;
  int validity_info;
  const char *validity_string;
};

char *pct_expando(const char *string,struct expando_args *args);
void deprecated_warning(const char *configname,unsigned int configlineno,
   const char *option,const char *repl1,const char *repl2);
void deprecated_command (const char *name);

const char *compress_algo_to_string(int algo);
int string_to_compress_algo(const char *string);
int check_compress_algo(int algo);
int default_cipher_algo(void);
int default_compress_algo(void);
const char *compliance_option_string(void);
void compliance_failure(void);

struct parse_options
{
  char *name;
  unsigned int bit;
  char **value;
  char *help;
};

char *optsep(char **stringp);
char *argsplit(char *string);
int parse_options(char *str,unsigned int *options,
    struct parse_options *opts,int noisy);
char *unescape_percent_string (const unsigned char *s);
char *default_homedir (void);
const char *get_libexecdir (void);
int path_access(const char *file,int mode);


void display_online_help( const char *keyword );


int setup_symkey(STRING2KEY **symkey_s2k,DEK **symkey_dek);
int encode_symmetric( const char *filename );
int encode_store( const char *filename );
int encode_crypt( const char *filename, STRLIST remusr, int use_symkey );
void encode_crypt_files(int nfiles, char **files, STRLIST remusr);
int encrypt_filter( void *opaque, int control,
      IOBUF a, byte *buf, size_t *ret_len);



int complete_sig( PKT_signature *sig, PKT_secret_key *sk, MD_HANDLE md );
int sign_file( STRLIST filenames, int detached, STRLIST locusr,
        int do_encrypt, STRLIST remusr, const char *outfile );
int clearsign_file( const char *fname, STRLIST locusr, const char *outfile );
int sign_symencrypt_file (const char *fname, STRLIST locusr);


int check_revocation_keys (PKT_public_key *pk, PKT_signature *sig);
int check_backsig(PKT_public_key *main_pk,PKT_public_key *sub_pk,
    PKT_signature *backsig);
int check_key_signature( KBNODE root, KBNODE node, int *is_selfsig );
int check_key_signature2( KBNODE root, KBNODE node, PKT_public_key *check_pk,
     PKT_public_key *ret_pk, int *is_selfsig,
     u32 *r_expiredate, int *r_expired );


int delete_keys( STRLIST names, int secret, int allow_both );


void keyedit_menu( const char *username, STRLIST locusr,
     STRLIST commands, int quiet, int seckey_check );
void show_basic_key_info (KBNODE keyblock);


u32 parse_expire_string(u32 timestamp,const char *string);
u32 ask_expire_interval(u32 timestamp,int object,const char *def_expire);
void generate_keypair( const char *fname, const char *card_serialno,
                       const char *backup_encryption_dir );
int keygen_set_std_prefs (const char *string,int personal);
PKT_user_id *keygen_get_std_prefs (void);
int keygen_add_key_expire( PKT_signature *sig, void *opaque );
int keygen_add_std_prefs( PKT_signature *sig, void *opaque );
int keygen_upd_std_prefs( PKT_signature *sig, void *opaque );
int keygen_add_keyserver_url(PKT_signature *sig, void *opaque);
int keygen_add_notations(PKT_signature *sig,void *opaque);
int keygen_add_revkey(PKT_signature *sig, void *opaque);
int make_backsig(PKT_signature *sig,PKT_public_key *pk,
   PKT_public_key *sub_pk,PKT_secret_key *sub_sk,
                 u32 timestamp);
int generate_subkeypair( KBNODE pub_keyblock, KBNODE sec_keyblock );

int generate_card_subkeypair (KBNODE pub_keyblock, KBNODE sec_keyblock,
                              int keyno, const char *serialno);
int save_unprotected_key_to_card (PKT_secret_key *sk, int keyno);



int overwrite_filep( const char *fname );
char *make_outfile_name( const char *iname );
char *ask_outfile_name( const char *name, size_t namelen );
int open_outfile( const char *iname, int mode, IOBUF *a );
char *get_matching_datafile (const char *sigfilename);
IOBUF open_sigfile( const char *iname, progress_filter_context_t *pfx );
void try_make_homedir( const char *fname );


void make_session_key( DEK *dek );
MPI encode_session_key( DEK *dek, unsigned nbits );
MPI pkcs1_encode_md( MD_HANDLE md, int algo, size_t len, unsigned nbits,
       const byte *asn, size_t asnlen );
MPI encode_md_value( PKT_public_key *pk, PKT_secret_key *sk,
       MD_HANDLE md, int hash_algo );



typedef int (*import_filter_t)(kbnode_t keyblock, void *arg);

int parse_import_options(char *str,unsigned int *options,int noisy);
void import_keys( char **fnames, int nnames,
    void *stats_hd, unsigned int options );
int import_keys_stream (IOBUF inp,void *stats_hd,unsigned char **fpr,
                        size_t *fpr_len,unsigned int options,
                        import_filter_t filter, void *filter_arg,
                        int *r_gpgkeys_err);
void *import_new_stats_handle (void);
void import_release_stats_handle (void *p);
void import_print_stats (void *hd);

int collapse_uids( KBNODE *keyblock );

int auto_create_card_key_stub ( const char *serialnostr,
                                const unsigned char *fpr1,
                                const unsigned char *fpr2,
                                const unsigned char *fpr3);


int parse_export_options(char *str,unsigned int *options,int noisy);
int export_pubkeys( STRLIST users, unsigned int options );
int export_pubkeys_stream( IOBUF out, STRLIST users,
      KBNODE *keyblock_out, unsigned int options );
int export_seckeys( STRLIST users );
int export_secsubkeys( STRLIST users );


int dearmor_file( const char *fname );
int enarmor_file( const char *fname );


struct revocation_reason_info;
int gen_revoke( const char *uname );
int gen_desig_revoke( const char *uname, STRLIST locusr);
int revocation_reason_build_cb( PKT_signature *sig, void *opaque );
struct revocation_reason_info *
  ask_revocation_reason( int key_rev, int cert_rev, int hint );
void release_revocation_reason_info( struct revocation_reason_info *reason );


void public_key_list( STRLIST list );
void secret_key_list( STRLIST list );
void print_subpackets_colon(PKT_signature *sig);
void reorder_keyblock (KBNODE keyblock);
void list_keyblock( KBNODE keyblock, int secret, int fpr, void *opaque );
void print_fingerprint (PKT_public_key *pk, PKT_secret_key *sk, int mode);
void print_revokers(PKT_public_key *pk);
void show_policy_url(PKT_signature *sig,int indent,int mode);
void show_keyserver_url(PKT_signature *sig,int indent,int mode);
void show_notation(PKT_signature *sig,int indent,int mode,int which);
void dump_attribs(const PKT_user_id *uid,
    PKT_public_key *pk,PKT_secret_key *sk);
void set_attrib_fd(int fd);
void print_seckey_info (PKT_secret_key *sk);
void print_pubkey_info (FILE *fp, PKT_public_key *pk);
void print_card_key_info (FILE *fp, KBNODE keyblock);


void print_file_status( int status, const char *name, int what );
int verify_signatures( int nfiles, char **files );
int verify_files( int nfiles, char **files );


int decrypt_message( const char *filename );
void decrypt_messages(int nfiles, char *files[]);


int hash_datafiles( MD_HANDLE md, MD_HANDLE md2,
      STRLIST files, const char *sigfilename, int textmode );
PKT_plaintext *setup_plaintext_name(const char *filename,IOBUF iobuf);


void run_in_pipemode (void);


void init_signals(void);
void pause_on_sigusr( int which );
void block_all_signals(void);
void unblock_all_signals(void);




void change_pin (int no, int allow_admin);
void card_status (FILE *fp, char *serialno, size_t serialnobuflen);
void card_edit (STRLIST commands);
int card_generate_subkey (KBNODE pub_keyblock, KBNODE sec_keyblock);
int card_store_subkey (KBNODE node, int use);
# 26 "./options.h" 2
# 39 "./options.h"
struct
{
  int verbose;
  int quiet;
  unsigned debug;
  int armor;
  char *outfile;
  off_t max_output;
  int dry_run;
  int list_only;
  int textmode;
  int expert;
  const char *def_sig_expire;
  int ask_sig_expire;
  const char *def_cert_expire;
  int ask_cert_expire;
  int batch;
  int answer_yes;
  int answer_no;
  int check_sigs;
  int with_colons;
  int with_key_data;
  int with_fingerprint;
  int fingerprint;
  int list_sigs;
  int no_armor;
  int list_packets;
  int def_cipher_algo;
  int force_v3_sigs;
  int force_v4_certs;
  int force_mdc;
  int disable_mdc;
  int def_digest_algo;
  int cert_digest_algo;
  int compress_algo;
  int compress_level;
  int bz2_compress_level;
  int bz2_decompress_lowmem;
  const char *def_secret_key;
  char *def_recipient;
  int def_recipient_self;
  int def_cert_level;
  int min_cert_level;
  int ask_cert_level;
  int emit_version;




  int marginals_needed;
  int completes_needed;
  int max_cert_depth;
  const char *homedir;

  char *display;
  char *ttyname;
  char *ttytype;
  char *lc_ctype;
  char *lc_messages;

  int skip_verify;
  int compress_keys;
  int compress_sigs;


  enum
    {
      TM_CLASSIC=0, TM_PGP=1, TM_EXTERNAL=2, TM_ALWAYS, TM_DIRECT, TM_AUTO
    } trust_model;
  int force_ownertrust;
  enum
    {
      CO_GNUPG, CO_RFC4880, CO_RFC2440, CO_RFC1991, CO_PGP2,
      CO_PGP6, CO_PGP7, CO_PGP8
    } compliance;
  enum
    {
      KF_SHORT, KF_LONG, KF_0xSHORT, KF_0xLONG
    } keyid_format;
  int pgp2_workarounds;
  int shm_coprocess;
  const char *set_filename;
  STRLIST comments;
  int throw_keyid;
  const char *photo_viewer;
  int s2k_mode;
  int s2k_digest_algo;
  int s2k_cipher_algo;
  unsigned char s2k_count;

  int simple_sk_checksum;

  int not_dash_escaped;
  int escape_from;
  int lock_once;
  struct keyserver_spec
  {
    char *uri;
    char *scheme;
    char *auth;
    char *host;
    char *port;
    char *path;
    char *opaque;
    STRLIST options;
    struct
    {
      unsigned int direct_uri:1;
    } flags;
    struct keyserver_spec *next;
  } *keyserver;
  struct
  {
    unsigned int options;
    unsigned int import_options;
    unsigned int export_options;
    STRLIST other;
  } keyserver_options;
  int exec_disable;
  int exec_path_set;
  unsigned int import_options;
  unsigned int export_options;
  unsigned int list_options;
  unsigned int verify_options;
  const char *def_preference_list;
  const char *def_keyserver_url;
  prefitem_t *personal_cipher_prefs;
  prefitem_t *personal_digest_prefs;
  prefitem_t *personal_compress_prefs;
  struct weakhash *weak_digests;
  int no_perm_warn;
  int no_mdc_warn;
  char *temp_dir;
  int no_encrypt_to;
  int interactive;
  struct notation *sig_notations;
  struct notation *cert_notations;
  STRLIST sig_policy_url;
  STRLIST cert_policy_url;
  STRLIST sig_keyserver_url;
  STRLIST cert_subpackets;
  STRLIST sig_subpackets;
  int allow_non_selfsigned_uid;
  int allow_freeform_uid;
  int no_literal;
  ulong set_filesize;
  int fast_list_mode;
  int fixed_list_mode;
  int ignore_time_conflict;
  int ignore_valid_from;
  int ignore_crc_error;
  int ignore_mdc_error;
  int command_fd;
  const char *override_session_key;
  int show_session_key;
  int use_agent;
  const char *gpg_agent_info;
  int try_all_secrets;
  int no_expensive_trust_checks;
  int no_sig_cache;
  int no_auto_check_trustdb;
  int preserve_permissions;
  int no_homedir_creation;
  struct groupitem *grouplist;
  int strict;
  int mangle_dos_filenames;
  int enable_progress_filter;
  unsigned int screen_columns;
  unsigned int screen_lines;
  byte *show_subpackets;
  int rfc2440_text;


  int exit_on_status_write_error;



  int limit_card_insert_tries;


  const char *ctapi_driver;
  const char *pcsc_driver;
  int disable_ccid;
  int disable_keypad;


  struct
  {



    unsigned int require_cross_cert:1;
    unsigned int use_embedded_filename:1;
    unsigned int utf8_filename:1;
    unsigned int dsa2:1;
    unsigned int allow_multiple_messages:1;
    unsigned int allow_weak_digest_algos:1;
    unsigned int large_rsa:1;
  } flags;



  struct akl
  {
    enum {AKL_CERT, AKL_PKA, AKL_LDAP, AKL_KEYSERVER, AKL_SPEC} type;
    struct keyserver_spec *spec;
    struct akl *next;
  } *auto_key_locate;

  int passwd_repeat;
} opt;





struct {
  int in_auto_key_retrieve;

} glo_ctrl;
# 59 "app-openpgp.c" 2
# 1 "../include/errors.h" 1
# 60 "app-openpgp.c" 2

# 1 "../include/util.h" 1
# 23 "../include/util.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 1 3
# 14 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 1 3
# 47 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_header_macro.h" 1 3
# 48 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3



# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___gnuc_va_list.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___gnuc_va_list.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 52 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_list.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_list.h" 3
typedef __builtin_va_list va_list;
# 57 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_arg.h" 1 3
# 62 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___va_copy.h" 1 3
# 67 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_copy.h" 1 3
# 72 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 2 3
# 24 "../include/util.h" 2





# 1 "../include/compat.h" 1







int hextobyte( const char *s );
int ascii_toupper (int c);
int ascii_tolower (int c);
int ascii_strcasecmp( const char *a, const char *b );
int ascii_strncasecmp( const char *a, const char *b, size_t n);






char *xstrconcat (const char *s1, ...) __attribute__ ((sentinel(0)));
# 30 "../include/util.h" 2
# 39 "../include/util.h"
typedef struct {
     int *argc;
     char ***argv;
     unsigned flags;
     int err;

     int r_opt;
     int r_type;
     union {
  int ret_int;
  long ret_long;
  ulong ret_ulong;
  char *ret_str;
     } r;
     struct {
  int idx;
  int inarg;
  int stopped;
  const char *last;
  void *aliases;
  const void *cur_alias;
         void *iio_list;
     } internal;
} ARGPARSE_ARGS;

typedef struct {
    int short_opt;
    const char *long_opt;
    unsigned flags;
    const char *description;
} ARGPARSE_OPTS;


void log_set_logfile( const char *name, int fd );
FILE *log_stream(void);
void g10_log_print_prefix(const char *text);
void log_set_name( const char *name );
const char *log_get_name(void);
void log_set_pid( int pid );
int log_get_errorcount( int clear );
void log_inc_errorcount(void);
int log_set_strict(int val);
void g10_log_hexdump( const char *text, const char *buf, size_t len );



  void g10_log_bug( const char *fmt, ... )
       __attribute__ ((noreturn, format (printf,1,2)));
  void g10_log_bug0( const char *, int, const char * ) __attribute__ ((noreturn));
  void g10_log_fatal( const char *fmt, ... )
       __attribute__ ((noreturn, format (printf,1,2)));
  void g10_log_error( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_info( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_warning( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_debug( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
# 121 "../include/util.h"
const char * g10_errstr( int no );


int arg_parse( ARGPARSE_ARGS *arg, ARGPARSE_OPTS *opts);
int optfile_parse( FILE *fp, const char *filename, unsigned *lineno,
     ARGPARSE_ARGS *arg, ARGPARSE_OPTS *opts);
void usage( int level );
const char *default_strusage( int level );



const char *strusage( int level );



# 1 "../include/../include/dotlock.h" 1
# 97 "../include/../include/dotlock.h"
struct dotlock_handle;
typedef struct dotlock_handle *dotlock_t;

void dotlock_disable (void);
dotlock_t dotlock_create (const char *file_to_lock, unsigned int flags);
void dotlock_set_fd (dotlock_t h, int fd);
int dotlock_get_fd (dotlock_t h);
void dotlock_destroy (dotlock_t h, int reclaim);
int dotlock_take (dotlock_t h, long timeout);
int dotlock_release (dotlock_t h);
void dotlock_remove_lockfiles (int reclaim);
void dotlock_remove_lockfiles_reclaim (void);
# 137 "../include/util.h" 2


char * make_basename(const char *filepath, const char *inputpath);
char * make_dirname(const char *filepath);
char *make_filename( const char *first_part, ... );
int compare_filenames( const char *a, const char *b );
int same_file_p (const char *name1, const char *name2);
const char *print_fname_stdin( const char *s );
const char *print_fname_stdout( const char *s );
int is_file_compressed(const char *s, int *r_status);


u32 make_timestamp(void);
u32 scan_isodatestr( const char *string );
u32 isotime2seconds (const char *string);
const char *strtimevalue( u32 stamp );
const char *strtimestamp( u32 stamp );
const char *isotimestamp( u32 stamp );
const char *asctimestamp( u32 stamp );
void print_string( FILE *fp, const byte *p, size_t n, int delim );
void print_string2( FILE *fp, const byte *p, size_t n, int delim, int delim2 );
void print_utf8_string( FILE *fp, const byte *p, size_t n );
void print_utf8_string2( FILE *fp, const byte *p, size_t n, int delim);
char *make_printable_string( const byte *p, size_t n, int delim );
int answer_is_yes_no_default( const char *s, int def_answer );
int answer_is_yes( const char *s );
int answer_is_yes_no_quit( const char *s );
int answer_is_okay_cancel (const char *s, int def_answer);
int match_multistr(const char *multistr,const char *match);


void free_strlist( STRLIST sl );

STRLIST add_to_strlist( STRLIST *list, const char *string );
STRLIST add_to_strlist2( STRLIST *list, const char *string, int is_utf8 );
STRLIST append_to_strlist( STRLIST *list, const char *string );
STRLIST append_to_strlist2( STRLIST *list, const char *string, int is_utf8 );
STRLIST strlist_prev( STRLIST head, STRLIST node );
STRLIST strlist_last( STRLIST node );
char *pop_strlist( STRLIST *list );
const char *memistr( const char *buf, size_t buflen, const char *sub );
const char *ascii_memistr( const char *buf, size_t buflen, const char *sub );
char *mem2str( char *, const void *, size_t);
char *trim_spaces( char *string );
unsigned int trim_trailing_chars( byte *line, unsigned int len,
                                  const char *trimchars);
unsigned int trim_trailing_ws( byte *line, unsigned len );
unsigned int check_trailing_chars( const byte *line, unsigned int len,
                                   const char *trimchars );
unsigned int check_trailing_ws( const byte *line, unsigned int len );
int string_count_chr( const char *string, int c );
int has_invalid_email_chars (const char *s);
int is_valid_mailbox (const char *name);
int set_native_charset( const char *newset );
const char* get_native_charset(void);
char *native_to_utf8( const char *string );
char *utf8_to_native( const char *string, size_t length, int delim);
char *string_to_utf8 (const char *string);

int ascii_isupper (int c);
int ascii_islower (int c);
int ascii_memcasecmp( const char *a, const char *b, size_t n);
char *ascii_strlwr (char *s);
# 223 "../include/util.h"
struct private_membuf_s {
  size_t len;
  size_t size;
  char *buf;
  int out_of_core;
};

typedef struct private_membuf_s membuf_t;

void init_membuf (membuf_t *mb, int initiallen);
void put_membuf (membuf_t *mb, const void *buf, size_t len);
void put_membuf_str (membuf_t *mb, const char *buf);
void *get_membuf (membuf_t *mb, size_t *len);
# 249 "../include/util.h"
char *xasprintf (const char *fmt, ...);
char *xtryasprintf (const char *fmt, ...);
char *xtryvasprintf (const char *fmt, va_list arg_ptr);
char *strconcat (const char *s1, ...) __attribute__ ((sentinel(0)));


char *get_pka_info (const char *address, void *fprbuf, size_t fprbuflen);


int get_cert (const char *name, int want_ipgp, size_t max_size, IOBUF *iobuf,
              unsigned char **fpr,size_t *fpr_len,char **url);


int hex2bin (const char *string, void *buffer, size_t length);
int hexcolon2bin (const char *string, void *buffer, size_t length);
char *bin2hex (const void *buffer, size_t length, char *stringbuf);
char *bin2hexcolon (const void *buffer, size_t length, char *stringbuf);
const char *hex2str (const char *hexstring,
                     char *buffer, size_t bufsize, size_t *buflen);
char *hex2str_alloc (const char *hexstring, size_t *r_count);
# 62 "app-openpgp.c" 2
# 1 "./cardglue.h" 1
# 32 "./cardglue.h"
typedef void (*gcry_handler_progress_t) (void *, const char *, int, int, int);



struct agent_card_info_s {
  int error;
  char *apptype;
  char *serialno;
  char *disp_name;
  char *disp_lang;
  int disp_sex;
  char *pubkey_url;
  char *login_data;
  char *private_do[4];
  char cafpr1valid;
  char cafpr2valid;
  char cafpr3valid;
  char cafpr1[20];
  char cafpr2[20];
  char cafpr3[20];
  char fpr1valid;
  char fpr2valid;
  char fpr3valid;
  char fpr1[20];
  char fpr2[20];
  char fpr3[20];
  u32 fpr1time;
  u32 fpr2time;
  u32 fpr3time;
  unsigned long sig_counter;
  int chv1_cached;


  int is_v2;
  int chvmaxlen[3];
  int chvretry[3];
  struct {
    int algo;
    unsigned int nbits;
  } key_attr[3];
  struct {
    unsigned int ki:1;
    unsigned int aac:1;
  } extcap;
};

struct agent_card_genkey_s {
  char fprvalid;
  char fpr[20];
  u32 created_at;
  MPI n;
  MPI e;
};


struct app_ctx_s;
struct ctrl_ctx_s;

typedef struct app_ctx_s *APP;
typedef struct app_ctx_s *app_t;
typedef struct ctrl_ctx_s *CTRL;
typedef struct ctrl_ctx_s *ctrl_t;
# 142 "./cardglue.h"
typedef int gpg_error_t;
typedef int gpg_err_code_t;
# 165 "./cardglue.h"
void card_set_reader_port (const char *portstr);

char *serialno_and_fpr_from_sk (const unsigned char *sn, size_t snlen,
                                PKT_secret_key *sk);
void send_status_info (ctrl_t ctrl, const char *keyword, ...);
void send_status_direct (ctrl_t ctrl, const char *keyword, const char *args);
void gcry_md_hash_buffer (int algo, void *digest,
     const void *buffer, size_t length);
const char *gcry_md_algo_name (int algorithm);
void log_printf (const char *fmt, ...);
void log_printhex (const char *text, const void *buffer, size_t length);
# 186 "./cardglue.h"
void gcry_mpi_release (MPI a);
MPI gcry_mpi_set_opaque (MPI a, void *p, unsigned int len);


void card_close (void);



void agent_release_card_info (struct agent_card_info_s *info);


int agent_learn (struct agent_card_info_s *info);



int agent_havekey (const char *hexkeygrip);


int agent_scd_getattr (const char *name, struct agent_card_info_s *info);


int agent_scd_setattr (const char *name,
                       const unsigned char *value, size_t valuelen,
                       const char *serialno);


int agent_scd_writekey (int keyno, const char *serialno,
                        const unsigned char *keydata, size_t keydatalen);


int agent_scd_genkey (struct agent_card_genkey_s *info, int keyno, int force,
                      const char *serialno, u32 *createtime);


int agent_scd_pksign (const char *keyid, int hashalgo,
                      const unsigned char *indata, size_t indatalen,
                      unsigned char **r_buf, size_t *r_buflen);


int agent_scd_pkdecrypt (const char *serialno,
                         const unsigned char *indata, size_t indatalen,
                         unsigned char **r_buf, size_t *r_buflen);


int agent_scd_change_pin (int chvno, const char *serialno);


int agent_scd_checkpin (const char *serialnobuf);


void agent_clear_pin_cache (const char *sn);



int agent_scd_writecert (const char *certidstr,
                         const unsigned char *certdata, size_t certdatalen);
int agent_scd_readcert (const char *certidstr,
                        void **r_buf, size_t *r_buflen);
# 63 "app-openpgp.c" 2




# 1 "../include/i18n.h" 1
# 32 "../include/i18n.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 1 3
# 26 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 3
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;

 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_p_sep_by_space;
 char int_n_cs_precedes;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};


char *setlocale (int, const char *);
struct lconv *localeconv(void);







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 65 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 2 3
# 76 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 3
locale_t duplocale(locale_t);
void freelocale(locale_t);
locale_t newlocale(int, const char *, locale_t);
locale_t uselocale(locale_t);
# 33 "../include/i18n.h" 2




# 1 "../intl/libintl.h" 1
# 58 "../intl/libintl.h"
extern int libintl_version;
# 134 "../intl/libintl.h"
extern char *gettext (const char *__msgid)
       __asm__ ("" "libintl_gettext")
       __attribute__ ((__format_arg__ (1)));
# 152 "../intl/libintl.h"
extern char *dgettext (const char *__domainname, const char *__msgid)
       __asm__ ("" "libintl_dgettext")
       __attribute__ ((__format_arg__ (2)));
# 172 "../intl/libintl.h"
extern char *dcgettext (const char *__domainname, const char *__msgid,
                        int __category)
       __asm__ ("" "libintl_dcgettext")
       __attribute__ ((__format_arg__ (2)));
# 194 "../intl/libintl.h"
extern char *ngettext (const char *__msgid1, const char *__msgid2,
                       unsigned long int __n)
       __asm__ ("" "libintl_ngettext")
       __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));
# 215 "../intl/libintl.h"
extern char *dngettext (const char *__domainname,
                        const char *__msgid1, const char *__msgid2,
                        unsigned long int __n)
       __asm__ ("" "libintl_dngettext")
       __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
# 239 "../intl/libintl.h"
extern char *dcngettext (const char *__domainname,
                         const char *__msgid1, const char *__msgid2,
                         unsigned long int __n, int __category)
       __asm__ ("" "libintl_dcngettext")
       __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
# 261 "../intl/libintl.h"
extern char *textdomain (const char *__domainname)
       __asm__ ("" "libintl_textdomain");
# 279 "../intl/libintl.h"
extern char *bindtextdomain (const char *__domainname, const char *__dirname)
       __asm__ ("" "libintl_bindtextdomain");
# 297 "../intl/libintl.h"
extern char *bind_textdomain_codeset (const char *__domainname,
                                      const char *__codeset)
       __asm__ ("" "libintl_bind_textdomain_codeset");
# 455 "../intl/libintl.h"
extern void
       libintl_set_relocation_prefix (const char *orig_prefix,
                                      const char *curr_prefix);
# 38 "../include/i18n.h" 2
# 68 "app-openpgp.c" 2
# 1 "./iso7816.h" 1
# 37 "./iso7816.h"
struct iso7816_pininfo_s
{
  int mode;
  int minlen;
  int maxlen;
  int padlen;
  int padchar;
};
typedef struct iso7816_pininfo_s iso7816_pininfo_t;


gpg_error_t iso7816_map_sw (int sw);

gpg_error_t iso7816_select_application (int slot,
                                        const char *aid, size_t aidlen,
                                        unsigned int flags);
gpg_error_t iso7816_select_file (int slot, int tag, int is_dir,
                                 unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_select_path (int slot,
                                 const unsigned short *path, size_t pathlen,
                                 unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_list_directory (int slot, int list_dirs,
                                    unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_apdu_direct (int slot,
                                 const void *apdudata, size_t apdudatalen,
                                 int handle_more,
                                 unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_check_keypad (int slot, int command,
                                  iso7816_pininfo_t *pininfo);
gpg_error_t iso7816_verify (int slot,
                            int chvno, const char *chv, size_t chvlen);
gpg_error_t iso7816_verify_kp (int slot,
                               int chvno, const char *chv, size_t chvlen,
                               iso7816_pininfo_t *pininfo);
gpg_error_t iso7816_change_reference_data (int slot, int chvno,
                               const char *oldchv, size_t oldchvlen,
                               const char *newchv, size_t newchvlen);
gpg_error_t iso7816_change_reference_data_kp (int slot, int chvno,
                               const char *oldchv, size_t oldchvlen,
                               const char *newchv, size_t newchvlen,
                               iso7816_pininfo_t *pininfo);
gpg_error_t iso7816_reset_retry_counter (int slot, int chvno,
                                         const char *newchv, size_t newchvlen);
gpg_error_t iso7816_reset_retry_counter_kp (int slot, int chvno,
                                            const char *newchv,
                                            size_t newchvlen,
                                            iso7816_pininfo_t *pininfo);
gpg_error_t iso7816_reset_retry_counter_with_rc (int slot, int chvno,
                                                 const char *data,
                                                 size_t datalen);
gpg_error_t iso7816_get_data (int slot, int extended_mode, int tag,
                              unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_put_data (int slot, int extended_mode, int tag,
                              const unsigned char *data, size_t datalen);
gpg_error_t iso7816_put_data_odd (int slot, int extended_mode, int tag,
                                  const unsigned char *data, size_t datalen);
gpg_error_t iso7816_manage_security_env (int slot, int p1, int p2,
                                         const unsigned char *data,
                                         size_t datalen);
gpg_error_t iso7816_compute_ds (int slot, int extended_mode,
                                const unsigned char *data, size_t datalen,
                                int le,
                                unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_decipher (int slot, int extended_mode,
                              const unsigned char *data, size_t datalen,
                              int le, int padind,
                              unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_internal_authenticate (int slot, int extended_mode,
                                   const unsigned char *data, size_t datalen,
                                   int le,
                                   unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_generate_keypair (int slot, int extended_mode,
                                    const unsigned char *data, size_t datalen,
                                    int le,
                                    unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_read_public_key (int slot, int extended_mode,
                                    const unsigned char *data, size_t datalen,
                                    int le,
                                    unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_get_challenge (int slot,
                                   int length, unsigned char *buffer);

gpg_error_t iso7816_read_binary (int slot, size_t offset, size_t nmax,
                                 unsigned char **result, size_t *resultlen);
gpg_error_t iso7816_read_record (int slot, int recno, int reccount,
                                 int short_ef,
                                 unsigned char **result, size_t *resultlen);
# 69 "app-openpgp.c" 2
# 1 "./app-common.h" 1
# 38 "./app-common.h"
struct app_local_s;

struct app_ctx_s {




  unsigned int ref_count;




  int no_reuse;


  int slot;






  assuan_context_t assuan_ctx;


  unsigned char *serialno;
  size_t serialnolen;
  const char *apptype;
  unsigned int card_version;
  int did_chv1;
  int force_chv1;
  int did_chv2;
  int did_chv3;
  struct app_local_s *app_local;
  struct {
    void (*deinit) (app_t app);
    gpg_error_t (*learn_status) (app_t app, ctrl_t ctrl, unsigned int flags);
    gpg_error_t (*readcert) (app_t app, const char *certid,
                     unsigned char **cert, size_t *certlen);
    gpg_error_t (*readkey) (app_t app, const char *certid,
                    unsigned char **pk, size_t *pklen);
    gpg_error_t (*getattr) (app_t app, ctrl_t ctrl, const char *name);
    gpg_error_t (*setattr) (app_t app, const char *name,
                    gpg_error_t (*pincb)(void*, const char *, char **),
                    void *pincb_arg,
                    const unsigned char *value, size_t valuelen);
    gpg_error_t (*sign) (app_t app,
                 const char *keyidstr, int hashalgo,
                 gpg_error_t (*pincb)(void*, const char *, char **),
                 void *pincb_arg,
                 const void *indata, size_t indatalen,
                 unsigned char **outdata, size_t *outdatalen );
    gpg_error_t (*auth) (app_t app, const char *keyidstr,
                 gpg_error_t (*pincb)(void*, const char *, char **),
                 void *pincb_arg,
                 const void *indata, size_t indatalen,
                 unsigned char **outdata, size_t *outdatalen);
    gpg_error_t (*decipher) (app_t app, const char *keyidstr,
                     gpg_error_t (*pincb)(void*, const char *, char **),
                     void *pincb_arg,
                     const void *indata, size_t indatalen,
                     unsigned char **outdata, size_t *outdatalen);
    gpg_error_t (*writecert) (app_t app, ctrl_t ctrl,
                              const char *certid,
                              gpg_error_t (*pincb)(void*,const char *,char **),
                              void *pincb_arg,
                              const unsigned char *data, size_t datalen);
    gpg_error_t (*writekey) (app_t app, ctrl_t ctrl,
                             const char *keyid, unsigned int flags,
                             gpg_error_t (*pincb)(void*,const char *,char **),
                             void *pincb_arg,
                             const unsigned char *pk, size_t pklen);
    gpg_error_t (*genkey) (app_t app, ctrl_t ctrl,
                           const char *keynostr, unsigned int flags,
                           time_t createtime,
                           gpg_error_t (*pincb)(void*, const char *, char **),
                           void *pincb_arg);
    gpg_error_t (*change_pin) (app_t app, ctrl_t ctrl,
                       const char *chvnostr, unsigned int flags,
                       gpg_error_t (*pincb)(void*, const char *, char **),
                       void *pincb_arg);
    gpg_error_t (*check_pin) (app_t app, const char *keyidstr,
                      gpg_error_t (*pincb)(void*, const char *, char **),
                      void *pincb_arg);
  } fnc;

};


gpg_error_t app_select_openpgp (app_t app);
gpg_error_t app_get_serial_and_stamp (app_t app, char **serial, time_t *stamp);
gpg_error_t app_openpgp_storekey (app_t app, int keyno,
                          unsigned char *template, size_t template_len,
                          time_t created_at,
                          const unsigned char *m, size_t mlen,
                          const unsigned char *e, size_t elen,
                          gpg_error_t (*pincb)(void*, const char *, char **),
                          void *pincb_arg);
# 70 "app-openpgp.c" 2
# 1 "./tlv.h" 1
# 24 "./tlv.h"
enum tlv_tag_class {
  CLASS_UNIVERSAL = 0,
  CLASS_APPLICATION = 1,
  CLASS_CONTEXT = 2,
  CLASS_PRIVATE =3
};

enum tlv_tag_type {
  TAG_NONE = 0,
  TAG_BOOLEAN = 1,
  TAG_INTEGER = 2,
  TAG_BIT_STRING = 3,
  TAG_OCTET_STRING = 4,
  TAG_NULL = 5,
  TAG_OBJECT_ID = 6,
  TAG_OBJECT_DESCRIPTOR = 7,
  TAG_EXTERNAL = 8,
  TAG_REAL = 9,
  TAG_ENUMERATED = 10,
  TAG_EMBEDDED_PDV = 11,
  TAG_UTF8_STRING = 12,
  TAG_REALTIVE_OID = 13,
  TAG_SEQUENCE = 16,
  TAG_SET = 17,
  TAG_NUMERIC_STRING = 18,
  TAG_PRINTABLE_STRING = 19,
  TAG_TELETEX_STRING = 20,
  TAG_VIDEOTEX_STRING = 21,
  TAG_IA5_STRING = 22,
  TAG_UTC_TIME = 23,
  TAG_GENERALIZED_TIME = 24,
  TAG_GRAPHIC_STRING = 25,
  TAG_VISIBLE_STRING = 26,
  TAG_GENERAL_STRING = 27,
  TAG_UNIVERSAL_STRING = 28,
  TAG_CHARACTER_STRING = 29,
  TAG_BMP_STRING = 30
};





const unsigned char *find_tlv (const unsigned char *buffer, size_t length,
                               int tag, size_t *nbytes);






const unsigned char *find_tlv_unchecked (const unsigned char *buffer,
                                         size_t length,
                                         int tag, size_t *nbytes);





gpg_error_t parse_ber_header (unsigned char const **buffer, size_t *size,
                              int *r_class, int *r_tag,
                              int *r_constructed,
                              int *r_ndef, size_t *r_length, size_t *r_nhdr);
# 102 "./tlv.h"
gpg_error_t parse_sexp (unsigned char const **buf, size_t *buflen,
                        int *depth, unsigned char const **tok, size_t *toklen);
# 71 "app-openpgp.c" 2
# 1 "./../include/host2net.h" 1
# 37 "./../include/host2net.h"
static inline unsigned long
buf16_to_ulong (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned long)p[0] << 8) | p[1]);
}

static inline unsigned int
buf16_to_uint (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned int)p[0] << 8) | p[1]);
}

static inline unsigned short
buf16_to_ushort (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned short)p[0] << 8) | p[1]);
}

static inline u16
buf16_to_u16 (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((u16)p[0] << 8) | p[1]);
}

static inline size_t
buf32_to_size_t (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((size_t)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}

static inline unsigned long
buf32_to_ulong (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned long)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}

static inline unsigned int
buf32_to_uint (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((unsigned int)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}

static inline u32
buf32_to_u32 (const void *buffer)
{
  const unsigned char *p = buffer;

  return (((u32)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}
# 72 "app-openpgp.c" 2



static struct {
  int tag;
  int constructed;
  int get_from;
  int binary:1;
  int dont_cache:1;
  int flush_on_error:1;
  int get_immediate_in_v11:1;





  int try_extlen:1;

  char *desc;
} data_objects[] = {
  { 0x005E, 0, 0, 1, 0, 0, 0, 0, "Login Data" },
  { 0x5F50, 0, 0, 0, 0, 0, 0, 0, "URL" },
  { 0x5F52, 0, 0, 1, 0, 0, 0, 0, "Historical Bytes" },
  { 0x0065, 1, 0, 1, 0, 0, 0, 0, "Cardholder Related Data"},
  { 0x005B, 0, 0x65, 0, 0, 0, 0, 0, "Name" },
  { 0x5F2D, 0, 0x65, 0, 0, 0, 0, 0, "Language preferences" },
  { 0x5F35, 0, 0x65, 0, 0, 0, 0, 0, "Sex" },
  { 0x006E, 1, 0, 1, 0, 0, 0, 0, "Application Related Data" },
  { 0x004F, 0, 0x6E, 1, 0, 0, 0, 0, "AID" },
  { 0x0073, 1, 0, 1, 0, 0, 0, 0, "Discretionary Data Objects" },
  { 0x0047, 0, 0x6E, 1, 1, 0, 0, 0, "Card Capabilities" },
  { 0x00C0, 0, 0x6E, 1, 1, 0, 0, 0, "Extended Card Capabilities" },
  { 0x00C1, 0, 0x6E, 1, 1, 0, 0, 0, "Algorithm Attributes Signature" },
  { 0x00C2, 0, 0x6E, 1, 1, 0, 0, 0, "Algorithm Attributes Decryption" },
  { 0x00C3, 0, 0x6E, 1, 1, 0, 0, 0, "Algorithm Attributes Authentication" },
  { 0x00C4, 0, 0x6E, 1, 0, 1, 1, 0, "CHV Status Bytes" },
  { 0x00C5, 0, 0x6E, 1, 0, 0, 0, 0, "Fingerprints" },
  { 0x00C6, 0, 0x6E, 1, 0, 0, 0, 0, "CA Fingerprints" },
  { 0x00CD, 0, 0x6E, 1, 0, 0, 0, 0, "Generation time" },
  { 0x007A, 1, 0, 1, 0, 0, 0, 0, "Security Support Template" },
  { 0x0093, 0, 0x7A, 1, 1, 0, 0, 0, "Digital Signature Counter" },
  { 0x0101, 0, 0, 0, 0, 0, 0, 0, "Private DO 1"},
  { 0x0102, 0, 0, 0, 0, 0, 0, 0, "Private DO 2"},
  { 0x0103, 0, 0, 0, 0, 0, 0, 0, "Private DO 3"},
  { 0x0104, 0, 0, 0, 0, 0, 0, 0, "Private DO 4"},
  { 0x7F21, 1, 0, 1, 0, 0, 0, 1, "Cardholder certificate"},
  { 0 }
};



typedef enum
  {
    RSA_UNKNOWN_FMT,
    RSA_STD,
    RSA_STD_N,
    RSA_CRT,
    RSA_CRT_N
  }
rsa_key_format_t;



struct cache_s {
  struct cache_s *next;
  int tag;
  size_t length;
  unsigned char data[1];
};



struct app_local_s {

  struct cache_s *cache;


  struct
  {
    int read_done;
    unsigned char *key;



    size_t keylen;



  } pk[3];

  unsigned char status_indicator;


  struct
  {
    unsigned int cmd_chaining:1;
    unsigned int ext_lc_le:1;
  } cardcap;


  struct
  {
    unsigned int is_v2:1;
    unsigned int get_challenge:1;
    unsigned int key_import:1;
    unsigned int change_force_chv:1;
    unsigned int private_dos:1;
    unsigned int algo_attr_change:1;
    unsigned int sm_supported:1;
    unsigned int sm_aes128:1;
    unsigned int max_certlen_3:16;
    unsigned int max_get_challenge:16;
    unsigned int max_cmd_data:16;
    unsigned int max_rsp_data:16;
  } extcap;


  struct
  {
    unsigned int no_sync:1;
    unsigned int def_chv2:1;
  } flags;

  struct
  {
    unsigned int n_bits;


    unsigned int e_bits;
    rsa_key_format_t format;
  } keyattr[3];

};




static unsigned long convert_sig_counter_value (const unsigned char *value,
                                                size_t valuelen);
static unsigned long get_sig_counter (app_t app);
static gpg_error_t do_auth (app_t app, const char *keyidstr,
                            gpg_error_t (*pincb)(void*, const char *, char **),
                            void *pincb_arg,
                            const void *indata, size_t indatalen,
                            unsigned char **outdata, size_t *outdatalen);
static void parse_algorithm_attribute (app_t app, int keyno);
static gpg_error_t change_keyattr_from_string
                           (app_t app,
                            gpg_error_t (*pincb)(void*, const char *, char **),
                            void *pincb_arg,
                            const void *value, size_t valuelen);






static void
do_deinit (app_t app)
{
  if (app && app->app_local)
    {
      struct cache_s *c, *c2;
      int i;

      for (c = app->app_local->cache; c; c = c2)
        {
          c2 = c->next;
          xfree (c);
        }

      for (i=0; i < (sizeof(app->app_local->pk)/sizeof((app->app_local->pk)[0])); i++)
        {
          xfree (app->app_local->pk[i].key);
          app->app_local->pk[i].read_done = 0;
        }
      xfree (app->app_local);
      app->app_local = ((void*)0);
    }
}






static gpg_error_t
get_cached_data (app_t app, int tag,
                 unsigned char **result, size_t *resultlen,
                 int get_immediate, int try_extlen)
{
  gpg_error_t err;
  int i;
  unsigned char *p;
  size_t len;
  struct cache_s *c;
  int exmode;

  *result = ((void*)0);
  *resultlen = 0;

  if (!get_immediate)
    {
      for (c=app->app_local->cache; c; c = c->next)
        if (c->tag == tag)
          {
            if(c->length)
              {
                p = xmalloc((c->length));
                if (!p)
                  return ((1));
                memcpy (p, c->data, c->length);
                *result = p;
              }

            *resultlen = c->length;

            return 0;
          }
    }

  if (try_extlen && app->app_local->cardcap.ext_lc_le)
    exmode = app->app_local->extcap.max_rsp_data;
  else
    exmode = 0;

  err = iso7816_get_data (app->slot, exmode, tag, &p, &len);
  if (err)
    return err;
  *result = p;
  *resultlen = len;


  if (get_immediate)
    return 0;

  for (i=0; data_objects[i].tag; i++)
    if (data_objects[i].tag == tag)
      {
        if (data_objects[i].dont_cache)
          return 0;
        break;
      }


  for (c=app->app_local->cache; c; c = c->next)
    ((void)((c->tag != tag) || (__assert_fail("c->tag != tag", "app-openpgp.c", 318, __func__),0)));

  c = xmalloc((sizeof *c + len));
  if (c)
    {
      memcpy (c->data, p, len);
      c->length = len;
      c->tag = tag;
      c->next = app->app_local->cache;
      app->app_local->cache = c;
    }

  return 0;
}


static void
flush_cache_item (app_t app, int tag)
{
  struct cache_s *c, *cprev;
  int i;

  if (!app->app_local)
    return;

  for (c=app->app_local->cache, cprev=((void*)0); c ; cprev=c, c = c->next)
    if (c->tag == tag)
      {
        if (cprev)
          cprev->next = c->next;
        else
          app->app_local->cache = c->next;
        xfree (c);

        for (c=app->app_local->cache; c ; c = c->next)
          {
            ((void)((c->tag != tag) || (__assert_fail("c->tag != tag", "app-openpgp.c", 354, __func__),0)));
          }
        return;
      }


  for (i=0; data_objects[i].tag; i++)
    if (data_objects[i].tag == tag && data_objects[i].get_from
        && data_objects[i].get_from != tag)
      flush_cache_item (app, data_objects[i].get_from);
}



static void
flush_cache_after_error (app_t app)
{
  int i;

  for (i=0; data_objects[i].tag; i++)
    if (data_objects[i].flush_on_error)
      flush_cache_item (app, data_objects[i].tag);
}



static void
flush_cache (app_t app)
{
  if (app && app->app_local)
    {
      struct cache_s *c, *c2;

      for (c = app->app_local->cache; c; c = c2)
        {
          c2 = c->next;
          xfree (c);
        }
      app->app_local->cache = ((void*)0);
    }
}






static void *
get_one_do (app_t app, int tag, unsigned char **result, size_t *nbytes,
            int *r_rc)
{
  int rc, i;
  unsigned char *buffer;
  size_t buflen;
  unsigned char *value;
  size_t valuelen;
  int dummyrc;
  int exmode;

  if (!r_rc)
    r_rc = &dummyrc;

  *result = ((void*)0);
  *nbytes = 0;
  *r_rc = 0;
  for (i=0; data_objects[i].tag && data_objects[i].tag != tag; i++)
    ;

  if (app->card_version > 0x0100 && data_objects[i].get_immediate_in_v11)
    {
      if (data_objects[i].try_extlen && app->app_local->cardcap.ext_lc_le)
        exmode = app->app_local->extcap.max_rsp_data;
      else
        exmode = 0;
      rc = iso7816_get_data (app->slot, exmode, tag, &buffer, &buflen);
      if (rc)
        {
          *r_rc = rc;
          return ((void*)0);
        }
      *result = buffer;
      *nbytes = buflen;
      return buffer;
    }

  value = ((void*)0);
  rc = -1;
  if (data_objects[i].tag && data_objects[i].get_from)
    {
      rc = get_cached_data (app, data_objects[i].get_from,
                            &buffer, &buflen,
                            (data_objects[i].dont_cache
                             || data_objects[i].get_immediate_in_v11),
                            data_objects[i].try_extlen);
      if (!rc)
        {
          const unsigned char *s;

          s = find_tlv_unchecked (buffer, buflen, tag, &valuelen);
          if (!s)
            value = ((void*)0);
          else if (valuelen > buflen - (s - buffer))
            {
              g10_log_error ("warning: constructed DO too short\n");
              value = ((void*)0);
              xfree (buffer); buffer = ((void*)0);
            }
          else
            value = buffer + (s - buffer);
        }
    }

  if (!value)
    {
      rc = get_cached_data (app, tag, &buffer, &buflen,
                            (data_objects[i].dont_cache
                             || data_objects[i].get_immediate_in_v11),
                            data_objects[i].try_extlen);
      if (!rc)
        {
          value = buffer;
          valuelen = buflen;
        }
    }

  if (!rc)
    {
      *nbytes = valuelen;
      *result = value;
      return buffer;
    }
  *r_rc = rc;
  return ((void*)0);
}


static void
dump_all_do (int slot)
{
  int rc, i, j;
  unsigned char *buffer;
  size_t buflen;

  for (i=0; data_objects[i].tag; i++)
    {
      if (data_objects[i].get_from)
        continue;



      rc = iso7816_get_data (slot, 0, data_objects[i].tag, &buffer, &buflen);
      if ((rc) == 1)
        ;
      else if (rc)
        g10_log_info ("DO `%s' not available: %s\n",
                  data_objects[i].desc, g10_errstr ((rc)));
      else
        {
          if (data_objects[i].binary)
            {
              g10_log_info ("DO `%s': ", data_objects[i].desc);
              log_printhex ("", buffer, buflen);
            }
          else
            g10_log_info ("DO `%s': `%.*s'\n",
                      data_objects[i].desc,
                      (int)buflen, buffer);

          if (data_objects[i].constructed)
            {
              for (j=0; data_objects[j].tag; j++)
                {
                  const unsigned char *value;
                  size_t valuelen;

                  if (j==i || data_objects[i].tag != data_objects[j].get_from)
                    continue;
                  value = find_tlv_unchecked (buffer, buflen,
                                              data_objects[j].tag, &valuelen);
                  if (!value)
                    ;
                  else if (valuelen > buflen - (value - buffer))
                    g10_log_error ("warning: constructed DO too short\n");
                  else
                    {
                      if (data_objects[j].binary)
                        {
                          g10_log_info ("DO `%s': ", data_objects[j].desc);
                          if (valuelen > 200)
                            g10_log_info ("[%u]\n", (unsigned int)valuelen);
                          else
                            log_printhex ("", value, valuelen);
                        }
                      else
                        g10_log_info ("DO `%s': `%.*s'\n",
                                  data_objects[j].desc,
                                  (int)valuelen, value);
                    }
                }
            }
        }
      xfree (buffer); buffer = ((void*)0);
    }
}




static unsigned int
count_bits (const unsigned char *a, size_t len)
{
  unsigned int n = len * 8;
  int i;

  for (; len && !*a; len--, a++, n -=8)
    ;
  if (len)
    {
      for (i=7; i && !(*a & (1<<i)); i--)
        n--;
    }
  return n;
}
# 597 "app-openpgp.c"
static void
parse_login_data (app_t app)
{
  unsigned char *buffer, *p;
  size_t buflen, len;
  void *relptr;


  app->app_local->flags.no_sync = 0;
  app->app_local->flags.def_chv2 = 0;


  relptr = get_one_do (app, 0x005E, &buffer, &buflen, ((void*)0));
  if (!relptr)
    return;
  for (; buflen; buflen--, buffer++)
    if (*buffer == '\n')
      break;
  if (buflen < 2 || buffer[1] != '\x14')
    return;
  buflen--;
  buffer++;
  do
    {
      buflen--;
      buffer++;
      if (buflen > 1 && *buffer == 'F' && buffer[1] == '=')
        {

          int lastdig = 0;



          for (p=buffer+2, len = buflen-2; len && ((*(p) >= '0' && *(p) <= '9') || (*(p) >= 'A' && *(p) <= 'F') || (*(p) >= 'a' && *(p) <= 'f')); p++, len--)
            lastdig = (*(p) <= '9'? (*(p)- '0'): *(p) <= 'F'? (*(p)-'A'+10):(*(p)-'a'+10));
          if (len && !(*p == '\n' || *p == '\x18'))
            goto next;
          app->app_local->flags.no_sync = !!(lastdig & 1);
          app->app_local->flags.def_chv2 = (lastdig & 3) == 3;
        }
    next:
      for (; buflen && *buffer != '\x18'; buflen--, buffer++)
        if (*buffer == '\n')
          buflen = 1;
    }
  while (buflen);

  xfree (relptr);
}


static gpg_error_t
store_fpr (app_t app, int keynumber, u32 timestamp,
           const unsigned char *m, size_t mlen,
           const unsigned char *e, size_t elen,
           unsigned char *fpr, unsigned int card_version)
{
  unsigned int n, nbits;
  unsigned char *buffer, *p;
  int tag, tag2;
  int rc;

  for (; mlen && !*m; mlen--, m++)
    ;
  for (; elen && !*e; elen--, e++)
    ;

  n = 6 + 2 + mlen + 2 + elen;
  p = buffer = xmalloc((3 + n));
  if (!buffer)
    return (1);

  *p++ = 0x99;
  *p++ = n >> 8;
  *p++ = n;
  *p++ = 4;
  *p++ = timestamp >> 24;
  *p++ = timestamp >> 16;
  *p++ = timestamp >> 8;
  *p++ = timestamp;
  *p++ = 1;
  nbits = count_bits (m, mlen);
  *p++ = nbits >> 8;
  *p++ = nbits;
  memcpy (p, m, mlen); p += mlen;
  nbits = count_bits (e, elen);
  *p++ = nbits >> 8;
  *p++ = nbits;
  memcpy (p, e, elen); p += elen;

  gcry_md_hash_buffer (2, fpr, buffer, n+3);

  xfree (buffer);

  tag = (card_version > 0x0007? 0xC7 : 0xC6) + keynumber;
  flush_cache_item (app, 0xC5);
  tag2 = 0xCE + keynumber;
  flush_cache_item (app, 0xCD);

  rc = iso7816_put_data (app->slot, 0, tag, fpr, 20);
  if (rc)
    g10_log_error (gettext ("failed to store the fingerprint: %s\n"),g10_errstr ((rc)));

  if (!rc && card_version > 0x0100)
    {
      unsigned char buf[4];

      buf[0] = timestamp >> 24;
      buf[1] = timestamp >> 16;
      buf[2] = timestamp >> 8;
      buf[3] = timestamp;

      rc = iso7816_put_data (app->slot, 0, tag2, buf, 4);
      if (rc)
        g10_log_error (gettext ("failed to store the creation date: %s\n"),
                   g10_errstr ((rc)));
    }

  return rc;
}


static void
send_fpr_if_not_null (ctrl_t ctrl, const char *keyword,
                      int number, const unsigned char *fpr)
{
  int i;
  char buf[41];
  char numbuf[25];

  for (i=0; i < 20 && !fpr[i]; i++)
    ;
  if (i==20)
    return;
  bin2hex (fpr, 20, buf);
  if (number == -1)
    *numbuf = 0;
  else
    sprintf (numbuf, "%d", number);
  send_status_info (ctrl, keyword,
                    numbuf, (size_t)strlen(numbuf),
                    buf, (size_t)strlen (buf), ((void*)0), 0);
}

static void
send_fprtime_if_not_null (ctrl_t ctrl, const char *keyword,
                          int number, const unsigned char *stamp)
{
  char numbuf1[50], numbuf2[50];
  unsigned long value;

  value = buf32_to_ulong (stamp);
  if (!value)
    return;
  sprintf (numbuf1, "%d", number);
  sprintf (numbuf2, "%lu", value);
  send_status_info (ctrl, keyword,
                    numbuf1, (size_t)strlen(numbuf1),
                    numbuf2, (size_t)strlen(numbuf2), ((void*)0), 0);
}

static void
send_key_data (ctrl_t ctrl, const char *name,
               const unsigned char *a, size_t alen)
{
  char *buf;

  buf = bin2hex (a, alen, ((void*)0));
  if (!buf)
    {
      g10_log_error ("memory allocation error in send_key_data\n");
      return;
    }

  send_status_info (ctrl, "KEY-DATA",
                    name, (size_t)strlen(name),
                    buf, (size_t)strlen (buf),
                    ((void*)0), 0);
  xfree (buf);
}


static void
send_key_attr (ctrl_t ctrl, app_t app, const char *keyword, int number)
{
  char buffer[200];

  ((void)((number >=0 && number < (sizeof(app->app_local->keyattr)/sizeof((app->app_local->keyattr)[0]))) || (__assert_fail("number >=0 && number < DIM(app->app_local->keyattr)", "app-openpgp.c", 784, __func__),0)));


  snprintf (buffer, sizeof buffer, "%d 1 %u %u %d",
            number+1,
            app->app_local->keyattr[number].n_bits,
            app->app_local->keyattr[number].e_bits,
            app->app_local->keyattr[number].format);
  send_status_direct (ctrl, keyword, buffer);
}




static gpg_error_t
do_getattr (app_t app, ctrl_t ctrl, const char *name)
{
  static struct {
    const char *name;
    int tag;
    int special;
  } table[] = {
    { "DISP-NAME", 0x005B },
    { "LOGIN-DATA", 0x005E },
    { "DISP-LANG", 0x5F2D },
    { "DISP-SEX", 0x5F35 },
    { "PUBKEY-URL", 0x5F50 },
    { "KEY-FPR", 0x00C5, 3 },
    { "KEY-TIME", 0x00CD, 4 },
    { "KEY-ATTR", 0x0000, -5 },
    { "CA-FPR", 0x00C6, 3 },
    { "CHV-STATUS", 0x00C4, 1 },
    { "SIG-COUNTER", 0x0093, 2 },
    { "SERIALNO", 0x004F, -1 },
    { "AID", 0x004F },
    { "EXTCAP", 0x0000, -2 },
    { "PRIVATE-DO-1", 0x0101 },
    { "PRIVATE-DO-2", 0x0102 },
    { "PRIVATE-DO-3", 0x0103 },
    { "PRIVATE-DO-4", 0x0104 },
    { "$AUTHKEYID", 0x0000, -3 },
    { "$DISPSERIALNO",0x0000, -4 },
    { ((void*)0), 0 }
  };
  int idx, i, rc;
  void *relptr;
  unsigned char *value;
  size_t valuelen;

  for (idx=0; table[idx].name && strcmp (table[idx].name, name); idx++)
    ;
  if (!table[idx].name)
    return (1);

  if (table[idx].special == -1)
    {





      char *serial;
      time_t stamp;
      char tmp[50];

      if (!app_get_serial_and_stamp (app, &serial, &stamp))
        {
          sprintf (tmp, "%lu", (unsigned long)stamp);
          send_status_info (ctrl, "SERIALNO",
                            serial, strlen (serial),
                            tmp, strlen (tmp),
                            ((void*)0), 0);
          xfree (serial);
        }
      return 0;
    }
  if (table[idx].special == -2)
    {
      char tmp[100];

      snprintf (tmp, sizeof tmp,
                "gc=%d ki=%d fc=%d pd=%d mcl3=%u aac=%d sm=%d",
                app->app_local->extcap.get_challenge,
                app->app_local->extcap.key_import,
                app->app_local->extcap.change_force_chv,
                app->app_local->extcap.private_dos,
                app->app_local->extcap.max_certlen_3,
                app->app_local->extcap.algo_attr_change,
                (app->app_local->extcap.sm_supported
                 ? (app->app_local->extcap.sm_aes128? 7 : 2)
                 : 0));
      send_status_info (ctrl, table[idx].name, tmp, strlen (tmp), ((void*)0), 0);
      return 0;
    }
  if (table[idx].special == -3)
    {
      char const tmp[] = "OPENPGP.3";
      send_status_info (ctrl, table[idx].name, tmp, strlen (tmp), ((void*)0), 0);
      return 0;
    }
  if (table[idx].special == -4)
    {
      char *serial;
      time_t stamp;

      if (!app_get_serial_and_stamp (app, &serial, &stamp))
        {
          if (strlen (serial) > 16+12)
            {
              send_status_info (ctrl, table[idx].name, serial+16, 12, ((void*)0), 0);
              xfree (serial);
              return 0;
            }
          xfree (serial);
        }
      return (1);
    }
  if (table[idx].special == -5)
    {
      for (i=0; i < 3; i++)
        send_key_attr (ctrl, app, table[idx].name, i);
      return 0;
    }

  relptr = get_one_do (app, table[idx].tag, &value, &valuelen, &rc);
  if (relptr)
    {
      if (table[idx].special == 1)
        {
          char numbuf[7*23];

          for (i=0,*numbuf=0; i < valuelen && i < 7; i++)
            sprintf (numbuf+strlen (numbuf), " %d", value[i]);
          send_status_info (ctrl, table[idx].name,
                            numbuf, strlen (numbuf), ((void*)0), 0);
        }
      else if (table[idx].special == 2)
        {
          char numbuf[50];

          sprintf (numbuf, "%lu", convert_sig_counter_value (value, valuelen));
          send_status_info (ctrl, table[idx].name,
                            numbuf, strlen (numbuf), ((void*)0), 0);
        }
      else if (table[idx].special == 3)
        {
          if (valuelen >= 60)
            for (i=0; i < 3; i++)
              send_fpr_if_not_null (ctrl, table[idx].name, i+1, value+i*20);
        }
      else if (table[idx].special == 4)
        {
          if (valuelen >= 12)
            for (i=0; i < 3; i++)
              send_fprtime_if_not_null (ctrl, table[idx].name, i+1, value+i*4);
        }
      else
        send_status_info (ctrl, table[idx].name, value, valuelen, ((void*)0), 0);

      xfree (relptr);
    }
  return rc;
}
# 1302 "app-openpgp.c"
static gpg_error_t
send_keypair_info (app_t app, ctrl_t ctrl, int keyno)
{
  gpg_error_t err = 0;
# 1338 "app-openpgp.c"
  return err;
}



static gpg_error_t
do_learn_status (app_t app, ctrl_t ctrl, unsigned int flags)
{
  (void)flags;

  do_getattr (app, ctrl, "EXTCAP");
  do_getattr (app, ctrl, "DISP-NAME");
  do_getattr (app, ctrl, "DISP-LANG");
  do_getattr (app, ctrl, "DISP-SEX");
  do_getattr (app, ctrl, "PUBKEY-URL");
  do_getattr (app, ctrl, "LOGIN-DATA");
  do_getattr (app, ctrl, "KEY-FPR");
  if (app->card_version > 0x0100)
    do_getattr (app, ctrl, "KEY-TIME");
  do_getattr (app, ctrl, "CA-FPR");
  do_getattr (app, ctrl, "CHV-STATUS");
  do_getattr (app, ctrl, "SIG-COUNTER");
  if (app->app_local->extcap.private_dos)
    {
      do_getattr (app, ctrl, "PRIVATE-DO-1");
      do_getattr (app, ctrl, "PRIVATE-DO-2");
      if (app->did_chv2)
        do_getattr (app, ctrl, "PRIVATE-DO-3");
      if (app->did_chv3)
        do_getattr (app, ctrl, "PRIVATE-DO-4");
    }
  send_keypair_info (app, ctrl, 1);
  send_keypair_info (app, ctrl, 2);
  send_keypair_info (app, ctrl, 3);


  return 0;
}







static gpg_error_t
do_readkey (app_t app, const char *keyid, unsigned char **pk, size_t *pklen)
{
# 1418 "app-openpgp.c"
  return (1);

}





static gpg_error_t
do_readcert (app_t app, const char *certid,
             unsigned char **cert, size_t *certlen)
{
# 1460 "app-openpgp.c"
  return (1);

}
# 1475 "app-openpgp.c"
static gpg_error_t
verify_a_chv (app_t app,
              gpg_error_t (*pincb)(void*, const char *, char **),
              void *pincb_arg,
              int chvno, unsigned long sigcount, char **pinvalue)
{
  int rc = 0;
  char *prompt_buffer = ((void*)0);
  const char *prompt;
  iso7816_pininfo_t pininfo;
  int minlen = 6;

  ((void)((chvno == 1 || chvno == 2) || (__assert_fail("chvno == 1 || chvno == 2", "app-openpgp.c", 1487, __func__),0)));

  *pinvalue = ((void*)0);

  if (chvno == 2 && app->app_local->flags.def_chv2)
    {

      if (opt.verbose)
        g10_log_info (gettext ("using default PIN as %s\n"), "CHV2");
      rc = iso7816_verify (app->slot, 0x82, "123456", 6);
      if (rc)
        {



          g10_log_info (gettext ("failed to use default PIN as %s: %s" " - disabling further default use\n"),

                    "CHV2", g10_errstr ((rc)));
          app->app_local->flags.def_chv2 = 0;
        }
      return rc;
    }

  memset (&pininfo, 0, sizeof pininfo);
  pininfo.mode = 1;
  pininfo.minlen = minlen;


  if (chvno == 1)
    {

      size_t promptsize = strlen (gettext ("||Please enter the PIN%%0A[sigs done: %lu]")) + 50;

      prompt_buffer = xmalloc((promptsize));
      if (!prompt_buffer)
        return (1);
      snprintf (prompt_buffer, promptsize-1, gettext ("||Please enter the PIN%%0A[sigs done: %lu]"), sigcount);
      prompt = prompt_buffer;

    }
  else
    prompt = gettext ("||Please enter the PIN");


  if (!opt.disable_keypad
      && !iso7816_check_keypad (app->slot, 0x20, &pininfo) )
    {



      rc = pincb (pincb_arg, prompt, ((void*)0));
      prompt = ((void*)0);
      xfree (prompt_buffer);
      prompt_buffer = ((void*)0);
      if (rc)
        {
          g10_log_info (gettext ("PIN callback returned error: %s\n"),
                    g10_errstr ((rc)));
          return rc;
        }
      rc = iso7816_verify_kp (app->slot, 0x80+chvno, "", 0, &pininfo);

      pincb (pincb_arg, ((void*)0), ((void*)0));

      ((void)((!*pinvalue) || (__assert_fail("!*pinvalue", "app-openpgp.c", 1551, __func__),0)));
    }
  else
    {

      rc = pincb (pincb_arg, prompt, pinvalue);
      prompt = ((void*)0);
      xfree (prompt_buffer);
      prompt_buffer = ((void*)0);
      if (rc)
        {
          g10_log_info (gettext ("PIN callback returned error: %s\n"),
                    g10_errstr ((rc)));
          return rc;
        }

      if (strlen (*pinvalue) < minlen)
        {
          g10_log_error (gettext ("PIN for CHV%d is too short;" " minimum length is %d\n"), chvno, minlen);

          xfree (*pinvalue);
          *pinvalue = ((void*)0);
          return (11);
        }

      rc = iso7816_verify (app->slot, 0x80+chvno,
                           *pinvalue, strlen (*pinvalue));
    }

  if (rc)
    {
      g10_log_error (gettext ("verify CHV%d failed: %s\n"), chvno, g10_errstr ((rc)));
      xfree (*pinvalue);
      *pinvalue = ((void*)0);
      flush_cache_after_error (app);
    }

  return rc;
}




static gpg_error_t
verify_chv2 (app_t app,
             gpg_error_t (*pincb)(void*, const char *, char **),
             void *pincb_arg)
{
  int rc;
  char *pinvalue;

  if (app->did_chv2)
    return 0;

  rc = verify_a_chv (app, pincb, pincb_arg, 2, 0, &pinvalue);
  if (rc)
    return rc;
  app->did_chv2 = 1;

  if (!app->did_chv1 && !app->force_chv1 && pinvalue)
    {




      rc = iso7816_verify (app->slot, 0x81, pinvalue, strlen (pinvalue));
      if ((rc) == 11)
        rc = (1);
      if (rc)
        {
          g10_log_error (gettext ("verify CHV%d failed: %s\n"), 1, g10_errstr ((rc)));
          flush_cache_after_error (app);
        }
      else
        app->did_chv1 = 1;
    }

  xfree (pinvalue);

  return rc;
}




static gpg_error_t
build_enter_admin_pin_prompt (app_t app, char **r_prompt)
{
  void *relptr;
  unsigned char *value;
  size_t valuelen;
  int remaining;
  char *prompt;

  *r_prompt = ((void*)0);

  relptr = get_one_do (app, 0x00C4, &value, &valuelen, ((void*)0));
  if (!relptr || valuelen < 7)
    {
      g10_log_error (gettext ("error retrieving CHV status from card\n"));
      xfree (relptr);
      return (1);
    }
  if (value[6] == 0)
    {
      g10_log_info (gettext ("card is permanently locked!\n"));
      xfree (relptr);
      return (11);
    }
  remaining = value[6];
  xfree (relptr);

  g10_log_info(gettext ("%d Admin PIN attempts remaining before card" " is permanently locked\n"), remaining);


  if (remaining < 3)
    {


      prompt = xtryasprintf (gettext ("|A|Please enter the Admin PIN%%0A" "[remaining attempts: %d]"), remaining);

    }
  else
    prompt = xtrystrdup (gettext ("|A|Please enter the Admin PIN"));

  if (!prompt)
    return (1);

  *r_prompt = prompt;
  return 0;
}



static gpg_error_t
verify_chv3 (app_t app,
             gpg_error_t (*pincb)(void*, const char *, char **),
             void *pincb_arg)
{
  int rc = 0;
# 1700 "app-openpgp.c"
  if (!app->did_chv3)
    {
      iso7816_pininfo_t pininfo;
      int minlen = 8;
      char *prompt;

      memset (&pininfo, 0, sizeof pininfo);
      pininfo.mode = 1;
      pininfo.minlen = minlen;

      rc = build_enter_admin_pin_prompt (app, &prompt);
      if (rc)
        return rc;

      if (!opt.disable_keypad
          && !iso7816_check_keypad (app->slot, 0x20, &pininfo) )
        {

          rc = pincb (pincb_arg, prompt, ((void*)0));
          xfree (prompt);
          prompt = ((void*)0);
          if (rc)
            {
              g10_log_info (gettext ("PIN callback returned error: %s\n"),
                        g10_errstr ((rc)));
              return rc;
            }
          rc = iso7816_verify_kp (app->slot, 0x83, "", 0, &pininfo);

          pincb (pincb_arg, ((void*)0), ((void*)0));
        }
      else
        {
          char *pinvalue;

          rc = pincb (pincb_arg, prompt, &pinvalue);
          xfree (prompt);
          prompt = ((void*)0);
          if (rc)
            {
              g10_log_info (gettext ("PIN callback returned error: %s\n"),
                        g10_errstr ((rc)));
              return rc;
            }

          if (strlen (pinvalue) < minlen)
            {
              g10_log_error (gettext ("PIN for CHV%d is too short;" " minimum length is %d\n"), 3, minlen);

              xfree (pinvalue);
              return (11);
            }

          rc = iso7816_verify (app->slot, 0x83, pinvalue, strlen (pinvalue));
          xfree (pinvalue);
        }

      if (rc)
        {
          g10_log_error (gettext ("verify CHV%d failed: %s\n"), 3, g10_errstr ((rc)));
          flush_cache_after_error (app);
          return rc;
        }
      app->did_chv3 = 1;
    }
  return rc;
}




static gpg_error_t
do_setattr (app_t app, const char *name,
            gpg_error_t (*pincb)(void*, const char *, char **),
            void *pincb_arg,
            const unsigned char *value, size_t valuelen)
{
  gpg_error_t rc;
  int idx;
  static struct {
    const char *name;
    int tag;
    int need_chv;
    int special;
    unsigned int need_v2:1;
  } table[] = {
    { "DISP-NAME", 0x005B, 3 },
    { "LOGIN-DATA", 0x005E, 3, 2 },
    { "DISP-LANG", 0x5F2D, 3 },
    { "DISP-SEX", 0x5F35, 3 },
    { "PUBKEY-URL", 0x5F50, 3 },
    { "CHV-STATUS-1", 0x00C4, 3, 1 },
    { "CA-FPR-1", 0x00CA, 3 },
    { "CA-FPR-2", 0x00CB, 3 },
    { "CA-FPR-3", 0x00CC, 3 },
    { "PRIVATE-DO-1", 0x0101, 2 },
    { "PRIVATE-DO-2", 0x0102, 3 },
    { "PRIVATE-DO-3", 0x0103, 2 },
    { "PRIVATE-DO-4", 0x0104, 3 },
    { "CERT-3", 0x7F21, 3, 0, 1 },
    { "SM-KEY-ENC", 0x00D1, 3, 0, 1 },
    { "SM-KEY-MAC", 0x00D2, 3, 0, 1 },
    { "KEY-ATTR", 0, 0, 3, 1 },
    { ((void*)0), 0 }
  };
  int exmode;

  for (idx=0; table[idx].name && strcmp (table[idx].name, name); idx++)
    ;
  if (!table[idx].name)
    return (1);
  if (table[idx].need_v2 && !app->app_local->extcap.is_v2)
    return (19);

  if (table[idx].special == 3)
    return change_keyattr_from_string (app, pincb, pincb_arg, value, valuelen);

  switch (table[idx].need_chv)
    {
    case 2:
      rc = verify_chv2 (app, pincb, pincb_arg);
      break;
    case 3:
      rc = verify_chv3 (app, pincb, pincb_arg);
      break;
    default:
      rc = 0;
    }
  if (rc)
    return rc;




  flush_cache_item (app, table[idx].tag);

  if (app->app_local->cardcap.ext_lc_le && valuelen > 254)
    exmode = 1;
  else if (app->app_local->cardcap.cmd_chaining && valuelen > 254)
    exmode = -254;
  else
    exmode = 0;
  rc = iso7816_put_data (app->slot, exmode, table[idx].tag, value, valuelen);
  if (rc)
    g10_log_error ("failed to set `%s': %s\n", table[idx].name, g10_errstr ((rc)));

  if (table[idx].special == 1)
    app->force_chv1 = (valuelen && *value == 0);
  else if (table[idx].special == 2)
    parse_login_data (app);

  return rc;
}






static gpg_error_t
do_writecert (app_t app, ctrl_t ctrl,
              const char *certidstr,
              gpg_error_t (*pincb)(void*, const char *, char **),
              void *pincb_arg,
              const unsigned char *certdata, size_t certdatalen)
{
  (void)ctrl;
# 1878 "app-openpgp.c"
  return (1);

}
# 1899 "app-openpgp.c"
static gpg_error_t
do_change_pin (app_t app, ctrl_t ctrl, const char *chvnostr,
               unsigned int flags,
               gpg_error_t (*pincb)(void*, const char *, char **),
               void *pincb_arg)
{
  int rc = 0;
  int chvno = atoi (chvnostr);
  char *resetcode = ((void*)0);
  char *oldpinvalue = ((void*)0);
  char *pinvalue;
  int reset_mode = !!(flags & 1);
  int set_resetcode = 0;

  (void)ctrl;

  if (reset_mode && chvno == 3)
    {
      rc = (1);
      goto leave;
    }

  if (!app->app_local->extcap.is_v2)
    {


      if (reset_mode || chvno == 3)
        {

          app->did_chv3 = 0;
          rc = verify_chv3 (app, pincb, pincb_arg);
          if (rc)
            goto leave;
        }
      else if (chvno == 1 || chvno == 2)
        {


          int save_force = app->force_chv1;

          app->force_chv1 = 0;
          app->did_chv1 = 0;
          app->did_chv2 = 0;
          rc = verify_chv2 (app, pincb, pincb_arg);
          app->force_chv1 = save_force;
          if (rc)
            goto leave;
        }
      else
        {
          rc = (1);
          goto leave;
        }
    }
  else
    {


      if (reset_mode)
        {

          app->did_chv3 = 0;
          rc = verify_chv3 (app, pincb, pincb_arg);
          if (rc)
            goto leave;

          if (chvno == 2)
            set_resetcode = 1;
        }
      else if (chvno == 1 || chvno == 3)
        {
          int minlen = (chvno ==3)? 8 : 6;
          char *promptbuf = ((void*)0);
          const char *prompt;

          if (chvno == 3)
            {
              rc = build_enter_admin_pin_prompt (app, &promptbuf);
              if (rc)
                goto leave;
              prompt = promptbuf;
            }
          else
            prompt = gettext ("||Please enter the PIN");
          rc = pincb (pincb_arg, prompt, &oldpinvalue);
          xfree (promptbuf);
          promptbuf = ((void*)0);
          if (rc)
            {
              g10_log_info (gettext ("PIN callback returned error: %s\n"),
                        g10_errstr ((rc)));
              goto leave;
            }

          if (strlen (oldpinvalue) < minlen)
            {
              g10_log_info (gettext ("PIN for CHV%d is too short;" " minimum length is %d\n"), chvno, minlen);

              rc = (11);
              goto leave;
            }
        }
      else if (chvno == 2)
        {


          void *relptr;
          unsigned char *value;
          size_t valuelen;
          int remaining;
          int minlen = 8;

          relptr = get_one_do (app, 0x00C4, &value, &valuelen, ((void*)0));
          if (!relptr || valuelen < 7)
            {
              g10_log_error (gettext ("error retrieving CHV status from card\n"));
              xfree (relptr);
              rc = (1);
              goto leave;
            }
          remaining = value[5];
          xfree (relptr);
          if (!remaining)
            {
              g10_log_error (gettext ("Reset Code not or not anymore available\n"));
              rc = (11);
              goto leave;
            }

          rc = pincb (pincb_arg,
                      gettext ("||Please enter the Reset Code for the card"),
                      &resetcode);
          if (rc)
            {
              g10_log_info (gettext ("PIN callback returned error: %s\n"),
                        g10_errstr ((rc)));
              goto leave;
            }
          if (strlen (resetcode) < minlen)
            {
              g10_log_info (gettext ("Reset Code is too short; minimum length is %d\n"),
                        minlen);
              rc = (11);
              goto leave;
            }
        }
      else
        {
          rc = (1);
          goto leave;
        }
    }

  if (chvno == 3)
    app->did_chv3 = 0;
  else
    app->did_chv1 = app->did_chv2 = 0;




  rc = pincb (pincb_arg, set_resetcode? gettext ("|RN|New Reset Code") :
              chvno == 3? gettext ("|AN|New Admin PIN") : gettext ("|N|New PIN"),
              &pinvalue);
  if (rc)
    {
      g10_log_error (gettext ("error getting new PIN: %s\n"), g10_errstr ((rc)));
      goto leave;
    }


  if (resetcode)
    {
      char *buffer;

      buffer = xmalloc((strlen (resetcode) + strlen (pinvalue) + 1));
      if (!buffer)
        rc = (1);
      else
        {
          strcpy (stpcpy (buffer, resetcode), pinvalue);
          rc = iso7816_reset_retry_counter_with_rc (app->slot, 0x81,
                                                    buffer, strlen (buffer));
          do { volatile char *_vptr=(volatile char *)(buffer); size_t _vlen=(strlen (buffer)); while(_vlen) { *_vptr=(0); _vptr++; _vlen--; } } while(0);
          xfree (buffer);
        }
    }
  else if (set_resetcode)
    {
      if (strlen (pinvalue) < 8)
        {
          g10_log_error (gettext ("Reset Code is too short; minimum length is %d\n"), 8);
          rc = (11);
        }
      else
        rc = iso7816_put_data (app->slot, 0, 0xD3,
                               pinvalue, strlen (pinvalue));
    }
  else if (reset_mode)
    {
      rc = iso7816_reset_retry_counter (app->slot, 0x81,
                                        pinvalue, strlen (pinvalue));
      if (!rc && !app->app_local->extcap.is_v2)
        rc = iso7816_reset_retry_counter (app->slot, 0x82,
                                          pinvalue, strlen (pinvalue));
    }
  else if (!app->app_local->extcap.is_v2)
    {

      if (chvno == 1 || chvno == 2)
        {
          rc = iso7816_change_reference_data (app->slot, 0x81, ((void*)0), 0,
                                              pinvalue, strlen (pinvalue));
          if (!rc)
            rc = iso7816_change_reference_data (app->slot, 0x82, ((void*)0), 0,
                                                pinvalue, strlen (pinvalue));
        }
      else
        {
          rc = iso7816_change_reference_data (app->slot, 0x80 + chvno, ((void*)0), 0,
                                              pinvalue, strlen (pinvalue));
        }
    }
  else
    {

      ((void)((chvno == 1 || chvno == 3) || (__assert_fail("chvno == 1 || chvno == 3", "app-openpgp.c", 2125, __func__),0)));

      rc = iso7816_change_reference_data (app->slot, 0x80 + chvno,
                                          oldpinvalue, strlen (oldpinvalue),
                                          pinvalue, strlen (pinvalue));
    }

  if (pinvalue)
    {
      do { volatile char *_vptr=(volatile char *)(pinvalue); size_t _vlen=(strlen (pinvalue)); while(_vlen) { *_vptr=(0); _vptr++; _vlen--; } } while(0);
      xfree (pinvalue);
    }
  if (rc)
    flush_cache_after_error (app);

 leave:
  if (resetcode)
    {
      do { volatile char *_vptr=(volatile char *)(resetcode); size_t _vlen=(strlen (resetcode)); while(_vlen) { *_vptr=(0); _vptr++; _vlen--; } } while(0);
      xfree (resetcode);
    }
  if (oldpinvalue)
    {
      do { volatile char *_vptr=(volatile char *)(oldpinvalue); size_t _vlen=(strlen (oldpinvalue)); while(_vlen) { *_vptr=(0); _vptr++; _vlen--; } } while(0);
      xfree (oldpinvalue);
    }
  return rc;
}






static gpg_error_t
does_key_exist (app_t app, int keyidx, int generating, int force)
{
  const unsigned char *fpr;
  unsigned char *buffer;
  size_t buflen, n;
  int i;

  ((void)((keyidx >=0 && keyidx <= 2) || (__assert_fail("keyidx >=0 && keyidx <= 2", "app-openpgp.c", 2167, __func__),0)));

  if (iso7816_get_data (app->slot, 0, 0x006E, &buffer, &buflen))
    {
      g10_log_error (gettext ("error reading application data\n"));
      return (1);
    }
  fpr = find_tlv (buffer, buflen, 0x00C5, &n);
  if (!fpr || n < 60)
    {
      g10_log_error (gettext ("error reading fingerprint DO\n"));
      xfree (buffer);
      return (1);
    }
  fpr += 20*keyidx;
  for (i=0; i < 20 && !fpr[i]; i++)
    ;
  xfree (buffer);
  if (i!=20 && !force)
    {
      g10_log_error (gettext ("key already exists\n"));
      return (42);
    }
  else if (i!=20)
    g10_log_info (gettext ("existing key will be replaced\n"));
  else if (generating)
    g10_log_info (gettext ("generating new key\n"));
  else
    g10_log_info (gettext ("writing new key\n"));
  return 0;
}




static size_t
add_tlv (unsigned char *buffer, unsigned int tag, size_t length)
{
  unsigned char *p = buffer;

  ((void)((tag <= 0xffff) || (__assert_fail("tag <= 0xffff", "app-openpgp.c", 2207, __func__),0)));
  if ( tag > 0xff )
    *p++ = tag >> 8;
  *p++ = tag;
  if (length < 128)
    *p++ = length;
  else if (length < 256)
    {
      *p++ = 0x81;
      *p++ = length;
    }
  else
    {
      if (length > 0xffff)
        length = 0xffff;
      *p++ = 0x82;
      *p++ = length >> 8;
      *p++ = length;
    }

  return p - buffer;
}




static gpg_error_t
build_privkey_template (app_t app, int keyno,
                        const unsigned char *rsa_n, size_t rsa_n_len,
                        const unsigned char *rsa_e, size_t rsa_e_len,
                        const unsigned char *rsa_p, size_t rsa_p_len,
                        const unsigned char *rsa_q, size_t rsa_q_len,
                        unsigned char **result, size_t *resultlen)
{
  size_t rsa_e_reqlen;
  unsigned char privkey[7*(1+3)];
  size_t privkey_len;
  unsigned char exthdr[2+2+3];
  size_t exthdr_len;
  unsigned char suffix[2+3];
  size_t suffix_len;
  unsigned char *tp;
  size_t datalen;
  unsigned char *template;
  size_t template_size;

  *result = ((void*)0);
  *resultlen = 0;

  switch (app->app_local->keyattr[keyno].format)
    {
    case RSA_STD:
    case RSA_STD_N:
      break;
    case RSA_CRT:
    case RSA_CRT_N:
      return (19);

    default:
      return (45);
    }


  rsa_e_reqlen = app->app_local->keyattr[keyno].e_bits/8;
  ((void)((rsa_e_len <= rsa_e_reqlen) || (__assert_fail("rsa_e_len <= rsa_e_reqlen", "app-openpgp.c", 2271, __func__),0)));


  datalen = 0;
  tp = privkey;

  tp += add_tlv (tp, 0x91, rsa_e_reqlen);
  datalen += rsa_e_reqlen;

  tp += add_tlv (tp, 0x92, rsa_p_len);
  datalen += rsa_p_len;

  tp += add_tlv (tp, 0x93, rsa_q_len);
  datalen += rsa_q_len;

  if (app->app_local->keyattr[keyno].format == RSA_STD_N
      || app->app_local->keyattr[keyno].format == RSA_CRT_N)
    {
      tp += add_tlv (tp, 0x97, rsa_n_len);
      datalen += rsa_n_len;
    }
  privkey_len = tp - privkey;


  tp = exthdr;
  *tp++ = keyno ==0 ? 0xb6 : keyno == 1? 0xb8 : 0xa4;
  *tp++ = 0;
  tp += add_tlv (tp, 0x7f48, privkey_len);
  exthdr_len = tp - exthdr;


  tp = suffix;
  tp += add_tlv (tp, 0x5f48, datalen);
  suffix_len = tp - suffix;


  template_size = (1 + 3
                   + exthdr_len
                   + privkey_len
                   + suffix_len
                   + datalen);
  tp = template = xmalloc_secure((template_size));
  if (!template)
    return (1);

  tp += add_tlv (tp, 0x4d, exthdr_len + privkey_len + suffix_len + datalen);
  memcpy (tp, exthdr, exthdr_len);
  tp += exthdr_len;
  memcpy (tp, privkey, privkey_len);
  tp += privkey_len;
  memcpy (tp, suffix, suffix_len);
  tp += suffix_len;

  memcpy (tp, rsa_e, rsa_e_len);
  if (rsa_e_len < rsa_e_reqlen)
    {

      memmove (tp + rsa_e_reqlen - rsa_e_len, tp, rsa_e_len);
      memset (tp, 0, rsa_e_reqlen - rsa_e_len);
    }
  tp += rsa_e_reqlen;

  memcpy (tp, rsa_p, rsa_p_len);
  tp += rsa_p_len;

  memcpy (tp, rsa_q, rsa_q_len);
  tp += rsa_q_len;

  if (app->app_local->keyattr[keyno].format == RSA_STD_N
      || app->app_local->keyattr[keyno].format == RSA_CRT_N)
    {
      memcpy (tp, rsa_n, rsa_n_len);
      tp += rsa_n_len;
    }



  ((void)((tp - template <= template_size) || (__assert_fail("tp - template <= template_size", "app-openpgp.c", 2348, __func__),0)));

  *result = template;
  *resultlen = tp - template;
  return 0;
}




static gpg_error_t
change_keyattr (app_t app, int keyno, unsigned int nbits,
                gpg_error_t (*pincb)(void*, const char *, char **),
                void *pincb_arg)
{
  gpg_error_t err;
  unsigned char *buffer;
  size_t buflen;
  void *relptr;

  ((void)((keyno >=0 && keyno <= 2) || (__assert_fail("keyno >=0 && keyno <= 2", "app-openpgp.c", 2368, __func__),0)));

  if (nbits > 3072)
    return (1);


  relptr = get_one_do (app, 0xC1+keyno, &buffer, &buflen, ((void*)0));
  if (!relptr)
    return (1);
  if (buflen < 6 || buffer[0] != 1)
    {

      xfree (relptr);
      return (1);
    }





  nbits = ((nbits + 31) / 32) * 32;
  buffer[1] = (nbits >> 8);
  buffer[2] = nbits;


  err = verify_chv3 (app, pincb, pincb_arg);
  if (err)
    {
      xfree (relptr);
      return err;
    }


  err = iso7816_put_data (app->slot, 0, 0xC1+keyno, buffer, buflen);
  xfree (relptr);
  if (err)
    g10_log_error ("error changing size of key %d to %u bits\n", keyno+1, nbits);
  else
    g10_log_info ("size of key %d changed to %u bits\n", keyno+1, nbits);
  flush_cache (app);
  parse_algorithm_attribute (app, keyno);
  app->did_chv1 = 0;
  app->did_chv2 = 0;
  app->did_chv3 = 0;
  return err;
}




static gpg_error_t
change_keyattr_from_string (app_t app,
                            gpg_error_t (*pincb)(void*, const char *, char **),
                            void *pincb_arg,
                            const void *value, size_t valuelen)
{
  gpg_error_t err;
  char *string;
  int keyno, algo;
  unsigned int nbits;



  string = xmalloc((valuelen+1));
  if (!string)
    return (1);
  memcpy (string, value, valuelen);
  string[valuelen] = 0;




  if (sscanf (string, " --force %d %d %u", &keyno, &algo, &nbits) != 3)
    err = (1);
  else if (keyno < 1 || keyno > 3)
    err = (1);
  else if (algo != 1)
    err = (4);
  else if (nbits < 1024)
    err = (45);
  else
    err = change_keyattr (app, keyno-1, nbits, pincb, pincb_arg);

  xfree (string);
  return err;
}
# 2463 "app-openpgp.c"
static gpg_error_t
do_writekey (app_t app, ctrl_t ctrl,
             const char *keyid, unsigned int flags,
             gpg_error_t (*pincb)(void*, const char *, char **),
             void *pincb_arg,
             const unsigned char *keydata, size_t keydatalen)
{
  gpg_error_t err;
  int force = (flags & 1);
  int keyno;
  const unsigned char *buf, *tok;
  size_t buflen, toklen;
  int depth, last_depth1, last_depth2;
  const unsigned char *rsa_n = ((void*)0);
  const unsigned char *rsa_e = ((void*)0);
  const unsigned char *rsa_p = ((void*)0);
  const unsigned char *rsa_q = ((void*)0);
  size_t rsa_n_len, rsa_e_len, rsa_p_len, rsa_q_len;
  unsigned int nbits;
  unsigned int maxbits;
  unsigned char *template = ((void*)0);
  unsigned char *tp;
  size_t template_len;
  unsigned char fprbuf[20];
  u32 created_at = 0;

  (void)ctrl;

  if (!strcmp (keyid, "OPENPGP.1"))
    keyno = 0;
  else if (!strcmp (keyid, "OPENPGP.2"))
    keyno = 1;
  else if (!strcmp (keyid, "OPENPGP.3"))
    keyno = 2;
  else
    return (1);

  err = does_key_exist (app, keyno, 0, force);
  if (err)
    return err;





  buf = keydata;
  buflen = keydatalen;
  depth = 0;
  if ((err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen)))
    goto leave;
  if ((err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen)))
    goto leave;
  if (!tok || toklen != 11 || memcmp ("private-key", tok, toklen))
    {
      if (!tok)
        ;
      else if (toklen == 21 && !memcmp ("protected-private-key", tok, toklen))
        g10_log_info ("protected-private-key passed to writekey\n");
      else if (toklen == 20 && !memcmp ("shadowed-private-key", tok, toklen))
        g10_log_info ("shadowed-private-key passed to writekey\n");
      err = (7);
      goto leave;
    }
  if ((err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen)))
    goto leave;
  if ((err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen)))
    goto leave;
  if (!tok || toklen != 3 || memcmp ("rsa", tok, toklen))
    {
      err = (4);
      goto leave;
    }
  last_depth1 = depth;
  while (!(err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen))
         && depth && depth >= last_depth1)
    {
      if (tok)
        {
          err = (45);
          goto leave;
        }
      if ((err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen)))
        goto leave;
      if (tok && toklen == 1)
        {
          const unsigned char **mpi;
          size_t *mpi_len;

          switch (*tok)
            {
            case 'n': mpi = &rsa_n; mpi_len = &rsa_n_len; break;
            case 'e': mpi = &rsa_e; mpi_len = &rsa_e_len; break;
            case 'p': mpi = &rsa_p; mpi_len = &rsa_p_len; break;
            case 'q': mpi = &rsa_q; mpi_len = &rsa_q_len;break;
            default: mpi = ((void*)0); mpi_len = ((void*)0); break;
            }
          if (mpi && *mpi)
            {
              err = (45);
              goto leave;
            }
          if ((err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen)))
            goto leave;
          if (tok && mpi)
            {

              for (;toklen && !*tok; toklen--, tok++)
                ;
              *mpi = tok;
              *mpi_len = toklen;
            }
        }

      last_depth2 = depth;
      while (!(err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen))
             && depth && depth >= last_depth2)
        ;
      if (err)
        goto leave;
    }

  last_depth1 = depth;
  while (!(err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen))
         && depth && depth >= last_depth1)
    {
      if (tok)
        {
          err = (45);
          goto leave;
        }
      if ((err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen)))
        goto leave;
      if (tok && toklen == 10 && !memcmp ("created-at", tok, toklen))
        {
          if ((err = parse_sexp (&buf,&buflen,&depth,&tok,&toklen)))
            goto leave;
          if (tok)
            {
              for (created_at=0; toklen && *tok && *tok >= '0' && *tok <= '9';
                   tok++, toklen--)
                created_at = created_at*10 + (*tok - '0');
            }
        }

      last_depth2 = depth;
      while (!(err = parse_sexp (&buf, &buflen, &depth, &tok, &toklen))
             && depth && depth >= last_depth2)
        ;
      if (err)
        goto leave;
    }




  if (!created_at)
    {
      g10_log_error (gettext ("creation timestamp missing\n"));
      err = (45);
      goto leave;
    }

  maxbits = app->app_local->keyattr[keyno].n_bits;
  nbits = rsa_n? count_bits (rsa_n, rsa_n_len) : 0;
  if (opt.verbose)
    g10_log_info ("RSA modulus size is %u bits (%u bytes)\n",
              nbits, (unsigned int)rsa_n_len);
  if (nbits && nbits != maxbits
      && app->app_local->extcap.algo_attr_change)
    {

      err = change_keyattr (app, keyno, nbits, pincb, pincb_arg);
      if (!err)
        maxbits = app->app_local->keyattr[keyno].n_bits;
    }
  if (nbits != maxbits)
    {
      g10_log_error (gettext ("RSA modulus missing or not of size %d bits\n"),
                 (int)maxbits);
      err = (7);
      goto leave;
    }

  maxbits = app->app_local->keyattr[keyno].e_bits;
  if (maxbits > 32 && !app->app_local->extcap.is_v2)
    maxbits = 32;
  nbits = rsa_e? count_bits (rsa_e, rsa_e_len) : 0;
  if (nbits < 2 || nbits > maxbits)
    {
      g10_log_error (gettext ("RSA public exponent missing or larger than %d bits\n"),
                 (int)maxbits);
      err = (7);
      goto leave;
    }

  maxbits = app->app_local->keyattr[keyno].n_bits/2;
  nbits = rsa_p? count_bits (rsa_p, rsa_p_len) : 0;
  if (nbits != maxbits)
    {
      g10_log_error (gettext ("RSA prime %s missing or not of size %d bits\n"),
                 "P", (int)maxbits);
      err = (7);
      goto leave;
    }
  nbits = rsa_q? count_bits (rsa_q, rsa_q_len) : 0;
  if (nbits != maxbits)
    {
      g10_log_error (gettext ("RSA prime %s missing or not of size %d bits\n"),
                 "Q", (int)maxbits);
      err = (7);
      goto leave;
    }


  xfree (app->app_local->pk[keyno].key);
  app->app_local->pk[keyno].key = ((void*)0);
  app->app_local->pk[keyno].keylen = 0;
  app->app_local->pk[keyno].read_done = 0;


  if (app->app_local->extcap.is_v2)
    {


      int exmode;

      err = build_privkey_template (app, keyno,
                                    rsa_n, rsa_n_len,
                                    rsa_e, rsa_e_len,
                                    rsa_p, rsa_p_len,
                                    rsa_q, rsa_q_len,
                                    &template, &template_len);
      if (err)
        goto leave;


      err = verify_chv3 (app, pincb, pincb_arg);
      if (err)
        goto leave;


      if (app->app_local->cardcap.ext_lc_le && template_len > 254)
        exmode = 1;
      else if (app->app_local->cardcap.cmd_chaining && template_len > 254)
        exmode = -254;
      else
        exmode = 0;
      err = iso7816_put_data_odd (app->slot, exmode, 0x3fff,
                                  template, template_len);
    }
  else
    {






      ((void)((rsa_e_len <= 4) || (__assert_fail("rsa_e_len <= 4", "app-openpgp.c", 2721, __func__),0)));
      template_len = (1 + 1 + 4
                      + 1 + 1 + rsa_p_len
                      + 1 + 1 + rsa_q_len);
      template = tp = xmalloc_secure((template_len));
      if (!template)
        {
          err = (1);
          goto leave;
        }
      *tp++ = 0xC0;
      *tp++ = 4;
      memcpy (tp, rsa_e, rsa_e_len);
      if (rsa_e_len < 4)
        {

          memmove (tp+4-rsa_e_len, tp, rsa_e_len);
          memset (tp, 0, 4-rsa_e_len);
        }
      tp += 4;

      *tp++ = 0xC1;
      *tp++ = rsa_p_len;
      memcpy (tp, rsa_p, rsa_p_len);
      tp += rsa_p_len;

      *tp++ = 0xC2;
      *tp++ = rsa_q_len;
      memcpy (tp, rsa_q, rsa_q_len);
      tp += rsa_q_len;

      ((void)((tp - template == template_len) || (__assert_fail("tp - template == template_len", "app-openpgp.c", 2752, __func__),0)));


      err = verify_chv3 (app, pincb, pincb_arg);
      if (err)
        goto leave;


      err = iso7816_put_data (app->slot, 0,
                              (app->card_version > 0x0007? 0xE0:0xE9)+keyno,
                              template, template_len);
    }
  if (err)
    {
      g10_log_error (gettext ("failed to store the key: %s\n"), g10_errstr ((err)));
      goto leave;
    }

  err = store_fpr (app, keyno, created_at,
                  rsa_n, rsa_n_len, rsa_e, rsa_e_len,
                  fprbuf, app->card_version);
  if (err)
    goto leave;


 leave:
  xfree (template);
  return err;
}



static gpg_error_t
do_genkey (app_t app, ctrl_t ctrl, const char *keynostr, unsigned int flags,
           time_t createtime,
           gpg_error_t (*pincb)(void*, const char *, char **),
           void *pincb_arg)
{
  int rc;
  char numbuf[30];
  unsigned char fprbuf[20];
  const unsigned char *keydata, *m, *e;
  unsigned char *buffer = ((void*)0);
  size_t buflen, keydatalen, mlen, elen;
  time_t created_at;
  int keyno = atoi (keynostr);
  int force = (flags & 1);
  time_t start_at;
  int exmode;
  int le_value;
  unsigned int keybits;

  if (keyno < 1 || keyno > 3)
    return (1);
  keyno--;



  flush_cache (app);


  xfree (app->app_local->pk[keyno].key);
  app->app_local->pk[keyno].key = ((void*)0);
  app->app_local->pk[keyno].keylen = 0;
  app->app_local->pk[keyno].read_done = 0;


  rc = does_key_exist (app, keyno, 1, force);
  if (rc)
    return rc;





  keybits = app->app_local->keyattr[keyno].n_bits;
  if (keybits > 3072)
    return (1);


  rc = verify_chv3 (app, pincb, pincb_arg);
  if (rc)
    goto leave;



  if (app->app_local->cardcap.ext_lc_le && keybits > 1900)
    {
      exmode = 1;
      le_value = app->app_local->extcap.max_rsp_data;



    }
  else
    {
      exmode = 0;
      le_value = 256;
    }

  g10_log_info (gettext ("please wait while key is being generated ...\n"));
  start_at = time (((void*)0));
  rc = iso7816_generate_keypair


    (app->slot, exmode,
     (const unsigned char*)(keyno == 0? "\xB6" :
                            keyno == 1? "\xB8" : "\xA4"), 2,
     le_value,
     &buffer, &buflen);
  if (rc)
    {
      rc = (1);
      g10_log_error (gettext ("generating key failed\n"));
      goto leave;
    }
  g10_log_info (gettext ("key generation completed (%d seconds)\n"),
            (int)(time (((void*)0)) - start_at));

  keydata = find_tlv (buffer, buflen, 0x7F49, &keydatalen);
  if (!keydata)
    {
      rc = (1);
      g10_log_error (gettext ("response does not contain the public key data\n"));
      goto leave;
    }

  m = find_tlv (keydata, keydatalen, 0x0081, &mlen);
  if (!m)
    {
      rc = (1);
      g10_log_error (gettext ("response does not contain the RSA modulus\n"));
      goto leave;
    }

  send_key_data (ctrl, "n", m, mlen);

  e = find_tlv (keydata, keydatalen, 0x0082, &elen);
  if (!e)
    {
      rc = (1);
      g10_log_error (gettext ("response does not contain the RSA public exponent\n"));
      goto leave;
    }

  send_key_data (ctrl, "e", e, elen);

  created_at = createtime? createtime : make_timestamp ();
  sprintf (numbuf, "%lu", (unsigned long)created_at);
  send_status_info (ctrl, "KEY-CREATED-AT",
                    numbuf, (size_t)strlen(numbuf), ((void*)0), 0);

  rc = store_fpr (app, keyno, (u32)created_at,
                  m, mlen, e, elen, fprbuf, app->card_version);
  if (rc)
    goto leave;
  send_fpr_if_not_null (ctrl, "KEY-FPR", -1, fprbuf);


 leave:
  xfree (buffer);
  return rc;
}


static unsigned long
convert_sig_counter_value (const unsigned char *value, size_t valuelen)
{
  unsigned long ul;

  if (valuelen == 3 )
    ul = (value[0] << 16) | (value[1] << 8) | value[2];
  else
    {
      g10_log_error (gettext ("invalid structure of OpenPGP card (DO 0x93)\n"));
      ul = 0;
    }
  return ul;
}

static unsigned long
get_sig_counter (app_t app)
{
  void *relptr;
  unsigned char *value;
  size_t valuelen;
  unsigned long ul;

  relptr = get_one_do (app, 0x0093, &value, &valuelen, ((void*)0));
  if (!relptr)
    return 0;
  ul = convert_sig_counter_value (value, valuelen);
  xfree (relptr);
  return ul;
}

static gpg_error_t
compare_fingerprint (app_t app, int keyno, unsigned char *sha1fpr)
{
  const unsigned char *fpr;
  unsigned char *buffer;
  size_t buflen, n;
  int rc, i;

  ((void)((keyno >= 1 && keyno <= 3) || (__assert_fail("keyno >= 1 && keyno <= 3", "app-openpgp.c", 2956, __func__),0)));

  rc = get_cached_data (app, 0x006E, &buffer, &buflen, 0, 0);
  if (rc)
    {
      g10_log_error (gettext ("error reading application data\n"));
      return (1);
    }
  fpr = find_tlv (buffer, buflen, 0x00C5, &n);
  if (!fpr || n != 60)
    {
      xfree (buffer);
      g10_log_error (gettext ("error reading fingerprint DO\n"));
      return (1);
    }
  fpr += (keyno-1)*20;
  for (i=0; i < 20; i++)
    if (sha1fpr[i] != fpr[i])
      {
        xfree (buffer);
        g10_log_info (gettext ("fingerprint on card does not match requested one\n"));
        return (18);
      }
  xfree (buffer);
  return 0;
}







static gpg_error_t
check_against_given_fingerprint (app_t app, const char *fpr, int keyno)
{
  unsigned char tmp[20];
  const char *s;
  int n;

  for (s=fpr, n=0; ((*(s) >= '0' && *(s) <= '9') || (*(s) >= 'A' && *(s) <= 'F') || (*(s) >= 'a' && *(s) <= 'f')); s++, n++)
    ;
  if (n != 40)
    return (1);
  else if (!*s)
    ;
  else
    return (1);

  for (s=fpr, n=0; n < 20; s += 2, n++)
        tmp[n] = (((*(s) <= '9'? (*(s)- '0'): *(s) <= 'F'? (*(s)-'A'+10):(*(s)-'a'+10)) * 16) + (*((s)+1) <= '9'? (*((s)+1)- '0'): *((s)+1) <= 'F'? (*((s)+1)-'A'+10):(*((s)+1)-'a'+10)));
  return compare_fingerprint (app, keyno, tmp);
}
# 3024 "app-openpgp.c"
static gpg_error_t
do_sign (app_t app, const char *keyidstr, int hashalgo,
         gpg_error_t (*pincb)(void*, const char *, char **),
         void *pincb_arg,
         const void *indata, size_t indatalen,
         unsigned char **outdata, size_t *outdatalen )
{
  static unsigned char rmd160_prefix[15] =
    { 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x24, 0x03,
      0x02, 0x01, 0x05, 0x00, 0x04, 0x14 };
  static unsigned char sha1_prefix[15] =
    { 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03,
      0x02, 0x1a, 0x05, 0x00, 0x04, 0x14 };
  static unsigned char sha224_prefix[19] =
    { 0x30, 0x2D, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48,
      0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04,
      0x1C };
  static unsigned char sha256_prefix[19] =
    { 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
      0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
      0x00, 0x04, 0x20 };
  static unsigned char sha384_prefix[19] =
    { 0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
      0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05,
      0x00, 0x04, 0x30 };
  static unsigned char sha512_prefix[19] =
    { 0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
      0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
      0x00, 0x04, 0x40 };
  int rc;
  unsigned char data[19+64];
  size_t datalen;
  unsigned char tmp_sn[20];
  const char *s;
  int n;
  const char *fpr = ((void*)0);
  unsigned long sigcount;
  int use_auth = 0;
  int exmode, le_value;

  if (!keyidstr || !*keyidstr)
    return (45);
# 3078 "app-openpgp.c"
  if (indatalen == 20)
    ;
  else if (hashalgo == 2 && (1) && indatalen == sizeof sha1_prefix + (20) && !memcmp (indata, sha1_prefix, sizeof sha1_prefix)) { indata = (const char*)indata + sizeof sha1_prefix; indatalen -= sizeof sha1_prefix; }
  else if (hashalgo == 3 && (1) && indatalen == sizeof rmd160_prefix + (20) && !memcmp (indata, rmd160_prefix, sizeof rmd160_prefix)) { indata = (const char*)indata + sizeof rmd160_prefix; indatalen -= sizeof rmd160_prefix; }
  else if (hashalgo == 11 && (app->app_local->extcap.is_v2) && indatalen == sizeof sha224_prefix + (28) && !memcmp (indata, sha224_prefix, sizeof sha224_prefix)) { indata = (const char*)indata + sizeof sha224_prefix; indatalen -= sizeof sha224_prefix; }
  else if (hashalgo == 8 && (app->app_local->extcap.is_v2) && indatalen == sizeof sha256_prefix + (32) && !memcmp (indata, sha256_prefix, sizeof sha256_prefix)) { indata = (const char*)indata + sizeof sha256_prefix; indatalen -= sizeof sha256_prefix; }
  else if (hashalgo == 9 && (app->app_local->extcap.is_v2) && indatalen == sizeof sha384_prefix + (48) && !memcmp (indata, sha384_prefix, sizeof sha384_prefix)) { indata = (const char*)indata + sizeof sha384_prefix; indatalen -= sizeof sha384_prefix; }
  else if (hashalgo == 10 && (app->app_local->extcap.is_v2) && indatalen == sizeof sha512_prefix + (64) && !memcmp (indata, sha512_prefix, sizeof sha512_prefix)) { indata = (const char*)indata + sizeof sha512_prefix; indatalen -= sizeof sha512_prefix; }
  else if ((indatalen == 28 || indatalen == 32
            || indatalen == 48 || indatalen ==64)
           && app->app_local->extcap.is_v2)
    ;
  else
    {
      g10_log_error (gettext ("card does not support digest algorithm %s\n"),
                 gcry_md_algo_name (hashalgo));

      return (45);
    }



  if (!strcmp (keyidstr, "OPENPGP.1"))
    ;
  else if (!strcmp (keyidstr, "OPENPGP.3"))
    use_auth = 1;
  else if (strlen (keyidstr) < 32 || strncmp (keyidstr, "D27600012401", 12))
    return (1);
  else
    {
      for (s=keyidstr, n=0; ((*(s) >= '0' && *(s) <= '9') || (*(s) >= 'A' && *(s) <= 'F') || (*(s) >= 'a' && *(s) <= 'f')); s++, n++)
 ;
      if (n != 32)
 return (1);
      else if (!*s)
 ;
      else if (*s == '/')
 fpr = s + 1;
      else
 return (1);

      for (s=keyidstr, n=0; n < 16; s += 2, n++)
 tmp_sn[n] = (((*(s) <= '9'? (*(s)- '0'): *(s) <= 'F'? (*(s)-'A'+10):(*(s)-'a'+10)) * 16) + (*((s)+1) <= '9'? (*((s)+1)- '0'): *((s)+1) <= 'F'? (*((s)+1)-'A'+10):(*((s)+1)-'a'+10)));

      if (app->serialnolen != 16)
 return (1);
      if (memcmp (app->serialno, tmp_sn, 16))
 return (1);
    }







  rc = fpr? check_against_given_fingerprint (app, fpr, 1) : 0;
  if (rc)
    return rc;
# 3148 "app-openpgp.c"
  if (hashalgo == 2 && (1) ) { datalen = sizeof sha1_prefix + indatalen; ((void)((datalen <= sizeof data) || (__assert_fail("datalen <= sizeof data", "app-openpgp.c", 3148, __func__),0))); memcpy (data, sha1_prefix, sizeof sha1_prefix); memcpy (data + sizeof sha1_prefix, indata, indatalen); }
  else if (hashalgo == 3 && (1) ) { datalen = sizeof rmd160_prefix + indatalen; ((void)((datalen <= sizeof data) || (__assert_fail("datalen <= sizeof data", "app-openpgp.c", 3149, __func__),0))); memcpy (data, rmd160_prefix, sizeof rmd160_prefix); memcpy (data + sizeof rmd160_prefix, indata, indatalen); }
  else if (hashalgo == 11 && (app->app_local->extcap.is_v2) ) { datalen = sizeof sha224_prefix + indatalen; ((void)((datalen <= sizeof data) || (__assert_fail("datalen <= sizeof data", "app-openpgp.c", 3150, __func__),0))); memcpy (data, sha224_prefix, sizeof sha224_prefix); memcpy (data + sizeof sha224_prefix, indata, indatalen); }
  else if (hashalgo == 8 && (app->app_local->extcap.is_v2) ) { datalen = sizeof sha256_prefix + indatalen; ((void)((datalen <= sizeof data) || (__assert_fail("datalen <= sizeof data", "app-openpgp.c", 3151, __func__),0))); memcpy (data, sha256_prefix, sizeof sha256_prefix); memcpy (data + sizeof sha256_prefix, indata, indatalen); }
  else if (hashalgo == 9 && (app->app_local->extcap.is_v2) ) { datalen = sizeof sha384_prefix + indatalen; ((void)((datalen <= sizeof data) || (__assert_fail("datalen <= sizeof data", "app-openpgp.c", 3152, __func__),0))); memcpy (data, sha384_prefix, sizeof sha384_prefix); memcpy (data + sizeof sha384_prefix, indata, indatalen); }
  else if (hashalgo == 10 && (app->app_local->extcap.is_v2) ) { datalen = sizeof sha512_prefix + indatalen; ((void)((datalen <= sizeof data) || (__assert_fail("datalen <= sizeof data", "app-openpgp.c", 3153, __func__),0))); memcpy (data, sha512_prefix, sizeof sha512_prefix); memcpy (data + sizeof sha512_prefix, indata, indatalen); }
  else
    return (4);



  if (use_auth)
    {
      return do_auth (app, "OPENPGP.3", pincb, pincb_arg,
                      data, datalen,
                      outdata, outdatalen);
    }


  sigcount = get_sig_counter (app);
  g10_log_info (gettext ("signatures created so far: %lu\n"), sigcount);


  if (!app->did_chv1 || app->force_chv1 )
    {
      char *pinvalue;

      rc = verify_a_chv (app, pincb, pincb_arg, 1, sigcount, &pinvalue);
      if (rc)
        return rc;

      app->did_chv1 = 1;






      if (!app->did_chv2 && pinvalue && !app->app_local->extcap.is_v2)
        {
          rc = iso7816_verify (app->slot, 0x82, pinvalue, strlen (pinvalue));
          if ((rc) == 11)
            rc = (1);
          if (rc)
            {
              g10_log_error (gettext ("verify CHV%d failed: %s\n"), 2, g10_errstr ((rc)));
              xfree (pinvalue);
              flush_cache_after_error (app);
              return rc;
            }
          app->did_chv2 = 1;
        }
      xfree (pinvalue);
    }


  if (app->app_local->cardcap.ext_lc_le)
    {
      exmode = 1;
      le_value = app->app_local->extcap.max_rsp_data;
    }
  else
    {
      exmode = 0;
      le_value = 0;
    }
  rc = iso7816_compute_ds (app->slot, exmode, data, datalen, le_value,
                           outdata, outdatalen);
  return rc;
}
# 3229 "app-openpgp.c"
static gpg_error_t
do_auth (app_t app, const char *keyidstr,
         gpg_error_t (*pincb)(void*, const char *, char **),
         void *pincb_arg,
         const void *indata, size_t indatalen,
         unsigned char **outdata, size_t *outdatalen )
{
  int rc;
  unsigned char tmp_sn[20];
  const char *s;
  int n;
  const char *fpr = ((void*)0);

  if (!keyidstr || !*keyidstr)
    return (45);
  if (indatalen > 101)
    return (45);


  if (!strcmp (keyidstr, "OPENPGP.3"))
    ;
  else if (strlen (keyidstr) < 32 || strncmp (keyidstr, "D27600012401", 12))
    return (1);
  else
    {
      for (s=keyidstr, n=0; ((*(s) >= '0' && *(s) <= '9') || (*(s) >= 'A' && *(s) <= 'F') || (*(s) >= 'a' && *(s) <= 'f')); s++, n++)
        ;
      if (n != 32)
        return (1);
      else if (!*s)
        ;
      else if (*s == '/')
        fpr = s + 1;
      else
        return (1);

      for (s=keyidstr, n=0; n < 16; s += 2, n++)
        tmp_sn[n] = (((*(s) <= '9'? (*(s)- '0'): *(s) <= 'F'? (*(s)-'A'+10):(*(s)-'a'+10)) * 16) + (*((s)+1) <= '9'? (*((s)+1)- '0'): *((s)+1) <= 'F'? (*((s)+1)-'A'+10):(*((s)+1)-'a'+10)));

      if (app->serialnolen != 16)
        return (1);
      if (memcmp (app->serialno, tmp_sn, 16))
        return (1);
    }







  rc = fpr? check_against_given_fingerprint (app, fpr, 3) : 0;
  if (rc)
    return rc;

  rc = verify_chv2 (app, pincb, pincb_arg);
  if (!rc)
    {
      int exmode, le_value;

      if (app->app_local->cardcap.ext_lc_le)
        {
          exmode = 1;
          le_value = app->app_local->extcap.max_rsp_data;
        }
      else
        {
          exmode = 0;
          le_value = 0;
        }
      rc = iso7816_internal_authenticate (app->slot, exmode,
                                          indata, indatalen, le_value,
                                          outdata, outdatalen);
    }
  return rc;
}


static gpg_error_t
do_decipher (app_t app, const char *keyidstr,
             gpg_error_t (*pincb)(void*, const char *, char **),
             void *pincb_arg,
             const void *indata, size_t indatalen,
             unsigned char **outdata, size_t *outdatalen )
{
  int rc;
  unsigned char tmp_sn[20];
  const char *s;
  int n;
  const char *fpr = ((void*)0);
  int exmode, le_value;

  if (!keyidstr || !*keyidstr || !indatalen)
    return (45);


  if (!strcmp (keyidstr, "OPENPGP.2"))
    ;
  else if (strlen (keyidstr) < 32 || strncmp (keyidstr, "D27600012401", 12))
    return (1);
  else
    {
      for (s=keyidstr, n=0; ((*(s) >= '0' && *(s) <= '9') || (*(s) >= 'A' && *(s) <= 'F') || (*(s) >= 'a' && *(s) <= 'f')); s++, n++)
 ;
      if (n != 32)
 return (1);
      else if (!*s)
 ;
      else if (*s == '/')
 fpr = s + 1;
      else
 return (1);

      for (s=keyidstr, n=0; n < 16; s += 2, n++)
 tmp_sn[n] = (((*(s) <= '9'? (*(s)- '0'): *(s) <= 'F'? (*(s)-'A'+10):(*(s)-'a'+10)) * 16) + (*((s)+1) <= '9'? (*((s)+1)- '0'): *((s)+1) <= 'F'? (*((s)+1)-'A'+10):(*((s)+1)-'a'+10)));

      if (app->serialnolen != 16)
 return (1);
      if (memcmp (app->serialno, tmp_sn, 16))
 return (1);
    }






  rc = fpr? check_against_given_fingerprint (app, fpr, 2) : 0;
  if (rc)
    return rc;

  rc = verify_chv2 (app, pincb, pincb_arg);
  if (!rc)
    {
      size_t fixuplen;
      unsigned char *fixbuf = ((void*)0);
      int padind = 0;
# 3374 "app-openpgp.c"
      if (indatalen >= (128-16) && indatalen < 128)
        fixuplen = 128 - indatalen;
      else if (indatalen >= (192-16) && indatalen < 192)
        fixuplen = 192 - indatalen;
      else if (indatalen >= (256-16) && indatalen < 256)
        fixuplen = 256 - indatalen;
      else if (indatalen >= (384-16) && indatalen < 384)
        fixuplen = 384 - indatalen;
      else
        fixuplen = 0;

      if (fixuplen)
        {



          fixuplen++;

          fixbuf = xmalloc((fixuplen + indatalen));
          if (!fixbuf)
            return (1);

          memset (fixbuf, 0, fixuplen);
          memcpy (fixbuf+fixuplen, indata, indatalen);
          indata = fixbuf;
          indatalen = fixuplen + indatalen;
          padind = -1;
        }

      if (app->app_local->cardcap.ext_lc_le && indatalen > 254 )
        {
          exmode = 1;
          le_value = app->app_local->extcap.max_rsp_data;
        }
      else if (app->app_local->cardcap.cmd_chaining && indatalen > 254)
        {
          exmode = -254;
          le_value = 0;
        }
      else
        exmode = le_value = 0;

      rc = iso7816_decipher (app->slot, exmode,
                             indata, indatalen, le_value, padind,
                             outdata, outdatalen);
      xfree (fixbuf);
    }

  return rc;
}
# 3436 "app-openpgp.c"
static gpg_error_t
do_check_pin (app_t app, const char *keyidstr,
              gpg_error_t (*pincb)(void*, const char *, char **),
              void *pincb_arg)
{
  unsigned char tmp_sn[20];
  const char *s;
  int n;
  int admin_pin = 0;

  if (!keyidstr || !*keyidstr)
    return (45);


  if (strlen (keyidstr) < 32 || strncmp (keyidstr, "D27600012401", 12))
    return (1);

  for (s=keyidstr, n=0; ((*(s) >= '0' && *(s) <= '9') || (*(s) >= 'A' && *(s) <= 'F') || (*(s) >= 'a' && *(s) <= 'f')); s++, n++)
    ;
  if (n != 32)
    return (1);
  else if (!*s)
    ;
  else if (*s == '/')
    ;
  else if (!strcmp (s, "[CHV3]") )
    admin_pin = 1;
  else
    return (1);

  for (s=keyidstr, n=0; n < 16; s += 2, n++)
    tmp_sn[n] = (((*(s) <= '9'? (*(s)- '0'): *(s) <= 'F'? (*(s)-'A'+10):(*(s)-'a'+10)) * 16) + (*((s)+1) <= '9'? (*((s)+1)- '0'): *((s)+1) <= 'F'? (*((s)+1)-'A'+10):(*((s)+1)-'a'+10)));

  if (app->serialnolen != 16)
    return (1);
  if (memcmp (app->serialno, tmp_sn, 16))
    return (1);






  if (admin_pin)
    {
      void *relptr;
      unsigned char *value;
      size_t valuelen;
      int count;

      relptr = get_one_do (app, 0x00C4, &value, &valuelen, ((void*)0));
      if (!relptr || valuelen < 7)
        {
          g10_log_error (gettext ("error retrieving CHV status from card\n"));
          xfree (relptr);
          return (1);
        }
      count = value[6];
      xfree (relptr);

      if (!count)
        {
          g10_log_info (gettext ("card is permanently locked!\n"));
          return (11);
        }
      else if (count < 3)
        {
          g10_log_info (gettext ("verification of Admin PIN is currently prohibited " "through this command\n"));

          return (1);
        }

      app->did_chv3 = 0;
      return verify_chv3 (app, pincb, pincb_arg);
    }
  else
    return verify_chv2 (app, pincb, pincb_arg);
}



static void
show_caps (struct app_local_s *s)
{
  g10_log_info ("Version-2 ......: %s\n", s->extcap.is_v2? "yes":"no");
  g10_log_info ("Get-Challenge ..: %s", s->extcap.get_challenge? "yes":"no");
  if (s->extcap.get_challenge)
    log_printf (" (%u bytes max)", s->extcap.max_get_challenge);
  g10_log_info ("Key-Import .....: %s\n", s->extcap.key_import? "yes":"no");
  g10_log_info ("Change-Force-PW1: %s\n", s->extcap.change_force_chv? "yes":"no");
  g10_log_info ("Private-DOs ....: %s\n", s->extcap.private_dos? "yes":"no");
  g10_log_info ("Algo-Attr-Change: %s\n", s->extcap.algo_attr_change? "yes":"no");
  g10_log_info ("SM-Support .....: %s", s->extcap.sm_supported? "yes":"no");
  if (s->extcap.sm_supported)
    log_printf (" (%s)", s->extcap.sm_aes128? "AES-128":"3DES");
  g10_log_info ("Max-Cert3-Len ..: %u\n", s->extcap.max_certlen_3);
  g10_log_info ("Max-Cmd-Data ...: %u\n", s->extcap.max_cmd_data);
  g10_log_info ("Max-Rsp-Data ...: %u\n", s->extcap.max_rsp_data);
  g10_log_info ("Cmd-Chaining ...: %s\n", s->cardcap.cmd_chaining?"yes":"no");
  g10_log_info ("Ext-Lc-Le ......: %s\n", s->cardcap.ext_lc_le?"yes":"no");
  g10_log_info ("Status Indicator: %02X\n", s->status_indicator);

  g10_log_info ("GnuPG-No-Sync ..: %s\n", s->flags.no_sync? "yes":"no");
  g10_log_info ("GnuPG-Def-PW2 ..: %s\n", s->flags.def_chv2? "yes":"no");
}




static void
parse_historical (struct app_local_s *apploc,
                  const unsigned char * buffer, size_t buflen)
{

  if (buflen < 4)
    {
      g10_log_error ("warning: historical bytes are too short\n");
      return;
    }
  if (*buffer)
    {
      g10_log_error ("warning: bad category indicator in historical bytes\n");
      return;
    }


  buffer++;
  buflen--;


  apploc->status_indicator = buffer[buflen-3];
  buflen -= 3;


  while (buflen)
    {
      unsigned int tag = (*buffer & 0xf0) >> 4;
      unsigned int len = (*buffer & 0x0f);
      if (len+1 > buflen)
        {
          g10_log_error ("warning: bad Compact-TLV in historical bytes\n");
          return;
        }
      buffer++;
      buflen--;
      if (tag == 7 && len == 3)
        {

          apploc->cardcap.cmd_chaining = !!(buffer[2] & 0x80);
          apploc->cardcap.ext_lc_le = !!(buffer[2] & 0x40);
        }
      buffer += len;
      buflen -= len;
    }
}




static void
parse_algorithm_attribute (app_t app, int keyno)
{
  unsigned char *buffer;
  size_t buflen;
  void *relptr;
  const char desc[3][5] = {"sign", "encr", "auth"};

  ((void)((keyno >=0 && keyno <= 2) || (__assert_fail("keyno >=0 && keyno <= 2", "app-openpgp.c", 3603, __func__),0)));

  app->app_local->keyattr[keyno].n_bits = 0;

  relptr = get_one_do (app, 0xC1+keyno, &buffer, &buflen, ((void*)0));
  if (!relptr)
    {
      g10_log_error ("error reading DO 0x%02X\n", 0xc1+keyno);
      return;
    }
  if (buflen < 1)
    {
      g10_log_error ("error reading DO 0x%02X\n", 0xc1+keyno);
      xfree (relptr);
      return;
    }

  if (opt.verbose)
    g10_log_info ("Key-Attr-%s ..: ", desc[keyno]);
  if (*buffer == 1 && (buflen == 5 || buflen == 6))
    {
      app->app_local->keyattr[keyno].n_bits = (buffer[1]<<8 | buffer[2]);
      app->app_local->keyattr[keyno].e_bits = (buffer[3]<<8 | buffer[4]);
      app->app_local->keyattr[keyno].format = 0;
      if (buflen < 6)
        app->app_local->keyattr[keyno].format = RSA_STD;
      else
        app->app_local->keyattr[keyno].format = (buffer[5] == 0? RSA_STD :
                                                 buffer[5] == 1? RSA_STD_N :
                                                 buffer[5] == 2? RSA_CRT :
                                                 buffer[5] == 3? RSA_CRT_N :
                                                 RSA_UNKNOWN_FMT);

      if (opt.verbose)
        log_printf
          ("RSA, n=%u, e=%u, fmt=%s\n",
           app->app_local->keyattr[keyno].n_bits,
           app->app_local->keyattr[keyno].e_bits,
           app->app_local->keyattr[keyno].format == RSA_STD? "std" :
           app->app_local->keyattr[keyno].format == RSA_STD_N?"std+n":
           app->app_local->keyattr[keyno].format == RSA_CRT? "crt" :
           app->app_local->keyattr[keyno].format == RSA_CRT_N?"crt+n":"?");
    }
  else if (opt.verbose)
    log_printhex ("", buffer, buflen);

  xfree (relptr);
}



gpg_error_t
app_select_openpgp (app_t app)
{
  static char const aid[] = { 0xD2, 0x76, 0x00, 0x01, 0x24, 0x01 };
  int slot = app->slot;
  int rc;
  unsigned char *buffer;
  size_t buflen;
  void *relptr;



  rc = iso7816_select_application (slot, aid, sizeof aid, 0x0001);
  if (!rc)
    {
      unsigned int manufacturer;

      app->apptype = "OPENPGP";

      app->did_chv1 = 0;
      app->did_chv2 = 0;
      app->did_chv3 = 0;
      app->app_local = ((void*)0);






      rc = iso7816_get_data (slot, 0, 0x004F, &buffer, &buflen);
      if (rc)
        goto leave;
      if (opt.verbose)
        {
          g10_log_info ("AID: ");
          log_printhex ("", buffer, buflen);
        }

      app->card_version = buffer[6] << 8;
      app->card_version |= buffer[7];
      manufacturer = (buffer[8]<<8 | buffer[9]);

      xfree (app->serialno);
      app->serialno = buffer;
      app->serialnolen = buflen;
      buffer = ((void*)0);
      app->app_local = xcalloc((1),(sizeof *app->app_local));
      if (!app->app_local)
        {
          rc = ((1));
          goto leave;
        }

      if (app->card_version >= 0x0200)
        app->app_local->extcap.is_v2 = 1;



      relptr = get_one_do (app, 0x5f52, &buffer, &buflen, ((void*)0));
      if (relptr)
        {
          if (opt.verbose)
            {
              g10_log_info ("Historical Bytes: ");
              log_printhex ("", buffer, buflen);
            }
          parse_historical (app->app_local, buffer, buflen);
          xfree (relptr);
        }


      relptr = get_one_do (app, 0x00C4, &buffer, &buflen, ((void*)0));
      if (!relptr)
        {
          g10_log_error (gettext ("can't access %s - invalid OpenPGP card?\n"),
                     "CHV Status Bytes");
          goto leave;
        }
      app->force_chv1 = (buflen && *buffer == 0);
      xfree (relptr);


      relptr = get_one_do (app, 0x00C0, &buffer, &buflen, ((void*)0));
      if (!relptr)
        {
          g10_log_error (gettext ("can't access %s - invalid OpenPGP card?\n"),
                     "Extended Capability Flags" );
          goto leave;
        }
      if (buflen)
        {
          app->app_local->extcap.sm_supported = !!(*buffer & 0x80);
          app->app_local->extcap.get_challenge = !!(*buffer & 0x40);
          app->app_local->extcap.key_import = !!(*buffer & 0x20);
          app->app_local->extcap.change_force_chv = !!(*buffer & 0x10);
          app->app_local->extcap.private_dos = !!(*buffer & 0x08);
          app->app_local->extcap.algo_attr_change = !!(*buffer & 0x04);
        }
      if (buflen >= 10)
        {

          app->app_local->extcap.sm_aes128 = (buffer[1] == 1);
          app->app_local->extcap.max_get_challenge
                                               = (buffer[2] << 8 | buffer[3]);
          app->app_local->extcap.max_certlen_3 = (buffer[4] << 8 | buffer[5]);
          app->app_local->extcap.max_cmd_data = (buffer[6] << 8 | buffer[7]);
          app->app_local->extcap.max_rsp_data = (buffer[8] << 8 | buffer[9]);
        }
      xfree (relptr);



      if (app->card_version <= 0x0100 && manufacturer == 1)
        app->app_local->extcap.change_force_chv = 1;

      parse_login_data (app);

      if (opt.verbose)
        show_caps (app->app_local);

      parse_algorithm_attribute (app, 0);
      parse_algorithm_attribute (app, 1);
      parse_algorithm_attribute (app, 2);

      if (opt.verbose > 1)
        dump_all_do (slot);

      app->fnc.deinit = do_deinit;
      app->fnc.learn_status = do_learn_status;
      app->fnc.readcert = do_readcert;
      app->fnc.readkey = do_readkey;
      app->fnc.getattr = do_getattr;
      app->fnc.setattr = do_setattr;
      app->fnc.writecert = do_writecert;
      app->fnc.writekey = do_writekey;
      app->fnc.genkey = do_genkey;
      app->fnc.sign = do_sign;
      app->fnc.auth = do_auth;
      app->fnc.decipher = do_decipher;
      app->fnc.change_pin = do_change_pin;
      app->fnc.check_pin = do_check_pin;
   }

leave:
  if (rc)
    do_deinit (app);
  return rc;
}
