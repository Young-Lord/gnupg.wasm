# 1 "keyedit.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 363 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "keyedit.c" 2
# 21 "keyedit.c"
# 1 "../config.h" 1
# 22 "keyedit.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 1 3




# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 1 3
# 29 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 1 3
# 84 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_header_macro.h" 1 3
# 85 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3



# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 89 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_size_t.h" 1 3
# 18 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 94 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 103 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_wchar_t.h" 1 3
# 24 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_wchar_t.h" 3
typedef int wchar_t;
# 104 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_null.h" 1 3
# 109 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 123 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_max_align_t.h" 1 3
# 19 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 124 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_offsetof.h" 1 3
# 129 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 30 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 2 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 1 3
# 56 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 1 3
# 20 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 146 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long int uintptr_t;
# 161 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int intptr_t;
# 177 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef signed char int8_t;




typedef short int16_t;




typedef int int32_t;




typedef long long int int64_t;




typedef long long int intmax_t;




typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long int uint64_t;
# 227 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int uintmax_t;
# 21 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 2 3

typedef int8_t int_fast8_t;
typedef int64_t int_fast64_t;

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;

typedef uint8_t uint_fast8_t;
typedef uint64_t uint_fast64_t;

typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
# 95 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/stdint.h" 1 3
typedef int32_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef uint32_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
# 96 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 2 3
# 57 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 2 3
# 31 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 2 3





                                                             ;
                                                              ;
                                                              ;
                                                               ;
                                                              ;
                                                               ;
                                                              ;
                                                               ;
                                                            ;







typedef long unsigned int __wasi_size_t;

                                                                  ;
                                                                     ;




typedef uint64_t __wasi_filesize_t;

                                                                      ;
                                                                         ;




typedef uint64_t __wasi_timestamp_t;

                                                                       ;
                                                                          ;




typedef uint32_t __wasi_clockid_t;
# 102 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;







typedef uint16_t __wasi_errno_t;
# 498 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                   ;
                                                                      ;




typedef uint64_t __wasi_rights_t;
# 663 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint32_t __wasi_fd_t;

                                                                ;
                                                                   ;




typedef struct __wasi_iovec_t {



    uint8_t * buf;




    __wasi_size_t buf_len;

} __wasi_iovec_t;

                                                                   ;
                                                                      ;
                                                                            ;
                                                                                ;




typedef struct __wasi_ciovec_t {



    const uint8_t * buf;




    __wasi_size_t buf_len;

} __wasi_ciovec_t;

                                                                    ;
                                                                       ;
                                                                             ;
                                                                                 ;




typedef int64_t __wasi_filedelta_t;

                                                                       ;
                                                                          ;




typedef uint8_t __wasi_whence_t;
# 744 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;






typedef uint64_t __wasi_dircookie_t;

                                                                       ;
                                                                          ;




typedef uint32_t __wasi_dirnamlen_t;

                                                                       ;
                                                                          ;




typedef uint64_t __wasi_inode_t;

                                                                   ;
                                                                      ;




typedef uint8_t __wasi_filetype_t;
# 818 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                      ;
                                                                         ;




typedef struct __wasi_dirent_t {



    __wasi_dircookie_t d_next;




    __wasi_inode_t d_ino;




    __wasi_dirnamlen_t d_namlen;




    __wasi_filetype_t d_type;

} __wasi_dirent_t;

                                                                     ;
                                                                       ;
                                                                                ;
                                                                               ;
                                                                                   ;
                                                                                 ;




typedef uint8_t __wasi_advice_t;
# 889 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint16_t __wasi_fdflags_t;
# 924 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef struct __wasi_fdstat_t {



    __wasi_filetype_t fs_filetype;




    __wasi_fdflags_t fs_flags;




    __wasi_rights_t fs_rights_base;





    __wasi_rights_t fs_rights_inheriting;

} __wasi_fdstat_t;

                                                                     ;
                                                                       ;
                                                                                     ;
                                                                                  ;
                                                                                        ;
                                                                                               ;





typedef uint64_t __wasi_device_t;

                                                                    ;
                                                                       ;




typedef uint16_t __wasi_fstflags_t;
# 995 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                      ;
                                                                         ;




typedef uint32_t __wasi_lookupflags_t;






                                                                         ;
                                                                            ;




typedef uint16_t __wasi_oflags_t;
# 1036 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint64_t __wasi_linkcount_t;

                                                                       ;
                                                                          ;




typedef struct __wasi_filestat_t {



    __wasi_device_t dev;




    __wasi_inode_t ino;




    __wasi_filetype_t filetype;




    __wasi_linkcount_t nlink;




    __wasi_filesize_t size;




    __wasi_timestamp_t atim;




    __wasi_timestamp_t mtim;




    __wasi_timestamp_t ctim;

} __wasi_filestat_t;

                                                                       ;
                                                                         ;
                                                                               ;
                                                                               ;
                                                                                     ;
                                                                                  ;
                                                                                 ;
                                                                                 ;
                                                                                 ;
                                                                                 ;





typedef uint64_t __wasi_userdata_t;

                                                                      ;
                                                                         ;




typedef uint8_t __wasi_eventtype_t;
# 1136 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                       ;
                                                                          ;





typedef uint16_t __wasi_eventrwflags_t;






                                                                          ;
                                                                             ;





typedef struct __wasi_event_fd_readwrite_t {



    __wasi_filesize_t nbytes;




    __wasi_eventrwflags_t flags;

} __wasi_event_fd_readwrite_t;

                                                                                 ;
                                                                                   ;
                                                                                            ;
                                                                                           ;




typedef union __wasi_event_u_t {



    __wasi_event_fd_readwrite_t fd_readwrite;

} __wasi_event_u_t;

                                                                      ;
                                                                        ;




typedef struct __wasi_event_t {



    __wasi_userdata_t userdata;




    __wasi_errno_t error;




    __wasi_eventtype_t type;




    __wasi_event_u_t u;

} __wasi_event_t;

                                                                    ;
                                                                      ;
                                                                                 ;
                                                                              ;
                                                                              ;
                                                                           ;





typedef uint16_t __wasi_subclockflags_t;
# 1237 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                           ;
                                                                              ;




typedef struct __wasi_subscription_clock_t {



    __wasi_clockid_t id;




    __wasi_timestamp_t timeout;





    __wasi_timestamp_t precision;




    __wasi_subclockflags_t flags;

} __wasi_subscription_clock_t;

                                                                                 ;
                                                                                   ;
                                                                                        ;
                                                                                             ;
                                                                                                ;
                                                                                            ;





typedef struct __wasi_subscription_fd_readwrite_t {



    __wasi_fd_t file_descriptor;

} __wasi_subscription_fd_readwrite_t;

                                                                                       ;
                                                                                          ;
                                                                                                            ;




typedef union __wasi_subscription_u_t {



    __wasi_subscription_clock_t clock;




    __wasi_subscription_fd_readwrite_t fd_readwrite;

} __wasi_subscription_u_t;

                                                                             ;
                                                                               ;




typedef struct __wasi_subscription_t {




    __wasi_userdata_t userdata;




    __wasi_eventtype_t type;




    __wasi_subscription_u_t u;

} __wasi_subscription_t;

                                                                           ;
                                                                             ;
                                                                                        ;
                                                                                    ;
                                                                                  ;




typedef uint32_t __wasi_exitcode_t;

                                                                      ;
                                                                         ;




typedef uint8_t __wasi_signal_t;
# 1536 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint16_t __wasi_riflags_t;
# 1554 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef uint16_t __wasi_roflags_t;






                                                                     ;
                                                                        ;





typedef uint16_t __wasi_siflags_t;

                                                                     ;
                                                                        ;




typedef uint8_t __wasi_sdflags_t;
# 1594 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef uint8_t __wasi_preopentype_t;






                                                                         ;
                                                                            ;




typedef struct __wasi_prestat_dir_t {



    __wasi_size_t pr_name_len;

} __wasi_prestat_dir_t;

                                                                         ;
                                                                            ;
                                                                                          ;




typedef union __wasi_prestat_u_t {



    __wasi_prestat_dir_t dir;

} __wasi_prestat_u_t;

                                                                       ;
                                                                          ;




typedef struct __wasi_prestat_t {



    __wasi_preopentype_t pr_type;




    __wasi_prestat_u_t u;

} __wasi_prestat_t;

                                                                     ;
                                                                        ;
                                                                                  ;
                                                                            ;
# 1669 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_args_get(
    uint8_t * * argv,

    uint8_t * argv_buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("args_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_args_sizes_get(



    __wasi_size_t *argc,



    __wasi_size_t *argv_buf_size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("args_sizes_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_environ_get(
    uint8_t * * environ,

    uint8_t * environ_buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("environ_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_environ_sizes_get(



    __wasi_size_t *argc,



    __wasi_size_t *argv_buf_size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("environ_sizes_get"),
    __warn_unused_result__
));







__wasi_errno_t __wasi_clock_res_get(



    __wasi_clockid_t id,




    __wasi_timestamp_t *resolution
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("clock_res_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_clock_time_get(



    __wasi_clockid_t id,




    __wasi_timestamp_t precision,




    __wasi_timestamp_t *time
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("clock_time_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_advise(
    __wasi_fd_t fd,




    __wasi_filesize_t offset,




    __wasi_filesize_t len,




    __wasi_advice_t advice
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_advise"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_allocate(
    __wasi_fd_t fd,




    __wasi_filesize_t offset,




    __wasi_filesize_t len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_allocate"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_close(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_close"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_datasync(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_datasync"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_get(
    __wasi_fd_t fd,




    __wasi_fdstat_t *stat
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_set_flags(
    __wasi_fd_t fd,




    __wasi_fdflags_t flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_set_flags"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_set_rights(
    __wasi_fd_t fd,




    __wasi_rights_t fs_rights_base,

    __wasi_rights_t fs_rights_inheriting
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_set_rights"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_filestat_get(
    __wasi_fd_t fd,




    __wasi_filestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_filestat_set_size(
    __wasi_fd_t fd,




    __wasi_filesize_t size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_set_size"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_filestat_set_times(
    __wasi_fd_t fd,




    __wasi_timestamp_t atim,




    __wasi_timestamp_t mtim,




    __wasi_fstflags_t fst_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_set_times"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_pread(
    __wasi_fd_t fd,




    const __wasi_iovec_t *iovs,




    size_t iovs_len,




    __wasi_filesize_t offset,




    __wasi_size_t *nread
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_pread"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_prestat_get(
    __wasi_fd_t fd,




    __wasi_prestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_prestat_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_prestat_dir_name(
    __wasi_fd_t fd,




    uint8_t * path,

    __wasi_size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_prestat_dir_name"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_pwrite(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *iovs,




    size_t iovs_len,




    __wasi_filesize_t offset,




    __wasi_size_t *nwritten
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_pwrite"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_read(
    __wasi_fd_t fd,




    const __wasi_iovec_t *iovs,




    size_t iovs_len,




    __wasi_size_t *nread
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_read"),
    __warn_unused_result__
));
# 2098 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_fd_readdir(
    __wasi_fd_t fd,




    uint8_t * buf,

    __wasi_size_t buf_len,




    __wasi_dircookie_t cookie,




    __wasi_size_t *bufused
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_readdir"),
    __warn_unused_result__
));
# 2133 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_fd_renumber(
    __wasi_fd_t fd,




    __wasi_fd_t to
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_renumber"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_seek(
    __wasi_fd_t fd,




    __wasi_filedelta_t offset,




    __wasi_whence_t whence,




    __wasi_filesize_t *newoffset
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_seek"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_sync(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_sync"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_tell(
    __wasi_fd_t fd,




    __wasi_filesize_t *offset
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_tell"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_write(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *iovs,




    size_t iovs_len,




    __wasi_size_t *nwritten
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_write"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_create_directory(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_create_directory"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_filestat_get(
    __wasi_fd_t fd,




    __wasi_lookupflags_t flags,




    const char *path,




    size_t path_len,




    __wasi_filestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_filestat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_filestat_set_times(
    __wasi_fd_t fd,




    __wasi_lookupflags_t flags,




    const char *path,




    size_t path_len,




    __wasi_timestamp_t atim,




    __wasi_timestamp_t mtim,




    __wasi_fstflags_t fst_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_filestat_set_times"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_link(
    __wasi_fd_t old_fd,




    __wasi_lookupflags_t old_flags,




    const char *old_path,




    size_t old_path_len,




    __wasi_fd_t new_fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_link"),
    __warn_unused_result__
));
# 2376 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_path_open(
    __wasi_fd_t fd,




    __wasi_lookupflags_t dirflags,





    const char *path,




    size_t path_len,




    __wasi_oflags_t oflags,
# 2409 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
    __wasi_rights_t fs_rights_base,

    __wasi_rights_t fs_rights_inherting,

    __wasi_fdflags_t fdflags,




    __wasi_fd_t *opened_fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_open"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_readlink(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len,




    uint8_t * buf,

    __wasi_size_t buf_len,




    __wasi_size_t *bufused
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_readlink"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_path_remove_directory(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_remove_directory"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_rename(
    __wasi_fd_t fd,




    const char *old_path,




    size_t old_path_len,




    __wasi_fd_t new_fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_rename"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_symlink(



    const char *old_path,




    size_t old_path_len,

    __wasi_fd_t fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_symlink"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_path_unlink_file(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_unlink_file"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_poll_oneoff(



    const __wasi_subscription_t * in,




    __wasi_event_t * out,




    __wasi_size_t nsubscriptions,




    __wasi_size_t *nevents
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("poll_oneoff"),
    __warn_unused_result__
));






_Noreturn void __wasi_proc_exit(



    __wasi_exitcode_t rval
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("proc_exit")));





__wasi_errno_t __wasi_proc_raise(



    __wasi_signal_t sig
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("proc_raise"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_sched_yield(
    void
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sched_yield"),
    __warn_unused_result__
));
# 2652 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_random_get(



    uint8_t * buf,

    __wasi_size_t buf_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("random_get"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_sock_recv(
    __wasi_fd_t fd,




    const __wasi_iovec_t *ri_data,




    size_t ri_data_len,




    __wasi_riflags_t ri_flags,




    __wasi_size_t *ro_datalen,



    __wasi_roflags_t *ro_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_recv"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_sock_send(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *si_data,




    size_t si_data_len,




    __wasi_siflags_t si_flags,




    __wasi_size_t *so_datalen
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_send"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_sock_shutdown(
    __wasi_fd_t fd,




    __wasi_sdflags_t how
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_shutdown"),
    __warn_unused_result__
));
# 6 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 2 3






# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/features.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 2 3
# 30 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef __builtin_va_list va_list;




typedef __builtin_va_list __isoc_va_list;
# 141 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long int size_t;
# 156 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int ssize_t;
# 243 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long long int off_t;
# 400 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct _IO_FILE FILE;
# 31 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 2 3
# 66 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 3
typedef union _G_fpos64_t {
 char __opaque[16];
 long long __lldata;
 double __align;
} fpos_t;

extern FILE *const stdin;
extern FILE *const stdout;
extern FILE *const stderr;





FILE *fopen(const char *restrict, const char *restrict);
FILE *freopen(const char *restrict, const char *restrict, FILE *restrict);
int fclose(FILE *);

int remove(const char *);
int rename(const char *, const char *);

int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
void clearerr(FILE *);

int fseek(FILE *, long, int);
long ftell(FILE *);
void rewind(FILE *);

int fgetpos(FILE *restrict, fpos_t *restrict);
int fsetpos(FILE *, const fpos_t *);

size_t fread(void *restrict, size_t, size_t, FILE *restrict);
size_t fwrite(const void *restrict, size_t, size_t, FILE *restrict);

int fgetc(FILE *);
int getc(FILE *);
int getchar(void);
int ungetc(int, FILE *);

int fputc(int, FILE *);
int putc(int, FILE *);
int putchar(int);

char *fgets(char *restrict, int, FILE *restrict);




int fputs(const char *restrict, FILE *restrict);
int puts(const char *);

int printf(const char *restrict, ...);
int fprintf(FILE *restrict, const char *restrict, ...);
int sprintf(char *restrict, const char *restrict, ...);
int snprintf(char *restrict, size_t, const char *restrict, ...);

int vprintf(const char *restrict, __isoc_va_list);
int vfprintf(FILE *restrict, const char *restrict, __isoc_va_list);
int vsprintf(char *restrict, const char *restrict, __isoc_va_list);
int vsnprintf(char *restrict, size_t, const char *restrict, __isoc_va_list);

int scanf(const char *restrict, ...);
int fscanf(FILE *restrict, const char *restrict, ...);
int sscanf(const char *restrict, const char *restrict, ...);
int vscanf(const char *restrict, __isoc_va_list);
int vfscanf(FILE *restrict, const char *restrict, __isoc_va_list);
int vsscanf(const char *restrict, const char *restrict, __isoc_va_list);

void perror(const char *);

int setvbuf(FILE *restrict, char *restrict, int, size_t);
void setbuf(FILE *restrict, char *restrict);

char *tmpnam(char *);
FILE *tmpfile(void);




FILE *fmemopen(void *restrict, size_t, const char *restrict);
FILE *open_memstream(char **, size_t *);
FILE *fdopen(int, const char *);
FILE *popen(const char *, const char *);
int pclose(FILE *);
int fileno(FILE *);
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
int dprintf(int, const char *restrict, ...);
int vdprintf(int, const char *restrict, __isoc_va_list);
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);
ssize_t getdelim(char **restrict, size_t *restrict, int, FILE *restrict);
ssize_t getline(char **restrict, size_t *restrict, FILE *restrict);
int renameat(int, const char *, int, const char *);
char *ctermid(char *);







char *tempnam(const char *, const char *);




char *cuserid(char *);
void setlinebuf(FILE *);
void setbuffer(FILE *, char *, size_t);
int fgetc_unlocked(FILE *);
int fputc_unlocked(int, FILE *);
int fflush_unlocked(FILE *);
size_t fread_unlocked(void *, size_t, size_t, FILE *);
size_t fwrite_unlocked(const void *, size_t, size_t, FILE *);
void clearerr_unlocked(FILE *);
int feof_unlocked(FILE *);
int ferror_unlocked(FILE *);
int fileno_unlocked(FILE *);
int getw(FILE *);
int putw(int, FILE *);
char *fgetln(FILE *, size_t *);
int asprintf(char **, const char *, ...);
int vasprintf(char **, const char *, __isoc_va_list);



char *fgets_unlocked(char *, int, FILE *);
int fputs_unlocked(const char *, FILE *);

typedef ssize_t (cookie_read_function_t)(void *, char *, size_t);
typedef ssize_t (cookie_write_function_t)(void *, const char *, size_t);
typedef int (cookie_seek_function_t)(void *, off_t *, int);
typedef int (cookie_close_function_t)(void *);

typedef struct _IO_cookie_io_functions_t {
 cookie_read_function_t *read;
 cookie_write_function_t *write;
 cookie_seek_function_t *seek;
 cookie_close_function_t *close;
} cookie_io_functions_t;

FILE *fopencookie(void *, const char *, cookie_io_functions_t);
# 23 "keyedit.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h" 1 3







int getloadavg(double loadavg[], int nelem);





# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 1 3
# 21 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 40 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int wchar_t;
# 22 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 2 3

int atoi (const char *);
long atol (const char *);
long long atoll (const char *);
double atof (const char *);

float strtof (const char *restrict, char **restrict);
double strtod (const char *restrict, char **restrict);
long double strtold (const char *restrict, char **restrict);

long strtol (const char *restrict, char **restrict, int);
unsigned long strtoul (const char *restrict, char **restrict, int);
long long strtoll (const char *restrict, char **restrict, int);
unsigned long long strtoull (const char *restrict, char **restrict, int);

int rand (void);
void srand (unsigned);

void *malloc (size_t);
void *calloc (size_t, size_t);
void *realloc (void *, size_t);
void free (void *);
void *aligned_alloc(size_t, size_t);

_Noreturn void abort (void);
int atexit (void (*) (void));
_Noreturn void exit (int);
_Noreturn void _Exit (int);
int at_quick_exit (void (*) (void));
_Noreturn void quick_exit (int);

char *getenv (const char *);

int system (const char *);

void *bsearch (const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
void qsort (void *, size_t, size_t, int (*)(const void *, const void *));

int abs (int);
long labs (long);
long long llabs (long long);

typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;
typedef struct { long long quot, rem; } lldiv_t;

div_t div (int, int);
ldiv_t ldiv (long, long);
lldiv_t lldiv (long long, long long);

int mblen (const char *, size_t);
int mbtowc (wchar_t *restrict, const char *restrict, size_t);
int wctomb (char *, wchar_t);
size_t mbstowcs (wchar_t *restrict, const char *restrict, size_t);
size_t wcstombs (char *restrict, const wchar_t *restrict, size_t);




size_t __ctype_get_mb_cur_max(void);
# 101 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 3
int posix_memalign (void **, size_t, size_t);
int setenv (const char *, const char *, int);
int unsetenv (const char *);
int mkstemp (char *);
int mkostemp (char *, int);
char *mkdtemp (char *);
int getsubopt (char **, char *const *, char **);
int rand_r (unsigned *);






char *realpath (const char *restrict, char *restrict);
long int random (void);
void srandom (unsigned int);
char *initstate (unsigned int, char *, size_t);
char *setstate (char *);
int putenv (char *);
int posix_openpt (int);
int grantpt (int);
int unlockpt (int);
char *ptsname (int);
char *l64a (long);
long a64l (const char *);
void setkey (const char *);
double drand48 (void);
double erand48 (unsigned short [3]);
long int lrand48 (void);
long int nrand48 (unsigned short [3]);
long mrand48 (void);
long jrand48 (unsigned short [3]);
void srand48 (long);
unsigned short *seed48 (unsigned short [3]);
void lcong48 (unsigned short [7]);



# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h" 1 3








# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h" 2 3

void *alloca(size_t);
# 141 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 2 3
char *mktemp (char *);
int mkstemps (char *, int);
int mkostemps (char *, int, int);
void *valloc (size_t);
void *memalign(size_t, size_t);
int getloadavg(double *, int);
int clearenv(void);


void *reallocarray (void *, size_t, size_t);
void qsort_r (void *, size_t, size_t, int (*)(const void *, const void *, void *), void *);



int ptsname_r(int, char *, size_t);
char *ecvt(double, int, int *, int *);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
char *secure_getenv(const char *);
struct __locale_struct;
float strtof_l(const char *restrict, char **restrict, struct __locale_struct *);
double strtod_l(const char *restrict, char **restrict, struct __locale_struct *);
long double strtold_l(const char *restrict, char **restrict, struct __locale_struct *);
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h" 2 3
# 24 "keyedit.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/string.h" 1 3







extern char* strlwr(char *);
extern char* strupr(char *);





# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 1 3
# 25 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 412 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __locale_struct * locale_t;
# 26 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 2 3

void *memcpy (void *restrict, const void *restrict, size_t);
void *memmove (void *, const void *, size_t);
void *memset (void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void *memchr (const void *, int, size_t);

char *strcpy (char *restrict, const char *restrict);
char *strncpy (char *restrict, const char *restrict, size_t);

char *strcat (char *restrict, const char *restrict);
char *strncat (char *restrict, const char *restrict, size_t);

int strcmp (const char *, const char *);
int strncmp (const char *, const char *, size_t);

int strcoll (const char *, const char *);
size_t strxfrm (char *restrict, const char *restrict, size_t);

char *strchr (const char *, int);
char *strrchr (const char *, int);

size_t strcspn (const char *, const char *);
size_t strspn (const char *, const char *);
char *strpbrk (const char *, const char *);
char *strstr (const char *, const char *);
char *strtok (char *restrict, const char *restrict);

size_t strlen (const char *);

char *strerror (int);


# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 2 3




int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
char *index (const char *, int);
char *rindex (const char *, int);



int ffs (int);
int ffsl (long);
int ffsll (long long);


int strcasecmp (const char *, const char *);
int strncasecmp (const char *, const char *, size_t);

int strcasecmp_l (const char *, const char *, locale_t);
int strncasecmp_l (const char *, const char *, size_t, locale_t);
# 60 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 2 3





char *strtok_r (char *restrict, const char *restrict, char **restrict);
int strerror_r (int, char *, size_t);
char *stpcpy(char *restrict, const char *restrict);
char *stpncpy(char *restrict, const char *restrict, size_t);
size_t strnlen (const char *, size_t);
char *strdup (const char *);
char *strndup (const char *, size_t);
char *strsignal(int);
char *strerror_l (int, locale_t);
int strcoll_l (const char *, const char *, locale_t);
size_t strxfrm_l (char *restrict, const char *restrict, size_t, locale_t);
void *memmem(const void *, size_t, const void *, size_t);




void *memccpy (void *restrict, const void *restrict, int, size_t);



char *strsep(char **, const char *);
size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
void explicit_bzero (void *, size_t);




int strverscmp (const char *, const char *);
char *strchrnul(const char *, int);
char *strcasestr(const char *, const char *);
void *memrchr(const void *, int, size_t);
void *mempcpy(void *, const void *, size_t);
# 16 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/string.h" 2 3
# 25 "keyedit.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/errno.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/errno.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/errno.h" 1 3
# 11 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/errno.h" 2 3


__attribute__((const))

int *__errno_location(void);



extern char *program_invocation_short_name, *program_invocation_name;
# 26 "keyedit.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/assert.h" 1 3
# 19 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/assert.h" 3
_Noreturn void __assert_fail (const char *, const char *, int, const char *);
# 27 "keyedit.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/ctype.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/ctype.h" 3
int isalnum(int);
int isalpha(int);
int isblank(int);
int iscntrl(int);
int isdigit(int);
int isgraph(int);
int islower(int);
int isprint(int);
int ispunct(int);
int isspace(int);
int isupper(int);
int isxdigit(int);
int tolower(int);
int toupper(int);


static inline int __isspace(int _c)
{
 return _c == ' ' || (unsigned)_c-'\t' < 5;
}
# 46 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/ctype.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 47 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/ctype.h" 2 3

int isalnum_l(int, locale_t);
int isalpha_l(int, locale_t);
int isblank_l(int, locale_t);
int iscntrl_l(int, locale_t);
int isdigit_l(int, locale_t);
int isgraph_l(int, locale_t);
int islower_l(int, locale_t);
int isprint_l(int, locale_t);
int ispunct_l(int, locale_t);
int isspace_l(int, locale_t);
int isupper_l(int, locale_t);
int isxdigit_l(int, locale_t);
int tolower_l(int, locale_t);
int toupper_l(int, locale_t);

int isascii(int);
int toascii(int);
# 28 "keyedit.c" 2




# 1 "./options.h" 1
# 23 "./options.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 1 3
# 57 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 83 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long long int time_t;




typedef int suseconds_t;





typedef struct {
    union {
        int __i[10];
        volatile int __vi[10];
        unsigned long __s[10];
    } __u;



    const char *_a_transferredcanvases;

} pthread_attr_t;




typedef struct { union { int __i[6]; volatile int __vi[6]; volatile void *__p[6]; } __u; } pthread_mutex_t;
# 120 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct { union { int __i[12]; volatile int __vi[12]; void *__p[12]; } __u; } pthread_cond_t;
# 130 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct { union { int __i[sizeof(long)==8?14:8]; volatile int __vi[sizeof(long)==8?14:8]; void *__p[sizeof(long)==8?7:8]; } __u; } pthread_rwlock_t;




typedef struct { union { int __i[5]; volatile int __vi[5]; void *__p[5]; } __u; } pthread_barrier_t;
# 171 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int register_t;
# 222 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int u_int64_t;
# 233 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned mode_t;




typedef unsigned long int nlink_t;
# 248 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int ino_t;




typedef unsigned int dev_t;




typedef int blksize_t;




typedef int blkcnt_t;




typedef unsigned int fsblkcnt_t;




typedef unsigned int fsfilcnt_t;
# 289 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef void * timer_t;




typedef int clockid_t;




typedef int clock_t;
# 320 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int pid_t;




typedef unsigned id_t;




typedef unsigned uid_t;




typedef unsigned gid_t;




typedef int key_t;




typedef unsigned useconds_t;
# 358 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __pthread * pthread_t;





typedef int pthread_once_t;




typedef unsigned pthread_key_t;




typedef int pthread_spinlock_t;




typedef struct { unsigned __attr; } pthread_mutexattr_t;




typedef struct { unsigned __attr; } pthread_condattr_t;




typedef struct { unsigned __attr; } pthread_barrierattr_t;




typedef struct { unsigned __attr[2]; } pthread_rwlockattr_t;
# 58 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3


typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned u_int32_t;
typedef char *caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short, ushort;
typedef unsigned u_int, uint;
typedef unsigned long u_long, ulong;
typedef long long quad_t;
typedef unsigned long long u_quad_t;
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 11 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 2 3








static inline uint16_t __bswap16(uint16_t __x)
{
 return __x<<8 | __x>>8;
}

static inline uint32_t __bswap32(uint32_t __x)
{
 return __x>>24 | __x>>8&0xff00 | __x<<8&0xff0000 | __x<<24;
}

static inline uint64_t __bswap64(uint64_t __x)
{
 return __bswap32(__x)+0ULL<<32 | __bswap32(__x>>32);
}
# 71 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 1 3
# 16 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 309 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
struct timeval { time_t tv_sec; suseconds_t tv_usec; };




struct timespec { time_t tv_sec; long tv_nsec; };
# 418 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __sigset_t { unsigned long __bits[128/sizeof(long)]; } sigset_t;
# 17 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 2 3



typedef unsigned long fd_mask;

typedef struct {
 unsigned long fds_bits[1024 / 8 / sizeof(long)];
} fd_set;






int select (int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict);
int pselect (int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict);
# 72 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3
# 24 "./options.h" 2
# 1 "../include/types.h" 1
# 24 "../include/types.h"
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 1 3
# 24 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 2 3

typedef struct { intmax_t quot, rem; } imaxdiv_t;

intmax_t imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);

intmax_t strtoimax(const char *restrict, char **restrict, int);
uintmax_t strtoumax(const char *restrict, char **restrict, int);

intmax_t wcstoimax(const wchar_t *restrict, wchar_t **restrict, int);
uintmax_t wcstoumax(const wchar_t *restrict, wchar_t **restrict, int);
# 25 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 2 3
# 25 "../include/types.h" 2
# 49 "../include/types.h"
typedef unsigned char byte;
# 76 "../include/types.h"
typedef unsigned short u16;
# 86 "../include/types.h"
typedef unsigned int u32;
# 103 "../include/types.h"
typedef uint64_t u64;
# 126 "../include/types.h"
typedef union {
    int a;
    short b;
    char c[1];
    long d;

    u64 e;

    float f;
    double g;
} PROPERLY_ALIGNED_TYPE;

struct string_list {
    struct string_list *next;
    unsigned int flags;
    char d[1];
};
typedef struct string_list *STRLIST;
typedef struct string_list *strlist_t;
# 25 "./options.h" 2
# 1 "./main.h" 1
# 23 "./main.h"
# 1 "../include/iobuf.h" 1
# 36 "../include/iobuf.h"
typedef struct iobuf_struct *IOBUF;
typedef struct iobuf_struct *iobuf_t;


struct iobuf_struct {
    int use;
    off_t nlimit;
    off_t nbytes;
    off_t ntotal;
    int nofast;
    void *directfp;
    struct {
 size_t size;
 size_t start;
 size_t len;
 byte *buf;
    } d;
    int filter_eof;
    int error;
    int (*filter)( void *opaque, int control,
     IOBUF chain, byte *buf, size_t *len);
    void *filter_ov;
    int filter_ov_owner;
    char *real_fname;
    IOBUF chain;
    int no, subno;
    void *opaque;

    struct {
 size_t size;
 size_t start;
 size_t len;
 byte *buf;
    } unget;
};
# 81 "../include/iobuf.h"
int iobuf_debug_mode;

void iobuf_enable_special_filenames ( int yes );
int iobuf_is_pipe_filename (const char *fname);
IOBUF iobuf_alloc(int use, size_t bufsize);
IOBUF iobuf_temp(void);
IOBUF iobuf_temp_with_content( const char *buffer, size_t length );
IOBUF iobuf_open( const char *fname );
IOBUF iobuf_fdopen( int fd, const char *mode );
IOBUF iobuf_sockopen( int fd, const char *mode );
IOBUF iobuf_create( const char *fname );
IOBUF iobuf_append( const char *fname );
IOBUF iobuf_openrw( const char *fname );
int iobuf_ioctl ( IOBUF a, int cmd, int intval, void *ptrval );
int iobuf_close( IOBUF iobuf );
int iobuf_cancel( IOBUF iobuf );

int iobuf_push_filter( IOBUF a, int (*f)(void *opaque, int control,
         IOBUF chain, byte *buf, size_t *len), void *ov );
int iobuf_push_filter2( IOBUF a,
      int (*f)(void *opaque, int control,
      IOBUF chain, byte *buf, size_t *len),
      void *ov, int rel_ov );
int iobuf_flush(IOBUF a);
void iobuf_clear_eof(IOBUF a);



void iobuf_set_limit( IOBUF a, off_t nlimit );

off_t iobuf_tell( IOBUF a );
int iobuf_seek( IOBUF a, off_t newpos );

int iobuf_readbyte(IOBUF a);
int iobuf_read(IOBUF a, byte *buf, unsigned buflen );
unsigned iobuf_read_line( IOBUF a, byte **addr_of_buffer,
     unsigned *length_of_buffer, unsigned *max_length );
int iobuf_peek(IOBUF a, byte *buf, unsigned buflen );
int iobuf_writebyte(IOBUF a, unsigned c);
int iobuf_write(IOBUF a, byte *buf, unsigned buflen );
int iobuf_writestr(IOBUF a, const char *buf );

void iobuf_flush_temp( IOBUF temp );
int iobuf_write_temp( IOBUF a, IOBUF temp );
size_t iobuf_temp_to_buffer( IOBUF a, byte *buffer, size_t buflen );
void iobuf_unget_and_close_temp( IOBUF a, IOBUF temp );

int iobuf_get_fd (IOBUF a);
off_t iobuf_get_filelength (IOBUF a, int *overflow);

const char *iobuf_get_real_fname( IOBUF a );
const char *iobuf_get_fname( IOBUF a );

void iobuf_set_partial_block_mode( IOBUF a, size_t len );

int iobuf_translate_file_handle ( int fd, int for_write );
# 160 "../include/iobuf.h"
void iobuf_skip_rest (IOBUF a, unsigned long n, int partial);
# 24 "./main.h" 2
# 1 "../include/mpi.h" 1
# 32 "../include/mpi.h"
# 1 "../config.h" 1
# 33 "../include/mpi.h" 2



# 1 "../include/memory.h" 1
# 57 "../include/memory.h"
void *xmalloc( size_t n );
void *xtrymalloc (size_t n);
void *xmalloc_clear( size_t n );
void *xmalloc_secure( size_t n );
void *xmalloc_secure_clear( size_t n );
void *xrealloc( void *a, size_t n );
void xfree( void *p );
void m_check( const void *a );

char *xstrdup( const char * a);
char *xtrystrdup (const char *a);


size_t m_size( const void *a );
void m_print_stats(const char *prefix);


void *xcalloc (size_t n, size_t m);
void *xcalloc_secure (size_t n, size_t m);



int secmem_init( size_t npool );
void secmem_term( void );
void *secmem_malloc( size_t size );
void *secmexrealloc( void *a, size_t newsize );
void secmem_free( void *a );
int m_is_secure( const void *p );
void secmem_dump_stats(void);
void secmem_set_flags( unsigned flags );
unsigned secmem_get_flags(void);
# 102 "../include/memory.h"
int memory_debug_mode;
int memory_stat_debug_mode;
# 37 "../include/mpi.h" 2
# 49 "../include/mpi.h"
int mpi_debug_mode;


struct gcry_mpi;
typedef struct gcry_mpi *MPI;
# 72 "../include/mpi.h"
MPI mpi_alloc( unsigned nlimbs );
MPI mpi_alloc_secure( unsigned nlimbs );
MPI mpi_alloc_like( MPI a );
void mpi_free( MPI a );
void mpi_resize( MPI a, unsigned nlimbs );
MPI mpi_copy( MPI a );


MPI mpi_set_opaque( MPI a, void *p, unsigned int len );
void *mpi_get_opaque( MPI a, unsigned int *len );

void mpi_set_secure( MPI a );
void mpi_clear( MPI a );
void mpi_set( MPI w, MPI u);
void mpi_set_cond( MPI w, MPI u, unsigned long set);
void mpi_set_ui( MPI w, ulong u);
MPI mpi_alloc_set_ui( unsigned long u);
void mpi_m_check( MPI a );
void mpi_swap( MPI a, MPI b);
int mpi_get_nlimbs (MPI a);
int mpi_is_neg (MPI a);
unsigned int mpi_nlimb_hint_from_nbytes (unsigned int nbytes);
unsigned int mpi_nlimb_hint_from_nbits (unsigned int nbits);
unsigned int mpi_get_flags (MPI a);


int mpi_write( IOBUF out, MPI a );




MPI mpi_read(IOBUF inp, unsigned *nread, int secure);

MPI mpi_read_from_buffer(byte *buffer, unsigned *ret_nread, int secure);
int mpi_fromstr(MPI val, const char *str);
int mpi_print( FILE *fp, MPI a, int mode );
void g10_log_mpidump( const char *text, MPI a );
u32 mpi_get_keyid( MPI a, u32 *keyid );
byte *mpi_get_buffer( MPI a, unsigned *nbytes, int *sign );
byte *mpi_get_secure_buffer( MPI a, unsigned *nbytes, int *sign );
void mpi_set_buffer( MPI a, const byte *buffer, unsigned nbytes, int sign );




void mpi_add_ui(MPI w, MPI u, ulong v );
void mpi_add(MPI w, MPI u, MPI v);
void mpi_addm(MPI w, MPI u, MPI v, MPI m);
void mpi_sub_ui(MPI w, MPI u, ulong v );
void mpi_sub( MPI w, MPI u, MPI v);
void mpi_subm( MPI w, MPI u, MPI v, MPI m);


void mpi_mul_ui(MPI w, MPI u, ulong v );
void mpi_mul_2exp( MPI w, MPI u, ulong cnt);
void mpi_mul( MPI w, MPI u, MPI v);
void mpi_mulm( MPI w, MPI u, MPI v, MPI m);


ulong mpi_fdiv_r_ui( MPI rem, MPI dividend, ulong divisor );
void mpi_fdiv_r( MPI rem, MPI dividend, MPI divisor );
void mpi_fdiv_q( MPI quot, MPI dividend, MPI divisor );
void mpi_fdiv_qr( MPI quot, MPI rem, MPI dividend, MPI divisor );
void mpi_tdiv_r( MPI rem, MPI num, MPI den);
void mpi_tdiv_qr( MPI quot, MPI rem, MPI num, MPI den);
void mpi_tdiv_q_2exp( MPI w, MPI u, unsigned count );
int mpi_divisible_ui(MPI dividend, ulong divisor );


int mpi_gcd( MPI g, MPI a, MPI b );


void mpi_pow( MPI w, MPI u, MPI v);
void mpi_powm( MPI res, MPI base, MPI exponent, MPI mod);


void mpi_mulpowm( MPI res, MPI *basearray, MPI *exparray, MPI mod);


int mpi_cmp_ui( MPI u, ulong v );
int mpi_cmp( MPI u, MPI v );


int mpi_getbyte( MPI a, unsigned idx );
void mpi_putbyte( MPI a, unsigned idx, int value );
unsigned mpi_trailing_zeros( MPI a );


void mpi_normalize( MPI a );
unsigned mpi_get_nbits( MPI a );
int mpi_test_bit( MPI a, unsigned n );
void mpi_set_bit( MPI a, unsigned n );
void mpi_set_highbit( MPI a, unsigned n );
void mpi_clear_highbit( MPI a, unsigned n );
void mpi_clear_bit( MPI a, unsigned n );
void mpi_rshift( MPI x, MPI a, unsigned n );


void mpi_invm( MPI x, MPI u, MPI v );
# 25 "./main.h" 2
# 1 "../include/cipher.h" 1
# 26 "../include/cipher.h"
# 1 "../include/../cipher/random.h" 1
# 25 "../include/../cipher/random.h"
void random_dump_stats(void);
void secure_randoxmalloc(void);
void set_random_seed_file(const char *);
void update_random_seed_file(void);
int quick_random_gen( int onoff );
int random_is_faked(void);
void random_disable_locking (void);
void randomize_buffer( byte *buffer, size_t length, int level );
void randomize_mpi (MPI mpi, size_t nbits, int level);
byte *get_random_bits( size_t nbits, int level, int secure );
void fast_random_poll( void );
# 27 "../include/cipher.h" 2
# 82 "../include/cipher.h"
typedef struct
{
  int algo;
  int keylen;
  int algo_info_printed;
  int use_mdc;
  int symmetric;
  byte key[32];
} DEK;

struct cipher_handle_s;
typedef struct cipher_handle_s *CIPHER_HANDLE;
# 103 "../include/cipher.h"
struct md_digest_list_s;

struct gcry_md_context {
    int secure;
    FILE *debug;
    int finalized;
    struct md_digest_list_s *list;
    int bufcount;
    int bufsize;
    byte buffer[1];
};

typedef struct gcry_md_context *MD_HANDLE;
# 126 "../include/cipher.h"
int g10c_debug_mode;
int g10_opt_verbose;
const char *g10_opt_homedir;



void register_cipher_extension( const char *mainpgm, const char *fname );


int string_to_digest_algo( const char *string );
const char * digest_algo_to_string( int algo );
int check_digest_algo( int algo );
MD_HANDLE md_open( int algo, int secure );
void md_enable( MD_HANDLE hd, int algo );
MD_HANDLE md_copy( MD_HANDLE a );
void md_reset( MD_HANDLE a );
void md_close(MD_HANDLE a);
void md_write( MD_HANDLE a, const byte *inbuf, size_t inlen);
void md_final(MD_HANDLE a);
byte *md_read( MD_HANDLE a, int algo );
int md_digest( MD_HANDLE a, int algo, byte *buffer, int buflen );
int md_get_algo( MD_HANDLE a );
int md_algo_present( MD_HANDLE a, int algo );
int md_digest_length( int algo );
const byte *md_asn_oid( int algo, size_t *asnlen, size_t *mdlen );
void md_start_debug( MD_HANDLE a, const char *suffix );
void md_stop_debug( MD_HANDLE a );
# 161 "../include/cipher.h"
void rmd160_hash_buffer (char *outbuf, const char *buffer, size_t length);
void sha1_hash_buffer (char *outbuf, const char *buffer, size_t length);



int string_to_cipher_algo( const char *string );
const char * cipher_algo_to_string( int algo );
void disable_cipher_algo( int algo );
int check_cipher_algo( int algo );
unsigned cipher_get_keylen( int algo );
unsigned cipher_get_blocksize( int algo );
CIPHER_HANDLE cipher_open( int algo, int mode, int secure );
void cipher_close( CIPHER_HANDLE c );
int cipher_setkey( CIPHER_HANDLE c, byte *key, unsigned keylen );
void cipher_setiv( CIPHER_HANDLE c, const byte *iv, unsigned ivlen );
void cipher_encrypt( CIPHER_HANDLE c, byte *out, byte *in, unsigned nbytes );
void cipher_decrypt( CIPHER_HANDLE c, byte *out, byte *in, unsigned nbytes );
void cipher_sync( CIPHER_HANDLE c );







int string_to_pubkey_algo( const char *string );
const char * pubkey_algo_to_string( int algo );
void disable_pubkey_algo( int algo );
int check_pubkey_algo( int algo );
int check_pubkey_algo2( int algo, unsigned use );
int pubkey_get_npkey( int algo );
int pubkey_get_nskey( int algo );
int pubkey_get_nsig( int algo );
int pubkey_get_nenc( int algo );
unsigned pubkey_nbits( int algo, MPI *pkey );
int pubkey_generate( int algo, unsigned nbits, MPI *skey, MPI **retfactors );
int dsa2_generate( int algo, unsigned nbits, unsigned qbits,
     MPI *skey, MPI **retfactors );
int pubkey_check_secret_key( int algo, MPI *skey );
int pubkey_encrypt( int algo, MPI *resarr, MPI data, MPI *pkey );
int pubkey_decrypt( int algo, MPI *result, MPI *data, MPI *skey );
int pubkey_sign( int algo, MPI *resarr, MPI hash, MPI *skey );
int pubkey_verify( int algo, MPI hash, MPI *data, MPI *pkey );


extern ushort small_prime_numbers[];


void register_primegen_progress ( void (*cb)( void *, int), void *cb_data );
MPI generate_secret_prime( unsigned nbits );
MPI generate_public_prime( unsigned nbits );
MPI generate_elg_prime( int mode, unsigned pbits, unsigned qbits,
        MPI g, MPI **factors );


void register_pk_dsa_progress ( void (*cb)( void *, int), void *cb_data );
void register_pk_elg_progress ( void (*cb)( void *, int), void *cb_data );
# 26 "./main.h" 2
# 1 "./keydb.h" 1
# 25 "./keydb.h"
# 1 "./global.h" 1
# 25 "./global.h"
typedef struct kbnode_struct *KBNODE;
typedef struct kbnode_struct *kbnode_t;
typedef struct keydb_search_desc KEYDB_SEARCH_DESC;
# 26 "./keydb.h" 2
# 1 "./packet.h" 1
# 28 "./packet.h"
# 1 "./filter.h" 1
# 26 "./filter.h"
typedef struct {
    MD_HANDLE md;
    MD_HANDLE md2;
    size_t maxbuf_size;
} md_filter_context_t;

typedef struct {
    int refcount;



    int what;
    int only_keyblocks;
    const char *hdrlines;


    int no_openpgp_data;
    int key_failed_code;



    int inp_checked;
    int inp_bypass;
    int in_cleartext;
    int not_dash_escaped;
    int hashes;
    int faked;
    int truncated;
    int qp_detected;
    int pgp2mode;
    byte eol[3];




    byte *buffer;
    unsigned buffer_size;
    unsigned buffer_len;
    unsigned buffer_pos;

    byte radbuf[4];
    int idx, idx2;
    u32 crc;

    int status;
    int cancel;
    int any_data;
    int pending_lf;
} armor_filter_context_t;

struct unarmor_pump_s;
typedef struct unarmor_pump_s *UnarmorPump;


struct compress_filter_context_s {
    int status;
    void *opaque;
    byte *inbuf;
    unsigned inbufsize;
    byte *outbuf;
    unsigned outbufsize;
    int algo;
    int algo1hack;
    int new_ctb;
    void (*release)(struct compress_filter_context_s*);
};
typedef struct compress_filter_context_s compress_filter_context_t;


typedef struct {
    DEK *dek;
    u32 datalen;
    CIPHER_HANDLE cipher_hd;
    int header;
    MD_HANDLE mdc_hash;
    byte enchash[20];
    int create_mdc;
} cipher_filter_context_t;



typedef struct {
    byte *buffer;
    unsigned buffer_size;
    unsigned buffer_len;
    unsigned buffer_pos;
    int truncated;
    int not_dash_escaped;
    int escape_from;
    MD_HANDLE md;
    int pending_lf;
    int pending_esc;
} text_filter_context_t;


typedef struct {
    char *what;
    u32 last_time;
    unsigned long last;
    unsigned long offset;
    unsigned long total;
} progress_filter_context_t;




int md_filter( void *opaque, int control, IOBUF a, byte *buf, size_t *ret_len);
void free_md_filter_context( md_filter_context_t *mfx );


armor_filter_context_t *new_armor_context (void);
void release_armor_context (armor_filter_context_t *afx);
int push_armor_filter (armor_filter_context_t *afx, IOBUF iobuf);
int use_armor_filter( IOBUF a );
int armor_filter( void *opaque, int control,
    IOBUF chain, byte *buf, size_t *ret_len);
UnarmorPump unarmor_pump_new (void);
void unarmor_pump_release (UnarmorPump x);
int unarmor_pump (UnarmorPump x, int c);


void push_compress_filter(IOBUF out,compress_filter_context_t *zfx,int algo);
void push_compress_filter2(IOBUF out,compress_filter_context_t *zfx,
      int algo,int rel);


int cipher_filter( void *opaque, int control,
     IOBUF chain, byte *buf, size_t *ret_len);


int text_filter( void *opaque, int control,
   IOBUF chain, byte *buf, size_t *ret_len);
int copy_clearsig_text( IOBUF out, IOBUF inp, MD_HANDLE md,
     int escape_dash, int escape_from, int pgp2mode );


int progress_filter (void *opaque, int control,
       IOBUF a, byte *buf, size_t *ret_len);
void handle_progress (progress_filter_context_t *pfx,
        IOBUF inp, const char *name);
# 29 "./packet.h" 2




typedef enum {
 PKT_NONE =0,
 PKT_PUBKEY_ENC =1,
 PKT_SIGNATURE =2,
 PKT_SYMKEY_ENC =3,
 PKT_ONEPASS_SIG =4,
 PKT_SECRET_KEY =5,
 PKT_PUBLIC_KEY =6,
 PKT_SECRET_SUBKEY =7,
 PKT_COMPRESSED =8,
 PKT_ENCRYPTED =9,
 PKT_MARKER =10,
 PKT_PLAINTEXT =11,
 PKT_RING_TRUST =12,
 PKT_USER_ID =13,
 PKT_PUBLIC_SUBKEY =14,
 PKT_OLD_COMMENT =16,
 PKT_ATTRIBUTE =17,
 PKT_ENCRYPTED_MDC =18,
 PKT_MDC =19,
 PKT_COMMENT =61,
        PKT_GPG_CONTROL =63
} pkttype_t;

typedef struct packet_struct PACKET;


typedef enum {
    CTRLPKT_CLEARSIGN_START = 1,
    CTRLPKT_PIPEMODE = 2,
    CTRLPKT_PLAINTEXT_MARK =3
} ctrlpkttype_t;

typedef enum {
    PREFTYPE_NONE = 0,
    PREFTYPE_SYM = 1,
    PREFTYPE_HASH = 2,
    PREFTYPE_ZIP = 3
} preftype_t;

typedef struct {
    byte type;
    byte value;
} prefitem_t;

typedef struct {
    int mode;
    byte hash_algo;
    byte salt[8];
    u32 count;
} STRING2KEY;

typedef struct {
    byte version;
    byte cipher_algo;
    STRING2KEY s2k;
    byte seskeylen;
    byte seskey[1];
} PKT_symkey_enc;

typedef struct {
    u32 keyid[2];
    byte version;
    byte pubkey_algo;
    byte throw_keyid;
    MPI data[2];
} PKT_pubkey_enc;


typedef struct {
    u32 keyid[2];
    byte sig_class;
    byte digest_algo;
    byte pubkey_algo;
    byte last;
} PKT_onepass_sig;


typedef struct {
    size_t size;
    size_t len;
    byte data[1];
} subpktarea_t;

struct revocation_key {
  byte class;
  byte algid;
  byte fpr[20];
};



typedef struct
{
  int valid;
  int checked;

  char *uri;

  unsigned char fpr[20];
  char email[1];
} pka_info_t;



typedef struct
{
  struct
  {
    unsigned checked:1;
    unsigned valid:1;
    unsigned chosen_selfsig:1;
    unsigned unknown_critical:1;
    unsigned exportable:1;
    unsigned revocable:1;
    unsigned policy_url:1;
    unsigned notation:1;
    unsigned pref_ks:1;
    unsigned expired:1;
    unsigned pka_tried:1;
  } flags;
  u32 keyid[2];
  u32 timestamp;
  u32 expiredate;
  byte version;
  byte sig_class;
  byte pubkey_algo;

  byte digest_algo;
  byte trust_depth;
  byte trust_value;
  const byte *trust_regexp;
  struct revocation_key **revkey;
  int numrevkeys;
  pka_info_t *pka_info;

  subpktarea_t *hashed;
  subpktarea_t *unhashed;
  byte digest_start[2];
  MPI data[2];
} PKT_signature;




struct user_attribute {
  byte type;
  const byte *data;
  u32 len;
};

typedef struct
{
  int ref;
  int len;
  struct user_attribute *attribs;
  int numattribs;
  byte *attrib_data;
  unsigned long attrib_len;
  byte *namehash;
  int help_key_usage;
  u32 help_key_expire;
  int help_full_count;
  int help_marginal_count;
  int is_primary;
  int is_revoked;
  int is_expired;
  u32 expiredate;
  prefitem_t *prefs;
  u32 created;
  byte selfsigversion;
  struct
  {

    unsigned mdc:1;
    unsigned ks_modify:1;
    unsigned compacted:1;
  } flags;
  char name[1];
} PKT_user_id;

struct revoke_info
{

  u32 date;

  u32 keyid[2];

  byte algo;
};







typedef struct {
    u32 timestamp;
    u32 expiredate;
    u32 max_expiredate;
    struct revoke_info revoked;
    byte hdrbytes;
    byte version;
    byte selfsigversion;
    byte pubkey_algo;
    byte pubkey_usage;
    byte req_usage;
    byte req_algo;
    u32 has_expired;
    int is_revoked;

    int maybe_revoked;

    int is_valid;
    int dont_cache;
    byte backsig;
    u32 main_keyid[2];
    u32 keyid[2];
    byte is_primary;
    byte is_disabled;
    prefitem_t *prefs;
    int mdc_feature;
    PKT_user_id *user_id;
    struct revocation_key *revkey;
    int numrevkeys;
    u32 trust_timestamp;
    byte trust_depth;
    byte trust_value;
    const byte *trust_regexp;
    MPI pkey[4];
} PKT_public_key;





typedef struct {
    u32 timestamp;
    u32 expiredate;
    u32 max_expiredate;
    byte hdrbytes;
    byte version;
    byte pubkey_algo;
    byte pubkey_usage;
    byte req_usage;
    byte req_algo;
    u32 has_expired;
    int is_revoked;
    int is_valid;
    u32 main_keyid[2];
    u32 keyid[2];
    byte is_primary;
    byte is_protected;



    struct {
 byte algo;
        byte sha1chk;
 STRING2KEY s2k;
 byte ivlen;
 byte iv[16];
    } protect;
    MPI skey[6];
    u16 csum;
} PKT_secret_key;


typedef struct {
    int len;
    char data[1];
} PKT_comment;

typedef struct {
    u32 len;
    byte new_ctb;
    byte algorithm;
    IOBUF buf;
} PKT_compressed;

typedef struct {
    u32 len;
    int extralen;
    byte new_ctb;
    byte is_partial;
    byte mdc_method;
    IOBUF buf;
} PKT_encrypted;

typedef struct {
    byte hash[20];
} PKT_mdc;

typedef struct {
    unsigned int trustval;
    unsigned int sigcache;
} PKT_ring_trust;

typedef struct {
    u32 len;
    IOBUF buf;
    byte new_ctb;
    byte is_partial;
    int mode;
    u32 timestamp;
    int namelen;
    char name[1];
} PKT_plaintext;

typedef struct {
    int control;
    size_t datalen;
    char data[1];
} PKT_gpg_control;


struct packet_struct {
    pkttype_t pkttype;
    union {
 void *generic;
 PKT_symkey_enc *symkey_enc;
 PKT_pubkey_enc *pubkey_enc;
 PKT_onepass_sig *onepass_sig;
 PKT_signature *signature;
 PKT_public_key *public_key;
 PKT_secret_key *secret_key;
 PKT_comment *comment;
 PKT_user_id *user_id;
 PKT_compressed *compressed;
 PKT_encrypted *encrypted;
 PKT_mdc *mdc;
 PKT_ring_trust *ring_trust;
 PKT_plaintext *plaintext;
        PKT_gpg_control *gpg_control;
    } pkt;
};





typedef enum {
    SIGSUBPKT_TEST_CRITICAL=-3,
    SIGSUBPKT_LIST_UNHASHED=-2,
    SIGSUBPKT_LIST_HASHED =-1,
    SIGSUBPKT_NONE = 0,
    SIGSUBPKT_SIG_CREATED = 2,
    SIGSUBPKT_SIG_EXPIRE = 3,
    SIGSUBPKT_EXPORTABLE = 4,
    SIGSUBPKT_TRUST = 5,
    SIGSUBPKT_REGEXP = 6,
    SIGSUBPKT_REVOCABLE = 7,
    SIGSUBPKT_KEY_EXPIRE = 9,
    SIGSUBPKT_ARR =10,
    SIGSUBPKT_PREF_SYM =11,
    SIGSUBPKT_REV_KEY =12,
    SIGSUBPKT_ISSUER =16,
    SIGSUBPKT_NOTATION =20,
    SIGSUBPKT_PREF_HASH =21,
    SIGSUBPKT_PREF_COMPR =22,
    SIGSUBPKT_KS_FLAGS =23,
    SIGSUBPKT_PREF_KS =24,
    SIGSUBPKT_PRIMARY_UID =25,
    SIGSUBPKT_POLICY =26,
    SIGSUBPKT_KEY_FLAGS =27,
    SIGSUBPKT_SIGNERS_UID =28,
    SIGSUBPKT_REVOC_REASON =29,
    SIGSUBPKT_FEATURES =30,

    SIGSUBPKT_SIGNATURE =32,

    SIGSUBPKT_FLAG_CRITICAL=128
} sigsubpkttype_t;

struct notation
{
  char *name;
  char *value;
  char *altvalue;
  unsigned char *bdat;
  size_t blen;
  struct
  {
    unsigned int critical:1;
    unsigned int ignore:1;
  } flags;
  struct notation *next;
};


void reset_literals_seen(void);
int proc_packets( void *ctx, IOBUF a );
int proc_signature_packets( void *ctx, IOBUF a,
       STRLIST signedfiles, const char *sigfile );
int proc_encryption_packets( void *ctx, IOBUF a );
int list_packets( IOBUF a );


int set_packet_list_mode( int mode );


int dbg_search_packet( IOBUF inp, PACKET *pkt, off_t *retpos, int with_uid,
                       const char* file, int lineno );
int dbg_parse_packet( IOBUF inp, PACKET *ret_pkt,
                      const char* file, int lineno );
int dbg_copy_all_packets( IOBUF inp, IOBUF out,
                          const char* file, int lineno );
int dbg_copy_some_packets( IOBUF inp, IOBUF out, off_t stopoff,
                           const char* file, int lineno );
int dbg_skip_some_packets( IOBUF inp, unsigned n,
                           const char* file, int lineno );
# 463 "./packet.h"
int parse_signature( IOBUF inp, int pkttype, unsigned long pktlen,
       PKT_signature *sig );
const byte *enum_sig_subpkt ( const subpktarea_t *subpkts,
                              sigsubpkttype_t reqtype,
                              size_t *ret_n, int *start, int *critical );
const byte *parse_sig_subpkt ( const subpktarea_t *buffer,
                               sigsubpkttype_t reqtype,
                               size_t *ret_n );
const byte *parse_sig_subpkt2 ( PKT_signature *sig,
                                sigsubpkttype_t reqtype,
                                size_t *ret_n );
int parse_one_sig_subpkt( const byte *buffer, size_t n, int type );
void parse_revkeys(PKT_signature *sig);
int parse_attribute_subpkts(PKT_user_id *uid);
void make_attribute_uidname(PKT_user_id *uid, size_t max_namelen);
PACKET *create_gpg_control ( ctrlpkttype_t type,
                             const byte *data,
                             size_t datalen );


int build_packet( IOBUF inp, PACKET *pkt );
u32 calc_packet_length( PACKET *pkt );
void build_sig_subpkt( PKT_signature *sig, sigsubpkttype_t type,
   const byte *buffer, size_t buflen );
void build_sig_subpkt_from_sig( PKT_signature *sig );
int delete_sig_subpkt(subpktarea_t *buffer, sigsubpkttype_t type );
void build_attribute_subpkt(PKT_user_id *uid,byte type,
       const void *buf,u32 buflen,
       const void *header,u32 headerlen);
struct notation *string_to_notation(const char *string,int is_utf8);
struct notation *sig_to_notation(PKT_signature *sig);
void free_notation(struct notation *notation);


void free_symkey_enc( PKT_symkey_enc *enc );
void free_pubkey_enc( PKT_pubkey_enc *enc );
void free_seckey_enc( PKT_signature *enc );
int digest_algo_from_sig( PKT_signature *sig );
void release_public_key_parts( PKT_public_key *pk );
void free_public_key( PKT_public_key *key );
void release_secret_key_parts( PKT_secret_key *sk );
void free_secret_key( PKT_secret_key *sk );
void free_attributes(PKT_user_id *uid);
void free_user_id( PKT_user_id *uid );
void free_comment( PKT_comment *rem );
void free_packet( PACKET *pkt );
prefitem_t *copy_prefs (const prefitem_t *prefs);
PKT_public_key *copy_public_key( PKT_public_key *d, PKT_public_key *s );
void copy_public_parts_to_secret_key( PKT_public_key *pk, PKT_secret_key *sk );
PKT_secret_key *copy_secret_key( PKT_secret_key *d, PKT_secret_key *s );
PKT_signature *copy_signature( PKT_signature *d, PKT_signature *s );
PKT_user_id *scopy_user_id (PKT_user_id *sd );
int cmp_public_keys( PKT_public_key *a, PKT_public_key *b );
int cmp_secret_keys( PKT_secret_key *a, PKT_secret_key *b );
int cmp_signatures( PKT_signature *a, PKT_signature *b );
int cmp_public_secret_key( PKT_public_key *pk, PKT_secret_key *sk );
int cmp_user_ids( PKT_user_id *a, PKT_user_id *b );



int signature_check( PKT_signature *sig, MD_HANDLE digest );
int signature_check2( PKT_signature *sig, MD_HANDLE digest, u32 *r_expiredate,
        int *r_expired, int *r_revoked, PKT_public_key *ret_pk );


int is_secret_key_protected( PKT_secret_key *sk );
int check_secret_key( PKT_secret_key *sk, int retries );
int protect_secret_key( PKT_secret_key *sk, DEK *dek );


int get_session_key( PKT_pubkey_enc *k, DEK *dek );
int get_override_session_key( DEK *dek, const char *string );


int handle_compressed( void *ctx, PKT_compressed *cd,
         int (*callback)(IOBUF, void *), void *passthru );


int decrypt_data( void *ctx, PKT_encrypted *ed, DEK *dek );


int handle_plaintext( PKT_plaintext *pt, md_filter_context_t *mfx,
     int nooutput, int clearsig );
int ask_for_detached_datafile( MD_HANDLE md, MD_HANDLE md2,
          const char *inname, int textmode );


int make_keysig_packet( PKT_signature **ret_sig, PKT_public_key *pk,
   PKT_user_id *uid, PKT_public_key *subpk,
   PKT_secret_key *sk, int sigclass, int digest_algo,
   int sigversion, u32 timestamp, u32 duration,
   int (*mksubpkt)(PKT_signature *, void *),
   void *opaque );
int update_keysig_packet( PKT_signature **ret_sig,
                      PKT_signature *orig_sig,
                      PKT_public_key *pk,
                      PKT_user_id *uid,
                      PKT_public_key *subpk,
                      PKT_secret_key *sk,
                      int (*mksubpkt)(PKT_signature *, void *),
                      void *opaque );


PKT_user_id *generate_user_id(void);
# 27 "./keydb.h" 2
# 43 "./keydb.h"
struct getkey_ctx_s;
typedef struct getkey_ctx_s *GETKEY_CTX;
# 54 "./keydb.h"
struct kbnode_struct {
    KBNODE next;
    PACKET *pkt;
    int flag;
    int private_flag;
    ulong recno;
};





enum resource_type {
    rt_UNKNOWN = 0,
    rt_RING = 1
};






struct keyblock_pos_struct {
    int resno;
    enum resource_type rt;
    off_t offset;
    unsigned count;
    IOBUF fp;
    int secret;
    PACKET *pkt;
    int valid;
};
typedef struct keyblock_pos_struct KBPOS;


typedef struct pk_list *PK_LIST;
struct pk_list {
    PK_LIST next;
    PKT_public_key *pk;
    int flags;
};


typedef struct sk_list *SK_LIST;
struct sk_list {
    SK_LIST next;
    PKT_secret_key *sk;
    int mark;
};



typedef struct pubkey_find_info *PUBKEY_FIND_INFO;
struct pubkey_find_info {
    u32 keyid[2];
    unsigned nbits;
    byte pubkey_algo;
    byte fingerprint[20];
    char userid[1];
};


typedef struct keydb_handle *KEYDB_HANDLE;

typedef enum {
    KEYDB_SEARCH_MODE_NONE,
    KEYDB_SEARCH_MODE_EXACT,
    KEYDB_SEARCH_MODE_SUBSTR,
    KEYDB_SEARCH_MODE_MAIL,
    KEYDB_SEARCH_MODE_MAILSUB,
    KEYDB_SEARCH_MODE_MAILEND,
    KEYDB_SEARCH_MODE_WORDS,
    KEYDB_SEARCH_MODE_SHORT_KID,
    KEYDB_SEARCH_MODE_LONG_KID,
    KEYDB_SEARCH_MODE_FPR16,
    KEYDB_SEARCH_MODE_FPR20,
    KEYDB_SEARCH_MODE_FPR,
    KEYDB_SEARCH_MODE_FIRST,
    KEYDB_SEARCH_MODE_NEXT
} KeydbSearchMode;

struct keydb_search_desc {
    KeydbSearchMode mode;
    int (*skipfnc)(void *,u32*,PKT_user_id*);
    void *skipfncvalue;
    union {
        const char *name;
        byte fpr[20];
        u32 kid[2];
    } u;
    int exact;
};







int keydb_add_resource (const char *url, int flags, int secret);
KEYDB_HANDLE keydb_new (int secret);
void keydb_release (KEYDB_HANDLE hd);
const char *keydb_get_resource_name (KEYDB_HANDLE hd);
int keydb_get_keyblock (KEYDB_HANDLE hd, KBNODE *ret_kb);
int keydb_update_keyblock (KEYDB_HANDLE hd, KBNODE kb);
int keydb_insert_keyblock (KEYDB_HANDLE hd, KBNODE kb);
int keydb_delete_keyblock (KEYDB_HANDLE hd);
int keydb_locate_writable (KEYDB_HANDLE hd, const char *reserved);
void keydb_rebuild_caches (int noisy);
int keydb_search_reset (KEYDB_HANDLE hd);

int keydb_search2 (KEYDB_HANDLE hd, KEYDB_SEARCH_DESC *desc,
     size_t ndesc, size_t *descindex);
int keydb_search_first (KEYDB_HANDLE hd);
int keydb_search_next (KEYDB_HANDLE hd);
int keydb_search_kid (KEYDB_HANDLE hd, u32 *kid);
int keydb_search_fpr (KEYDB_HANDLE hd, const byte *fpr);



void show_revocation_reason( PKT_public_key *pk, int mode );
int check_signatures_trust( PKT_signature *sig );
void release_pk_list( PK_LIST pk_list );
int build_pk_list( STRLIST rcpts, PK_LIST *ret_pk_list, unsigned use );
union pref_hint
{
  int digest_length;
};
int algo_available( preftype_t preftype, int algo,
       const union pref_hint *hint );
int select_algo_from_prefs( PK_LIST pk_list, int preftype,
        int request, const union pref_hint *hint );
int select_mdc_from_pklist (PK_LIST pk_list);


void release_sk_list( SK_LIST sk_list );
int build_sk_list( STRLIST locusr, SK_LIST *ret_sk_list,
         int unlock, unsigned use );
# 200 "./keydb.h"
typedef int assuan_error_t;
typedef void *assuan_context_t;

int have_static_passphrase(void);
void set_passphrase_from_string(const char *pass);
void read_passphrase_from_fd( int fd );
void passphrase_clear_cache ( u32 *keyid, const char *cacheid, int algo );
char *ask_passphrase (const char *description,
                      const char *tryagain_text,
                      const char *promptid,
                      const char *prompt,
                      const char *cacheid, int *canceled);
DEK *passphrase_to_dek( u32 *keyid, int pubkey_algo,
   int cipher_algo, STRING2KEY *s2k, int mode,
                        const char *tryagain_text, int *canceled);
void set_next_passphrase( const char *s );
char *get_last_passphrase(void);
void next_to_last_passphrase(void);


int classify_user_id( const char *name, KEYDB_SEARCH_DESC *desc);
void cache_public_key( PKT_public_key *pk );
void getkey_disable_caches(void);
int get_pubkey( PKT_public_key *pk, u32 *keyid );
int get_pubkey_fast ( PKT_public_key *pk, u32 *keyid );
KBNODE get_pubkeyblock( u32 *keyid );
int get_pubkey_byname( PKT_public_key *pk, const char *name,
                       KBNODE *ret_keyblock, KEYDB_HANDLE *ret_kdbhd,
         int include_unusable );
int get_pubkey_bynames( GETKEY_CTX *rx, PKT_public_key *pk,
   STRLIST names, KBNODE *ret_keyblock );
int get_pubkey_next( GETKEY_CTX ctx, PKT_public_key *pk, KBNODE *ret_keyblock );
void get_pubkey_end( GETKEY_CTX ctx );
int get_seckey( PKT_secret_key *sk, u32 *keyid );
int get_primary_seckey( PKT_secret_key *sk, u32 *keyid );
int get_pubkey_byfprint( PKT_public_key *pk, const byte *fprint,
       size_t fprint_len );
int get_pubkey_byfprint_fast (PKT_public_key *pk,
                              const byte *fprint, size_t fprint_len);
int get_keyblock_byfprint( KBNODE *ret_keyblock, const byte *fprint,
       size_t fprint_len );
int get_keyblock_bylid( KBNODE *ret_keyblock, ulong lid );
int seckey_available( u32 *keyid );
int get_seckey_byname( PKT_secret_key *sk, const char *name, int unlock );
int get_seckey_bynames( GETKEY_CTX *rx, PKT_secret_key *sk,
   STRLIST names, KBNODE *ret_keyblock );
int get_seckey_next (GETKEY_CTX ctx, PKT_secret_key *sk, KBNODE *ret_keyblock);
void get_seckey_end( GETKEY_CTX ctx );

int get_seckey_byfprint( PKT_secret_key *sk,
    const byte *fprint, size_t fprint_len);
int get_seckeyblock_byfprint (KBNODE *ret_keyblock, const byte *fprint,
                              size_t fprint_len );


int enum_secret_keys( void **context, PKT_secret_key *sk,
        int with_subkeys, int with_spm );
void merge_keys_and_selfsig( KBNODE keyblock );
char*get_user_id_string( u32 *keyid );
char*get_user_id_string_native( u32 *keyid );
char*get_long_user_id_string( u32 *keyid );
char*get_user_id( u32 *keyid, size_t *rn );
char*get_user_id_native( u32 *keyid );
KEYDB_HANDLE get_ctx_handle(GETKEY_CTX ctx);
void release_akl(void);
int parse_auto_key_locate(char *options);


int pubkey_letter( int algo );
void hash_public_key( MD_HANDLE md, PKT_public_key *pk );
size_t keystrlen(void);
const char *keystr(u32 *keyid);
const char *keystr_from_pk(PKT_public_key *pk);
const char *keystr_from_sk(PKT_secret_key *sk);
const char *keystr_from_desc(KEYDB_SEARCH_DESC *desc);
u32 keyid_from_sk( PKT_secret_key *sk, u32 *keyid );
u32 keyid_from_pk( PKT_public_key *pk, u32 *keyid );
u32 keyid_from_sig( PKT_signature *sig, u32 *keyid );
u32 keyid_from_fingerprint(const byte *fprint, size_t fprint_len, u32 *keyid);
byte *namehash_from_uid(PKT_user_id *uid);
unsigned nbits_from_pk( PKT_public_key *pk );
unsigned nbits_from_sk( PKT_secret_key *sk );
const char *datestr_from_pk( PKT_public_key *pk );
const char *datestr_from_sk( PKT_secret_key *sk );
const char *datestr_from_sig( PKT_signature *sig );
const char *expirestr_from_pk( PKT_public_key *pk );
const char *expirestr_from_sk( PKT_secret_key *sk );
const char *expirestr_from_sig( PKT_signature *sig );
const char *revokestr_from_pk( PKT_public_key *pk );
const char *usagestr_from_pk( PKT_public_key *pk );
const char *colon_strtime (u32 t);
const char *colon_datestr_from_pk (PKT_public_key *pk);
const char *colon_datestr_from_sk (PKT_secret_key *sk);
const char *colon_datestr_from_sig (PKT_signature *sig);
const char *colon_expirestr_from_sig (PKT_signature *sig);
byte *fingerprint_from_sk( PKT_secret_key *sk, byte *buf, size_t *ret_len );
byte *fingerprint_from_pk( PKT_public_key *pk, byte *buf, size_t *ret_len );


KBNODE new_kbnode( PACKET *pkt );
KBNODE clone_kbnode( KBNODE node );
void release_kbnode( KBNODE n );
void delete_kbnode( KBNODE node );
void add_kbnode( KBNODE root, KBNODE node );
void insert_kbnode( KBNODE root, KBNODE node, int pkttype );
void move_kbnode( KBNODE *root, KBNODE node, KBNODE where );
void remove_kbnode( KBNODE *root, KBNODE node );
KBNODE find_prev_kbnode( KBNODE root, KBNODE node, int pkttype );
KBNODE find_next_kbnode( KBNODE node, int pkttype );
KBNODE find_kbnode( KBNODE node, int pkttype );
KBNODE walk_kbnode( KBNODE root, KBNODE *context, int all );
void clear_kbnode_flags( KBNODE n );
int commit_kbnode( KBNODE *root );
void dump_kbnode( KBNODE node );
# 27 "./main.h" 2
# 47 "./main.h"
typedef struct
{
  int header_okay;
  PK_LIST pk_list;
  DEK *symkey_dek;
  STRING2KEY *symkey_s2k;
  cipher_filter_context_t cfx;
} encrypt_filter_context_t;

struct groupitem
{
  char *name;
  STRLIST values;
  struct groupitem *next;
};

struct weakhash
{
  int algo;
  int rejection_shown;
  struct weakhash *next;
};



extern int g10_errors_seen;


  void g10_exit(int rc) __attribute__ ((noreturn));



void print_pubkey_algo_note( int algo );
void print_cipher_algo_note( int algo );
void print_digest_algo_note( int algo );
void additional_weak_digest (const char* digestname);


char *make_radix64_string( const byte *data, size_t len );
int parse_key_failed_line (const void *lineptr, unsigned int len);


void trap_unaligned(void);
int disable_core_dumps(void);
void register_secured_file (const char *fname);
void unregister_secured_file (const char *fname);
int is_secured_file (int fd);
int is_secured_filename (const char *fname);
u16 checksum_u16( unsigned n );
u16 checksum( byte *p, unsigned n );
u16 checksum_mpi( MPI a );
u32 buffer_to_u32( const byte *buffer );
const byte *get_session_marker( size_t *rlen );
int openpgp_cipher_test_algo( int algo );
int openpgp_pk_test_algo( int algo, unsigned int usage_flags );
int openpgp_pk_algo_usage ( int algo );
int openpgp_md_test_algo( int algo );

void md5_digest_warn (int show);

void not_in_gpg1_notice (void);

struct expando_args
{
  PKT_public_key *pk;
  PKT_secret_key *sk;
  byte imagetype;
  int validity_info;
  const char *validity_string;
};

char *pct_expando(const char *string,struct expando_args *args);
void deprecated_warning(const char *configname,unsigned int configlineno,
   const char *option,const char *repl1,const char *repl2);
void deprecated_command (const char *name);

const char *compress_algo_to_string(int algo);
int string_to_compress_algo(const char *string);
int check_compress_algo(int algo);
int default_cipher_algo(void);
int default_compress_algo(void);
const char *compliance_option_string(void);
void compliance_failure(void);

struct parse_options
{
  char *name;
  unsigned int bit;
  char **value;
  char *help;
};

char *optsep(char **stringp);
char *argsplit(char *string);
int parse_options(char *str,unsigned int *options,
    struct parse_options *opts,int noisy);
char *unescape_percent_string (const unsigned char *s);
char *default_homedir (void);
const char *get_libexecdir (void);
int path_access(const char *file,int mode);


void display_online_help( const char *keyword );


int setup_symkey(STRING2KEY **symkey_s2k,DEK **symkey_dek);
int encode_symmetric( const char *filename );
int encode_store( const char *filename );
int encode_crypt( const char *filename, STRLIST remusr, int use_symkey );
void encode_crypt_files(int nfiles, char **files, STRLIST remusr);
int encrypt_filter( void *opaque, int control,
      IOBUF a, byte *buf, size_t *ret_len);



int complete_sig( PKT_signature *sig, PKT_secret_key *sk, MD_HANDLE md );
int sign_file( STRLIST filenames, int detached, STRLIST locusr,
        int do_encrypt, STRLIST remusr, const char *outfile );
int clearsign_file( const char *fname, STRLIST locusr, const char *outfile );
int sign_symencrypt_file (const char *fname, STRLIST locusr);


int check_revocation_keys (PKT_public_key *pk, PKT_signature *sig);
int check_backsig(PKT_public_key *main_pk,PKT_public_key *sub_pk,
    PKT_signature *backsig);
int check_key_signature( KBNODE root, KBNODE node, int *is_selfsig );
int check_key_signature2( KBNODE root, KBNODE node, PKT_public_key *check_pk,
     PKT_public_key *ret_pk, int *is_selfsig,
     u32 *r_expiredate, int *r_expired );


int delete_keys( STRLIST names, int secret, int allow_both );


void keyedit_menu( const char *username, STRLIST locusr,
     STRLIST commands, int quiet, int seckey_check );
void show_basic_key_info (KBNODE keyblock);


u32 parse_expire_string(u32 timestamp,const char *string);
u32 ask_expire_interval(u32 timestamp,int object,const char *def_expire);
void generate_keypair( const char *fname, const char *card_serialno,
                       const char *backup_encryption_dir );
int keygen_set_std_prefs (const char *string,int personal);
PKT_user_id *keygen_get_std_prefs (void);
int keygen_add_key_expire( PKT_signature *sig, void *opaque );
int keygen_add_std_prefs( PKT_signature *sig, void *opaque );
int keygen_upd_std_prefs( PKT_signature *sig, void *opaque );
int keygen_add_keyserver_url(PKT_signature *sig, void *opaque);
int keygen_add_notations(PKT_signature *sig,void *opaque);
int keygen_add_revkey(PKT_signature *sig, void *opaque);
int make_backsig(PKT_signature *sig,PKT_public_key *pk,
   PKT_public_key *sub_pk,PKT_secret_key *sub_sk,
                 u32 timestamp);
int generate_subkeypair( KBNODE pub_keyblock, KBNODE sec_keyblock );

int generate_card_subkeypair (KBNODE pub_keyblock, KBNODE sec_keyblock,
                              int keyno, const char *serialno);
int save_unprotected_key_to_card (PKT_secret_key *sk, int keyno);



int overwrite_filep( const char *fname );
char *make_outfile_name( const char *iname );
char *ask_outfile_name( const char *name, size_t namelen );
int open_outfile( const char *iname, int mode, IOBUF *a );
char *get_matching_datafile (const char *sigfilename);
IOBUF open_sigfile( const char *iname, progress_filter_context_t *pfx );
void try_make_homedir( const char *fname );


void make_session_key( DEK *dek );
MPI encode_session_key( DEK *dek, unsigned nbits );
MPI pkcs1_encode_md( MD_HANDLE md, int algo, size_t len, unsigned nbits,
       const byte *asn, size_t asnlen );
MPI encode_md_value( PKT_public_key *pk, PKT_secret_key *sk,
       MD_HANDLE md, int hash_algo );



typedef int (*import_filter_t)(kbnode_t keyblock, void *arg);

int parse_import_options(char *str,unsigned int *options,int noisy);
void import_keys( char **fnames, int nnames,
    void *stats_hd, unsigned int options );
int import_keys_stream (IOBUF inp,void *stats_hd,unsigned char **fpr,
                        size_t *fpr_len,unsigned int options,
                        import_filter_t filter, void *filter_arg,
                        int *r_gpgkeys_err);
void *import_new_stats_handle (void);
void import_release_stats_handle (void *p);
void import_print_stats (void *hd);

int collapse_uids( KBNODE *keyblock );

int auto_create_card_key_stub ( const char *serialnostr,
                                const unsigned char *fpr1,
                                const unsigned char *fpr2,
                                const unsigned char *fpr3);


int parse_export_options(char *str,unsigned int *options,int noisy);
int export_pubkeys( STRLIST users, unsigned int options );
int export_pubkeys_stream( IOBUF out, STRLIST users,
      KBNODE *keyblock_out, unsigned int options );
int export_seckeys( STRLIST users );
int export_secsubkeys( STRLIST users );


int dearmor_file( const char *fname );
int enarmor_file( const char *fname );


struct revocation_reason_info;
int gen_revoke( const char *uname );
int gen_desig_revoke( const char *uname, STRLIST locusr);
int revocation_reason_build_cb( PKT_signature *sig, void *opaque );
struct revocation_reason_info *
  ask_revocation_reason( int key_rev, int cert_rev, int hint );
void release_revocation_reason_info( struct revocation_reason_info *reason );


void public_key_list( STRLIST list );
void secret_key_list( STRLIST list );
void print_subpackets_colon(PKT_signature *sig);
void reorder_keyblock (KBNODE keyblock);
void list_keyblock( KBNODE keyblock, int secret, int fpr, void *opaque );
void print_fingerprint (PKT_public_key *pk, PKT_secret_key *sk, int mode);
void print_revokers(PKT_public_key *pk);
void show_policy_url(PKT_signature *sig,int indent,int mode);
void show_keyserver_url(PKT_signature *sig,int indent,int mode);
void show_notation(PKT_signature *sig,int indent,int mode,int which);
void dump_attribs(const PKT_user_id *uid,
    PKT_public_key *pk,PKT_secret_key *sk);
void set_attrib_fd(int fd);
void print_seckey_info (PKT_secret_key *sk);
void print_pubkey_info (FILE *fp, PKT_public_key *pk);
void print_card_key_info (FILE *fp, KBNODE keyblock);


void print_file_status( int status, const char *name, int what );
int verify_signatures( int nfiles, char **files );
int verify_files( int nfiles, char **files );


int decrypt_message( const char *filename );
void decrypt_messages(int nfiles, char *files[]);


int hash_datafiles( MD_HANDLE md, MD_HANDLE md2,
      STRLIST files, const char *sigfilename, int textmode );
PKT_plaintext *setup_plaintext_name(const char *filename,IOBUF iobuf);


void run_in_pipemode (void);


void init_signals(void);
void pause_on_sigusr( int which );
void block_all_signals(void);
void unblock_all_signals(void);




void change_pin (int no, int allow_admin);
void card_status (FILE *fp, char *serialno, size_t serialnobuflen);
void card_edit (STRLIST commands);
int card_generate_subkey (KBNODE pub_keyblock, KBNODE sec_keyblock);
int card_store_subkey (KBNODE node, int use);
# 26 "./options.h" 2
# 39 "./options.h"
struct
{
  int verbose;
  int quiet;
  unsigned debug;
  int armor;
  char *outfile;
  off_t max_output;
  int dry_run;
  int list_only;
  int textmode;
  int expert;
  const char *def_sig_expire;
  int ask_sig_expire;
  const char *def_cert_expire;
  int ask_cert_expire;
  int batch;
  int answer_yes;
  int answer_no;
  int check_sigs;
  int with_colons;
  int with_key_data;
  int with_fingerprint;
  int fingerprint;
  int list_sigs;
  int no_armor;
  int list_packets;
  int def_cipher_algo;
  int force_v3_sigs;
  int force_v4_certs;
  int force_mdc;
  int disable_mdc;
  int def_digest_algo;
  int cert_digest_algo;
  int compress_algo;
  int compress_level;
  int bz2_compress_level;
  int bz2_decompress_lowmem;
  const char *def_secret_key;
  char *def_recipient;
  int def_recipient_self;
  int def_cert_level;
  int min_cert_level;
  int ask_cert_level;
  int emit_version;




  int marginals_needed;
  int completes_needed;
  int max_cert_depth;
  const char *homedir;

  char *display;
  char *ttyname;
  char *ttytype;
  char *lc_ctype;
  char *lc_messages;

  int skip_verify;
  int compress_keys;
  int compress_sigs;


  enum
    {
      TM_CLASSIC=0, TM_PGP=1, TM_EXTERNAL=2, TM_ALWAYS, TM_DIRECT, TM_AUTO
    } trust_model;
  int force_ownertrust;
  enum
    {
      CO_GNUPG, CO_RFC4880, CO_RFC2440, CO_RFC1991, CO_PGP2,
      CO_PGP6, CO_PGP7, CO_PGP8
    } compliance;
  enum
    {
      KF_SHORT, KF_LONG, KF_0xSHORT, KF_0xLONG
    } keyid_format;
  int pgp2_workarounds;
  int shm_coprocess;
  const char *set_filename;
  STRLIST comments;
  int throw_keyid;
  const char *photo_viewer;
  int s2k_mode;
  int s2k_digest_algo;
  int s2k_cipher_algo;
  unsigned char s2k_count;

  int simple_sk_checksum;

  int not_dash_escaped;
  int escape_from;
  int lock_once;
  struct keyserver_spec
  {
    char *uri;
    char *scheme;
    char *auth;
    char *host;
    char *port;
    char *path;
    char *opaque;
    STRLIST options;
    struct
    {
      unsigned int direct_uri:1;
    } flags;
    struct keyserver_spec *next;
  } *keyserver;
  struct
  {
    unsigned int options;
    unsigned int import_options;
    unsigned int export_options;
    STRLIST other;
  } keyserver_options;
  int exec_disable;
  int exec_path_set;
  unsigned int import_options;
  unsigned int export_options;
  unsigned int list_options;
  unsigned int verify_options;
  const char *def_preference_list;
  const char *def_keyserver_url;
  prefitem_t *personal_cipher_prefs;
  prefitem_t *personal_digest_prefs;
  prefitem_t *personal_compress_prefs;
  struct weakhash *weak_digests;
  int no_perm_warn;
  int no_mdc_warn;
  char *temp_dir;
  int no_encrypt_to;
  int interactive;
  struct notation *sig_notations;
  struct notation *cert_notations;
  STRLIST sig_policy_url;
  STRLIST cert_policy_url;
  STRLIST sig_keyserver_url;
  STRLIST cert_subpackets;
  STRLIST sig_subpackets;
  int allow_non_selfsigned_uid;
  int allow_freeform_uid;
  int no_literal;
  ulong set_filesize;
  int fast_list_mode;
  int fixed_list_mode;
  int ignore_time_conflict;
  int ignore_valid_from;
  int ignore_crc_error;
  int ignore_mdc_error;
  int command_fd;
  const char *override_session_key;
  int show_session_key;
  int use_agent;
  const char *gpg_agent_info;
  int try_all_secrets;
  int no_expensive_trust_checks;
  int no_sig_cache;
  int no_auto_check_trustdb;
  int preserve_permissions;
  int no_homedir_creation;
  struct groupitem *grouplist;
  int strict;
  int mangle_dos_filenames;
  int enable_progress_filter;
  unsigned int screen_columns;
  unsigned int screen_lines;
  byte *show_subpackets;
  int rfc2440_text;


  int exit_on_status_write_error;



  int limit_card_insert_tries;


  const char *ctapi_driver;
  const char *pcsc_driver;
  int disable_ccid;
  int disable_keypad;


  struct
  {



    unsigned int require_cross_cert:1;
    unsigned int use_embedded_filename:1;
    unsigned int utf8_filename:1;
    unsigned int dsa2:1;
    unsigned int allow_multiple_messages:1;
    unsigned int allow_weak_digest_algos:1;
    unsigned int large_rsa:1;
  } flags;



  struct akl
  {
    enum {AKL_CERT, AKL_PKA, AKL_LDAP, AKL_KEYSERVER, AKL_SPEC} type;
    struct keyserver_spec *spec;
    struct akl *next;
  } *auto_key_locate;

  int passwd_repeat;
} opt;





struct {
  int in_auto_key_retrieve;

} glo_ctrl;
# 33 "keyedit.c" 2

# 1 "../include/errors.h" 1
# 35 "keyedit.c" 2



# 1 "./photoid.h" 1
# 27 "./photoid.h"
PKT_user_id *generate_photo_id(PKT_public_key *pk,const char *filename);
int parse_image_header(const struct user_attribute *attr,byte *type,u32 *len);
char *image_type_to_string(byte type,int style);
void show_photos(const struct user_attribute *attrs,int count,
   PKT_public_key *pk,PKT_secret_key *sk,PKT_user_id *uid);
# 39 "keyedit.c" 2
# 1 "../include/util.h" 1
# 23 "../include/util.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 1 3
# 14 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 1 3
# 47 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_header_macro.h" 1 3
# 48 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3



# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___gnuc_va_list.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___gnuc_va_list.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 52 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_list.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_list.h" 3
typedef __builtin_va_list va_list;
# 57 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_arg.h" 1 3
# 62 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___va_copy.h" 1 3
# 67 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_copy.h" 1 3
# 72 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 2 3
# 24 "../include/util.h" 2





# 1 "../include/compat.h" 1







int hextobyte( const char *s );
int ascii_toupper (int c);
int ascii_tolower (int c);
int ascii_strcasecmp( const char *a, const char *b );
int ascii_strncasecmp( const char *a, const char *b, size_t n);






char *xstrconcat (const char *s1, ...) __attribute__ ((sentinel(0)));
# 30 "../include/util.h" 2
# 39 "../include/util.h"
typedef struct {
     int *argc;
     char ***argv;
     unsigned flags;
     int err;

     int r_opt;
     int r_type;
     union {
  int ret_int;
  long ret_long;
  ulong ret_ulong;
  char *ret_str;
     } r;
     struct {
  int idx;
  int inarg;
  int stopped;
  const char *last;
  void *aliases;
  const void *cur_alias;
         void *iio_list;
     } internal;
} ARGPARSE_ARGS;

typedef struct {
    int short_opt;
    const char *long_opt;
    unsigned flags;
    const char *description;
} ARGPARSE_OPTS;


void log_set_logfile( const char *name, int fd );
FILE *log_stream(void);
void g10_log_print_prefix(const char *text);
void log_set_name( const char *name );
const char *log_get_name(void);
void log_set_pid( int pid );
int log_get_errorcount( int clear );
void log_inc_errorcount(void);
int log_set_strict(int val);
void g10_log_hexdump( const char *text, const char *buf, size_t len );



  void g10_log_bug( const char *fmt, ... )
       __attribute__ ((noreturn, format (printf,1,2)));
  void g10_log_bug0( const char *, int, const char * ) __attribute__ ((noreturn));
  void g10_log_fatal( const char *fmt, ... )
       __attribute__ ((noreturn, format (printf,1,2)));
  void g10_log_error( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_info( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_warning( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_debug( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
# 121 "../include/util.h"
const char * g10_errstr( int no );


int arg_parse( ARGPARSE_ARGS *arg, ARGPARSE_OPTS *opts);
int optfile_parse( FILE *fp, const char *filename, unsigned *lineno,
     ARGPARSE_ARGS *arg, ARGPARSE_OPTS *opts);
void usage( int level );
const char *default_strusage( int level );



const char *strusage( int level );



# 1 "../include/../include/dotlock.h" 1
# 97 "../include/../include/dotlock.h"
struct dotlock_handle;
typedef struct dotlock_handle *dotlock_t;

void dotlock_disable (void);
dotlock_t dotlock_create (const char *file_to_lock, unsigned int flags);
void dotlock_set_fd (dotlock_t h, int fd);
int dotlock_get_fd (dotlock_t h);
void dotlock_destroy (dotlock_t h, int reclaim);
int dotlock_take (dotlock_t h, long timeout);
int dotlock_release (dotlock_t h);
void dotlock_remove_lockfiles (int reclaim);
void dotlock_remove_lockfiles_reclaim (void);
# 137 "../include/util.h" 2


char * make_basename(const char *filepath, const char *inputpath);
char * make_dirname(const char *filepath);
char *make_filename( const char *first_part, ... );
int compare_filenames( const char *a, const char *b );
int same_file_p (const char *name1, const char *name2);
const char *print_fname_stdin( const char *s );
const char *print_fname_stdout( const char *s );
int is_file_compressed(const char *s, int *r_status);


u32 make_timestamp(void);
u32 scan_isodatestr( const char *string );
u32 isotime2seconds (const char *string);
const char *strtimevalue( u32 stamp );
const char *strtimestamp( u32 stamp );
const char *isotimestamp( u32 stamp );
const char *asctimestamp( u32 stamp );
void print_string( FILE *fp, const byte *p, size_t n, int delim );
void print_string2( FILE *fp, const byte *p, size_t n, int delim, int delim2 );
void print_utf8_string( FILE *fp, const byte *p, size_t n );
void print_utf8_string2( FILE *fp, const byte *p, size_t n, int delim);
char *make_printable_string( const byte *p, size_t n, int delim );
int answer_is_yes_no_default( const char *s, int def_answer );
int answer_is_yes( const char *s );
int answer_is_yes_no_quit( const char *s );
int answer_is_okay_cancel (const char *s, int def_answer);
int match_multistr(const char *multistr,const char *match);


void free_strlist( STRLIST sl );

STRLIST add_to_strlist( STRLIST *list, const char *string );
STRLIST add_to_strlist2( STRLIST *list, const char *string, int is_utf8 );
STRLIST append_to_strlist( STRLIST *list, const char *string );
STRLIST append_to_strlist2( STRLIST *list, const char *string, int is_utf8 );
STRLIST strlist_prev( STRLIST head, STRLIST node );
STRLIST strlist_last( STRLIST node );
char *pop_strlist( STRLIST *list );
const char *memistr( const char *buf, size_t buflen, const char *sub );
const char *ascii_memistr( const char *buf, size_t buflen, const char *sub );
char *mem2str( char *, const void *, size_t);
char *trim_spaces( char *string );
unsigned int trim_trailing_chars( byte *line, unsigned int len,
                                  const char *trimchars);
unsigned int trim_trailing_ws( byte *line, unsigned len );
unsigned int check_trailing_chars( const byte *line, unsigned int len,
                                   const char *trimchars );
unsigned int check_trailing_ws( const byte *line, unsigned int len );
int string_count_chr( const char *string, int c );
int has_invalid_email_chars (const char *s);
int is_valid_mailbox (const char *name);
int set_native_charset( const char *newset );
const char* get_native_charset(void);
char *native_to_utf8( const char *string );
char *utf8_to_native( const char *string, size_t length, int delim);
char *string_to_utf8 (const char *string);

int ascii_isupper (int c);
int ascii_islower (int c);
int ascii_memcasecmp( const char *a, const char *b, size_t n);
char *ascii_strlwr (char *s);
# 223 "../include/util.h"
struct private_membuf_s {
  size_t len;
  size_t size;
  char *buf;
  int out_of_core;
};

typedef struct private_membuf_s membuf_t;

void init_membuf (membuf_t *mb, int initiallen);
void put_membuf (membuf_t *mb, const void *buf, size_t len);
void put_membuf_str (membuf_t *mb, const char *buf);
void *get_membuf (membuf_t *mb, size_t *len);
# 249 "../include/util.h"
char *xasprintf (const char *fmt, ...);
char *xtryasprintf (const char *fmt, ...);
char *xtryvasprintf (const char *fmt, va_list arg_ptr);
char *strconcat (const char *s1, ...) __attribute__ ((sentinel(0)));


char *get_pka_info (const char *address, void *fprbuf, size_t fprbuflen);


int get_cert (const char *name, int want_ipgp, size_t max_size, IOBUF *iobuf,
              unsigned char **fpr,size_t *fpr_len,char **url);


int hex2bin (const char *string, void *buffer, size_t length);
int hexcolon2bin (const char *string, void *buffer, size_t length);
char *bin2hex (const void *buffer, size_t length, char *stringbuf);
char *bin2hexcolon (const void *buffer, size_t length, char *stringbuf);
const char *hex2str (const char *hexstring,
                     char *buffer, size_t bufsize, size_t *buflen);
char *hex2str_alloc (const char *hexstring, size_t *r_count);
# 40 "keyedit.c" 2

# 1 "./trustdb.h" 1
# 43 "./trustdb.h"
void register_trusted_keyid(u32 *keyid);
void register_trusted_key( const char *string );
void check_trustdb (void);
void update_trustdb (void);
int setup_trustdb( int level, const char *dbname );
void how_to_fix_the_trustdb (void);
void init_trustdb( void );
void check_trustdb_stale(void);
void sync_trustdb( void );

const char *uid_trust_string_fixed(PKT_public_key *key,PKT_user_id *uid);
const char *trust_value_to_string (unsigned int value);
int string_to_trust_value (const char *str);

void revalidation_mark (void);
int trustdb_pending_check(void);
void trustdb_check_or_update(void);

int cache_disabled_value(PKT_public_key *pk);

unsigned int get_validity (PKT_public_key *pk, PKT_user_id *uid);
int get_validity_info (PKT_public_key *pk, PKT_user_id *uid);
const char *get_validity_string (PKT_public_key *pk, PKT_user_id *uid);

void list_trust_path( const char *username );
int enum_cert_paths( void **context, ulong *lid,
       unsigned *ownertrust, unsigned *validity );
void enum_cert_paths_print( void **context, FILE *fp,
        int refresh, ulong selected_lid );

void read_trust_options(byte *trust_model,ulong *created,ulong *nextcheck,
   byte *marginals,byte *completes,byte *cert_depth,
   byte *min_cert_level);

unsigned int get_ownertrust (PKT_public_key *pk);
unsigned int get_min_ownertrust (PKT_public_key *pk);
int get_ownertrust_info (PKT_public_key *pk);
const char *get_ownertrust_string (PKT_public_key *pk);

void update_ownertrust (PKT_public_key *pk, unsigned int new_trust );
int clear_ownertrusts (PKT_public_key *pk);

void clean_one_uid(KBNODE keyblock,KBNODE uidnode,int noisy,int self_only,
     int *uids_cleaned,int *sigs_cleaned);
void clean_key(KBNODE keyblock,int noisy,int self_only,
        int *uids_cleaned,int *sigs_cleaned);


void list_trustdb(const char *username);
void export_ownertrust(void);
void import_ownertrust(const char *fname);


int edit_ownertrust (PKT_public_key *pk, int mode );
# 42 "keyedit.c" 2

# 1 "../include/ttyio.h" 1
# 27 "../include/ttyio.h"
const char *tty_get_ttyname (void);
int tty_batchmode( int onoff );

 void tty_printf (const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
 void tty_fprintf (FILE *fp, const char *fmt, ... )
                                __attribute__ ((format (printf,2,3)));




void tty_print_string( const byte *p, size_t n );
void tty_print_utf8_string( const byte *p, size_t n );
void tty_print_utf8_string2( const byte *p, size_t n, size_t max_n );
char *tty_get( const char *prompt );
char *tty_get_hidden( const char *prompt );
void tty_kill_prompt(void);
int tty_get_answer_is_yes( const char *prompt );
int tty_no_terminal(int onoff);
# 61 "../include/ttyio.h"
void tty_cleanup_after_signal (void);
# 44 "keyedit.c" 2
# 1 "./status.h" 1
# 128 "./status.h"
void set_status_fd ( int fd );
int is_status_enabled ( void );
void write_status ( int no );
void write_status_text ( int no, const char *text );
void write_status_buffer ( int no,
                           const char *buffer, size_t len, int wrap );
void write_status_text_and_buffer ( int no, const char *text,
                                    const char *buffer, size_t len, int wrap );


  void init_shm_coprocessing ( ulong requested_shm_size, int lock_mem );


int cpr_enabled(void);
char *cpr_get( const char *keyword, const char *prompt );
char *cpr_get_no_help( const char *keyword, const char *prompt );
char *cpr_get_utf8( const char *keyword, const char *prompt );
char *cpr_get_hidden( const char *keyword, const char *prompt );
void cpr_kill_prompt(void);
int cpr_get_answer_is_yes( const char *keyword, const char *prompt );
int cpr_get_answer_yes_no_quit( const char *keyword, const char *prompt );
int cpr_get_answer_okay_cancel (const char *keyword,
                                 const char *prompt,
                                 int def_answer);
# 45 "keyedit.c" 2
# 1 "../include/i18n.h" 1
# 32 "../include/i18n.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 1 3
# 26 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 3
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;

 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_p_sep_by_space;
 char int_n_cs_precedes;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};


char *setlocale (int, const char *);
struct lconv *localeconv(void);







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 65 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 2 3
# 76 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 3
locale_t duplocale(locale_t);
void freelocale(locale_t);
locale_t newlocale(int, const char *, locale_t);
locale_t uselocale(locale_t);
# 33 "../include/i18n.h" 2




# 1 "../intl/libintl.h" 1
# 58 "../intl/libintl.h"
extern int libintl_version;
# 134 "../intl/libintl.h"
extern char *gettext (const char *__msgid)
       __asm__ ("" "libintl_gettext")
       __attribute__ ((__format_arg__ (1)));
# 152 "../intl/libintl.h"
extern char *dgettext (const char *__domainname, const char *__msgid)
       __asm__ ("" "libintl_dgettext")
       __attribute__ ((__format_arg__ (2)));
# 172 "../intl/libintl.h"
extern char *dcgettext (const char *__domainname, const char *__msgid,
                        int __category)
       __asm__ ("" "libintl_dcgettext")
       __attribute__ ((__format_arg__ (2)));
# 194 "../intl/libintl.h"
extern char *ngettext (const char *__msgid1, const char *__msgid2,
                       unsigned long int __n)
       __asm__ ("" "libintl_ngettext")
       __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));
# 215 "../intl/libintl.h"
extern char *dngettext (const char *__domainname,
                        const char *__msgid1, const char *__msgid2,
                        unsigned long int __n)
       __asm__ ("" "libintl_dngettext")
       __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
# 239 "../intl/libintl.h"
extern char *dcngettext (const char *__domainname,
                         const char *__msgid1, const char *__msgid2,
                         unsigned long int __n, int __category)
       __asm__ ("" "libintl_dcngettext")
       __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
# 261 "../intl/libintl.h"
extern char *textdomain (const char *__domainname)
       __asm__ ("" "libintl_textdomain");
# 279 "../intl/libintl.h"
extern char *bindtextdomain (const char *__domainname, const char *__dirname)
       __asm__ ("" "libintl_bindtextdomain");
# 297 "../intl/libintl.h"
extern char *bind_textdomain_codeset (const char *__domainname,
                                      const char *__codeset)
       __asm__ ("" "libintl_bind_textdomain_codeset");
# 455 "../intl/libintl.h"
extern void
       libintl_set_relocation_prefix (const char *orig_prefix,
                                      const char *curr_prefix);
# 38 "../include/i18n.h" 2
# 46 "keyedit.c" 2
# 1 "./keyserver-internal.h" 1
# 23 "./keyserver-internal.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/time.h" 1 3







int dysize(int year);







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 1 3
# 33 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 34 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 2 3






struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 const char *tm_zone;
};

clock_t clock (void);
time_t time (time_t *);
double difftime (time_t, time_t);
time_t mktime (struct tm *);
size_t strftime (char *restrict, size_t, const char *restrict, const struct tm *restrict);
struct tm *gmtime (const time_t *);
struct tm *localtime (const time_t *);
char *asctime (const struct tm *);
char *ctime (const time_t *);
int timespec_get(struct timespec *, int);
# 73 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 3
size_t strftime_l (char * restrict, size_t, const char * restrict, const struct tm * restrict, locale_t);

struct tm *gmtime_r (const time_t *restrict, struct tm *restrict);
struct tm *localtime_r (const time_t *restrict, struct tm *restrict);
char *asctime_r (const struct tm *restrict, char *restrict);
char *ctime_r (const time_t *, char *);

void tzset (void);

struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};
# 102 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 3
int nanosleep (const struct timespec *, struct timespec *);
int clock_getres (clockid_t, struct timespec *);
int clock_gettime (clockid_t, struct timespec *);
int clock_settime (clockid_t, const struct timespec *);
int clock_nanosleep (clockid_t, int, const struct timespec *, struct timespec *);
int clock_getcpuclockid (pid_t, clockid_t *);

struct sigevent;
int timer_create (clockid_t, struct sigevent *restrict, timer_t *restrict);
int timer_delete (timer_t);
int timer_settime (timer_t, int, const struct itimerspec *restrict, struct itimerspec *restrict);
int timer_gettime (timer_t, struct itimerspec *);
int timer_getoverrun (timer_t);

extern char *tzname[2];





char *strptime (const char *restrict, const char *restrict, struct tm *restrict);
extern int daylight;
extern long timezone;
extern int getdate_err;
struct tm *getdate (const char *);




int stime(const time_t *);
time_t timegm(struct tm *);
# 17 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/time.h" 2 3
# 24 "./keyserver-internal.h" 2
# 1 "../include/keyserver.h" 1
# 25 "./keyserver-internal.h" 2



int parse_keyserver_options(char *options);
void free_keyserver_spec(struct keyserver_spec *keyserver);
struct keyserver_spec *keyserver_match(struct keyserver_spec *spec);
struct keyserver_spec *parse_keyserver_uri(const char *string,
        int require_scheme,
        const char *configname,
        unsigned int configlineno);
struct keyserver_spec *parse_preferred_keyserver(PKT_signature *sig);
int keyserver_export(STRLIST users);
int keyserver_import(STRLIST users);
int keyserver_import_fprint(const byte *fprint,size_t fprint_len,
       struct keyserver_spec *keyserver);
int keyserver_import_keyid(u32 *keyid,struct keyserver_spec *keyserver);
int keyserver_refresh(STRLIST users);
int keyserver_search(STRLIST tokens);
int keyserver_fetch(STRLIST urilist);
int keyserver_import_cert(const char *name,
     unsigned char **fpr,size_t *fpr_len);
int keyserver_import_pka(const char *name,unsigned char **fpr,size_t *fpr_len);
int keyserver_import_name(const char *name,unsigned char **fpr,size_t *fpr_len,
     struct keyserver_spec *keyserver);
int keyserver_import_ldap(const char *name,
     unsigned char **fpr,size_t *fpr_len);
# 47 "keyedit.c" 2

static void show_prefs( PKT_user_id *uid, PKT_signature *selfsig, int verbose);
static void show_names(KBNODE keyblock,PKT_public_key *pk,
         unsigned int flag,int with_prefs);
static void show_key_with_all_names( KBNODE keyblock, int only_marked,
     int with_revoker, int with_fpr, int with_subkeys, int with_prefs );
static void show_key_and_fingerprint( KBNODE keyblock );
static void subkey_expire_warning (kbnode_t keyblock);
static int menu_adduid( KBNODE keyblock, KBNODE sec_keyblock,
   int photo, const char *photo_name );
static void menu_deluid( KBNODE pub_keyblock, KBNODE sec_keyblock );
static int menu_delsig( KBNODE pub_keyblock );
static int menu_clean(KBNODE keyblock,int self_only);
static void menu_delkey( KBNODE pub_keyblock, KBNODE sec_keyblock );
static int menu_addrevoker( KBNODE pub_keyblock,
       KBNODE sec_keyblock, int sensitive );
static int menu_expire( KBNODE pub_keyblock, KBNODE sec_keyblock );
static int menu_backsign(KBNODE pub_keyblock,KBNODE sec_keyblock);
static int menu_set_primary_uid( KBNODE pub_keyblock, KBNODE sec_keyblock );
static int menu_set_preferences( KBNODE pub_keyblock, KBNODE sec_keyblock );
static int menu_set_keyserver_url (const char *url,
       KBNODE pub_keyblock, KBNODE sec_keyblock );
static int menu_set_notation(const char *string,
        KBNODE pub_keyblock,KBNODE sec_keyblock);
static int menu_select_uid( KBNODE keyblock, int idx );
static int menu_select_uid_namehash( KBNODE keyblock, const char *namehash );
static int menu_select_key( KBNODE keyblock, int idx );
static int count_uids( KBNODE keyblock );
static int count_uids_with_flag( KBNODE keyblock, unsigned flag );
static int count_keys_with_flag( KBNODE keyblock, unsigned flag );
static int count_selected_uids( KBNODE keyblock );
static int real_uids_left( KBNODE keyblock );
static int count_selected_keys( KBNODE keyblock );
static int menu_revsig( KBNODE keyblock );
static int menu_revuid( KBNODE keyblock, KBNODE sec_keyblock );
static int menu_revkey( KBNODE pub_keyblock, KBNODE sec_keyblock );
static int menu_revsubkey( KBNODE pub_keyblock, KBNODE sec_keyblock );
static int enable_disable_key( KBNODE keyblock, int disable );
static void menu_showphoto( KBNODE keyblock );

static int update_trust=0;
# 102 "keyedit.c"
struct sign_attrib {
    int non_exportable,non_revocable;
    struct revocation_reason_info *reason;
    byte trust_depth,trust_value;
    char *trust_regexp;
};





static PKT_public_key *
find_pk_from_sknode (KBNODE pub_keyblock, KBNODE sec_node)
{
  KBNODE node = pub_keyblock;
  PKT_secret_key *sk;
  PKT_public_key *pk;

  if (sec_node->pkt->pkttype == PKT_SECRET_KEY
      && node->pkt->pkttype == PKT_PUBLIC_KEY)
    return node->pkt->pkt.public_key;
  if (sec_node->pkt->pkttype != PKT_SECRET_SUBKEY)
    return ((void*)0);
  sk = sec_node->pkt->pkt.secret_key;
  for (; node; node = node->next)
    if (node->pkt->pkttype == PKT_PUBLIC_SUBKEY)
      {
        pk = node->pkt->pkt.public_key;
        if (pk->keyid[0] == sk->keyid[0] && pk->keyid[1] == sk->keyid[1])
          return pk;
      }

  return ((void*)0);
}





static int
print_and_check_one_sig_colon( KBNODE keyblock, KBNODE node,
          int *inv_sigs, int *no_key, int *oth_err,
          int *is_selfsig, int print_without_key )
{
  PKT_signature *sig = node->pkt->pkt.signature;
  int rc, sigrc;




  switch((rc=check_key_signature(keyblock,node,is_selfsig)))
    {
    case 0:
      node->flag &= ~((1<<0)|(1<<1)|(1<<2));
      sigrc = '!';
      break;
    case 8:
      node->flag = (1<<0);
      sigrc = '-';
      if( inv_sigs )
 ++*inv_sigs;
      break;
    case 9:
    case 53:
      node->flag = (1<<1);
      sigrc = '?';
      if( no_key )
 ++*no_key;
      break;
    default:
      node->flag = (1<<2);
      sigrc = '%';
      if( oth_err )
 ++*oth_err;
      break;
    }

  if( sigrc != '?' || print_without_key )
    {
      printf("sig:%c::%d:%08lX%08lX:%lu:%lu:",
      sigrc,sig->pubkey_algo,(ulong)sig->keyid[0],(ulong)sig->keyid[1],
      (ulong)sig->timestamp,(ulong)sig->expiredate);

      if(sig->trust_depth || sig->trust_value)
 printf("%d %d",sig->trust_depth,sig->trust_value);

      printf(":");

      if(sig->trust_regexp)
 print_string((stdout),sig->trust_regexp,strlen(sig->trust_regexp),':');

      printf("::%02x%c\n",sig->sig_class,sig->flags.exportable?'x':'l');

      if(opt.show_subpackets)
       print_subpackets_colon(sig);
    }

  return (sigrc == '!');
}






static int
print_and_check_one_sig( KBNODE keyblock, KBNODE node,
    int *inv_sigs, int *no_key, int *oth_err,
   int *is_selfsig, int print_without_key )
{
    PKT_signature *sig = node->pkt->pkt.signature;
    int rc, sigrc;
    int is_rev = sig->sig_class == 0x30;




    switch( (rc = check_key_signature( keyblock, node, is_selfsig)) ) {
      case 0:
 node->flag &= ~((1<<0)|(1<<1)|(1<<2));
 sigrc = '!';
 break;
      case 8:
 node->flag = (1<<0);
 sigrc = '-';
 if( inv_sigs )
     ++*inv_sigs;
 break;
      case 9:
      case 53:
 node->flag = (1<<1);
 sigrc = '?';
 if( no_key )
     ++*no_key;
 break;
      default:
 node->flag = (1<<2);
 sigrc = '%';
 if( oth_err )
     ++*oth_err;
 break;
    }
    if( sigrc != '?' || print_without_key ) {
        tty_printf("%s%c%c %c%c%c%c%c%c %s %s",
     is_rev? "rev":"sig",sigrc,
     (sig->sig_class-0x10>0 &&
      sig->sig_class-0x10<4)?'0'+sig->sig_class-0x10:' ',
     sig->flags.exportable?' ':'L',
     sig->flags.revocable?' ':'R',
     sig->flags.policy_url?'P':' ',
     sig->flags.notation?'N':' ',
                   sig->flags.expired?'X':' ',
     (sig->trust_depth>9)?'T':
     (sig->trust_depth>0)?'0'+sig->trust_depth:' ',
     keystr(sig->keyid),datestr_from_sig(sig));
 if(opt.list_options&(1<<9))
   tty_printf(" %s",expirestr_from_sig(sig));
 tty_printf("  ");
 if( sigrc == '%' )
     tty_printf("[%s] ", g10_errstr(rc) );
 else if( sigrc == '?' )
     ;
 else if( *is_selfsig ) {
     tty_printf( is_rev? gettext ("[revocation]")
         : gettext ("[self-signature]") );
 }
 else
   {
     size_t n;
     char *p = get_user_id( sig->keyid, &n );
     tty_print_utf8_string2(p, n, opt.screen_columns-keystrlen()-26-
          ((opt.list_options&(1<<9))?11:0));
     xfree(p);
   }
 tty_printf("\n");

 if(sig->flags.policy_url && (opt.list_options&(1<<1)))
   show_policy_url(sig,3,0);

 if(sig->flags.notation && (opt.list_options&((1<<2)|(1<<3))))
   show_notation(sig,3,0,
   ((opt.list_options&(1<<2))?1:0)+
   ((opt.list_options&(1<<3))?2:0));

 if(sig->flags.pref_ks && (opt.list_options&(1<<4)))
   show_keyserver_url(sig,3,0);
    }

    return (sigrc == '!');
}







static int
check_all_keysigs( KBNODE keyblock, int only_selected )
{
    KBNODE kbctx;
    KBNODE node;
    int inv_sigs = 0;
    int no_key = 0;
    int oth_err = 0;
    int has_selfsig = 0;
    int mis_selfsig = 0;
    int selected = !only_selected;
    int anyuid = 0;

    for( kbctx=((void*)0); (node=walk_kbnode( keyblock, &kbctx, 0)) ; ) {
 if( node->pkt->pkttype == PKT_USER_ID ) {
     PKT_user_id *uid = node->pkt->pkt.user_id;

     if( only_selected )
  selected = (node->flag & (1<<8));
     if( selected ) {
  tty_printf("uid  ");
  tty_print_utf8_string( uid->name, uid->len );
  tty_printf("\n");
  if( anyuid && !has_selfsig )
      mis_selfsig++;
  has_selfsig = 0;
  anyuid = 1;
     }
 }
 else if( selected && node->pkt->pkttype == PKT_SIGNATURE
   && ( (node->pkt->pkt.signature->sig_class&~3) == 0x10
       || node->pkt->pkt.signature->sig_class == 0x30 ) ) {
     int selfsig;

     if( print_and_check_one_sig( keyblock, node, &inv_sigs,
     &no_key, &oth_err, &selfsig, 0 ) ) {
  if( selfsig )
      has_selfsig = 1;
     }

 }
    }
    if( !has_selfsig )
 mis_selfsig++;
    if( inv_sigs == 1 )
 tty_printf(gettext ("1 bad signature\n") );
    else if( inv_sigs )
 tty_printf(gettext ("%d bad signatures\n"), inv_sigs );
    if( no_key == 1 )
 tty_printf(gettext ("1 signature not checked due to a missing key\n") );
    else if( no_key )
 tty_printf(gettext ("%d signatures not checked due to missing keys\n"), no_key );
    if( oth_err == 1 )
 tty_printf(gettext ("1 signature not checked due to an error\n") );
    else if( oth_err )
 tty_printf(gettext ("%d signatures not checked due to errors\n"), oth_err );
    if( mis_selfsig == 1 )
 tty_printf(gettext ("1 user ID without valid self-signature detected\n"));
    else if( mis_selfsig )
 tty_printf(gettext ("%d user IDs without valid self-signatures detected\n"),
            mis_selfsig);

    return inv_sigs || no_key || oth_err || mis_selfsig;
}


static int
sign_mk_attrib( PKT_signature *sig, void *opaque )
{
    struct sign_attrib *attrib = opaque;
    byte buf[8];

    if( attrib->non_exportable ) {
 buf[0] = 0;
 build_sig_subpkt( sig, SIGSUBPKT_EXPORTABLE, buf, 1 );
    }

    if( attrib->non_revocable ) {
 buf[0] = 0;
 build_sig_subpkt( sig, SIGSUBPKT_REVOCABLE, buf, 1 );
    }

    if( attrib->reason )
 revocation_reason_build_cb( sig, attrib->reason );

    if(attrib->trust_depth)
      {


        buf[0] = attrib->trust_depth;
 buf[1] = attrib->trust_value;
 build_sig_subpkt(sig,SIGSUBPKT_TRUST,buf,2);




 if(attrib->trust_regexp)
   build_sig_subpkt(sig,SIGSUBPKT_FLAG_CRITICAL|SIGSUBPKT_REGEXP,
      attrib->trust_regexp,
      strlen(attrib->trust_regexp)+1);
      }

    return 0;
}

static void
trustsig_prompt(byte *trust_value,byte *trust_depth,char **regexp)
{
  char *p;

  *trust_value=0;
  *trust_depth=0;
  *regexp=((void*)0);


  tty_printf(gettext ("Please decide how far you trust this user to correctly verify" " other users' keys\n(by looking at passports, checking" " fingerprints from different sources, etc.)\n"));


  tty_printf("\n");
  tty_printf (gettext ("  %d = I trust marginally\n"), 1);
  tty_printf (gettext ("  %d = I trust fully\n"), 2);
  tty_printf("\n");

  while(*trust_value==0)
    {
      p = cpr_get("trustsig_prompt.trust_value",gettext ("Your selection? "));
      trim_spaces(p);
      cpr_kill_prompt();

      if(p[0]=='1' && !p[1])
 *trust_value=60;
      else if(p[0]=='2' && !p[1])
 *trust_value=120;
      xfree(p);
    }

  tty_printf("\n");

  tty_printf(gettext ("Please enter the depth of this trust signature.\n" "A depth greater than 1 allows the key you are signing to make\n" "trust signatures on your behalf.\n"));



  tty_printf("\n");

  while(*trust_depth==0)
    {
      p = cpr_get("trustsig_prompt.trust_depth",gettext ("Your selection? "));
      trim_spaces(p);
      cpr_kill_prompt();
      *trust_depth=atoi(p);
      xfree(p);
    }

  tty_printf("\n");

  tty_printf(gettext ("Please enter a domain to restrict this signature, " "or enter for none.\n"));


  tty_printf("\n");

  p=cpr_get("trustsig_prompt.trust_regexp",gettext ("Your selection? "));
  trim_spaces(p);
  cpr_kill_prompt();

  if(strlen(p)>0)
    {
      char *q=p;
      int regexplen=100,ind;

      *regexp=xmalloc(regexplen);





      strcpy(*regexp,"<[^>]+[@.]");
      ind=strlen(*regexp);

      while(*q)
 {
   if(!((*q>='A' && *q<='Z')
        || (*q>='a' && *q<='z') || (*q>='0' && *q<='9')))
     (*regexp)[ind++]='\\';

   (*regexp)[ind++]=*q;

   if((regexplen-ind)<3)
     {
       regexplen+=100;
       *regexp=xrealloc(*regexp,regexplen);
     }

   q++;
 }

      (*regexp)[ind]='\0';
      strcat(*regexp,">$");
    }

  xfree(p);
  tty_printf("\n");
}






static int
sign_uids( KBNODE keyblock, STRLIST locusr, int *ret_modified,
    int local, int nonrevocable, int trust, int interactive )
{
    int rc = 0;
    SK_LIST sk_list = ((void*)0);
    SK_LIST sk_rover = ((void*)0);
    PKT_secret_key *sk = ((void*)0);
    KBNODE node, uidnode;
    PKT_public_key *primary_pk=((void*)0);
    int select_all = !count_selected_uids(keyblock) || interactive;
    int all_v3=1;
    u32 timestamp=make_timestamp();


    if((opt.compliance==CO_PGP2))
      for(node=keyblock;node;node=node->next)
 if(node->pkt->pkttype==PKT_SIGNATURE &&
    node->pkt->pkt.signature->version>3)
   {
     all_v3=0;
     break;
   }
# 538 "keyedit.c"
    rc=build_sk_list( locusr, &sk_list, 0, 4);
    if( rc )
 goto leave;


    for( sk_rover = sk_list; sk_rover; sk_rover = sk_rover->next ) {
        u32 sk_keyid[2],pk_keyid[2];
 char *p,*trust_regexp=((void*)0);
 int force_v4=0,class=0,selfsig=0;
 u32 duration=0;
 byte trust_depth=0,trust_value=0;

 if(local || nonrevocable || trust ||
    opt.cert_policy_url || opt.cert_notations)
   force_v4=1;





 if( sk )
     free_secret_key(sk);
 sk = copy_secret_key( ((void*)0), sk_rover->sk );
 keyid_from_sk( sk, sk_keyid );

 for( node=keyblock; node; node = node->next ) {
     if( select_all || (node->flag & (1<<8)) )
  node->flag |= (1<<4);
     else
  node->flag &= ~(1<<4);
 }

 uidnode = ((void*)0);
 for( node=keyblock; node; node = node->next ) {
     if( node->pkt->pkttype == PKT_PUBLIC_KEY ) {
           primary_pk=node->pkt->pkt.public_key;
  keyid_from_pk( primary_pk, pk_keyid );


  if(pk_keyid[0]==sk_keyid[0] && pk_keyid[1]==sk_keyid[1])
    {
      selfsig=1;




      force_v4=0;
    }
     }
     else if( node->pkt->pkttype == PKT_USER_ID )
       {
  uidnode = (node->flag & (1<<4))? node : ((void*)0);
  if(uidnode)
    {
      int yesreally=0;
      char *user=utf8_to_native(uidnode->pkt->pkt.user_id->name,
           uidnode->pkt->pkt.user_id->len,
           0);

      if(uidnode->pkt->pkt.user_id->is_revoked)
        {
   tty_printf(gettext ("User ID \"%s\" is revoked."),user);

   if(selfsig)
     tty_printf("\n");
   else if(opt.expert)
     {
       tty_printf("\n");

       if(!cpr_get_answer_is_yes("sign_uid.revoke_okay",
            gettext ("Are you sure you " "still want to sign " "it? (y/N) ")))


         {
    uidnode->flag &= ~(1<<4);
    uidnode=((void*)0);
         }
       else if(interactive)
         yesreally=1;
     }
   else
     {
       uidnode->flag &= ~(1<<4);
       uidnode=((void*)0);
       tty_printf(gettext ("  Unable to sign.\n"));
     }
        }
      else if(uidnode->pkt->pkt.user_id->is_expired)
        {
   tty_printf(gettext ("User ID \"%s\" is expired."),user);

   if(selfsig)
     tty_printf("\n");
   else if(opt.expert)
     {
       tty_printf("\n");

       if(!cpr_get_answer_is_yes("sign_uid.expire_okay",
            gettext ("Are you sure you " "still want to sign " "it? (y/N) ")))


         {
    uidnode->flag &= ~(1<<4);
    uidnode=((void*)0);
         }
       else if(interactive)
         yesreally=1;
     }
   else
     {
       uidnode->flag &= ~(1<<4);
       uidnode=((void*)0);
       tty_printf(gettext ("  Unable to sign.\n"));
     }
        }
      else if(!uidnode->pkt->pkt.user_id->created && !selfsig)
        {
   tty_printf(gettext ("User ID \"%s\" is not self-signed."),
       user);

   if(opt.expert)
     {
       tty_printf("\n");

       if(!cpr_get_answer_is_yes("sign_uid.nosig_okay",
            gettext ("Are you sure you " "still want to sign " "it? (y/N) ")))


         {
    uidnode->flag &= ~(1<<4);
    uidnode=((void*)0);
         }
       else if(interactive)
         yesreally=1;
     }
   else
     {
       uidnode->flag &= ~(1<<4);
       uidnode=((void*)0);
       tty_printf(gettext ("  Unable to sign.\n"));
     }
        }

      if(uidnode && interactive && !yesreally)
        {
   tty_printf(gettext ("User ID \"%s\" is signable.  "),user);
   if(!cpr_get_answer_is_yes("sign_uid.sign_okay",
        gettext ("Sign it? (y/N) ")))
     {
       uidnode->flag &= ~(1<<4);
       uidnode=((void*)0);
     }
        }

      xfree(user);
    }
       }
     else if( uidnode && node->pkt->pkttype == PKT_SIGNATURE
  && (node->pkt->pkt.signature->sig_class&~3) == 0x10 ) {
  if( sk_keyid[0] == node->pkt->pkt.signature->keyid[0]
      && sk_keyid[1] == node->pkt->pkt.signature->keyid[1] ) {
                    char buf[50];
      char *user=utf8_to_native(uidnode->pkt->pkt.user_id->name,
           uidnode->pkt->pkt.user_id->len,
           0);


      if(node->pkt->pkt.signature->version<4 && selfsig)
        {
   tty_printf(gettext ("The self-signature on \"%s\"\n" "is a PGP 2.x-style signature.\n"),user);






   if(opt.expert)
     if(cpr_get_answer_is_yes("sign_uid.v4_promote_okay",
         gettext ("Do you want to promote " "it to an OpenPGP self-" "signature? (y/N) ")))


       {
         force_v4=1;
         node->flag|=(1<<5);
         xfree(user);
         continue;
       }
        }


      if(node->pkt->pkt.signature->flags.expired)
        {
   tty_printf(gettext ("Your current signature on \"%s\"\n" "has expired.\n"),user);


   if(cpr_get_answer_is_yes("sign_uid.replace_expired_okay",
       gettext ("Do you want to issue a " "new signature to replace " "the expired one? (y/N) ")))


     {







       node->flag|=(1<<5);
       xfree(user);
       continue;
     }
        }

      if(!node->pkt->pkt.signature->flags.exportable && !local)
        {


   tty_printf(gettext ("Your current signature on \"%s\"\n" "is a local signature.\n"),user);


   if(cpr_get_answer_is_yes("sign_uid.local_promote_okay",
       gettext ("Do you want to promote " "it to a full exportable " "signature? (y/N) ")))


     {







       node->flag|=(1<<5);
       xfree(user);
       continue;
     }
        }



                    if (!node->pkt->pkt.signature->flags.exportable && local)
                      tty_printf(gettext ("\"%s\" was already locally signed by key %s\n"),

     user,keystr_from_sk(sk));
                    else
                      tty_printf(gettext ("\"%s\" was already signed by key %s\n"),
                                 user,keystr_from_sk(sk));

      if(opt.expert
         && cpr_get_answer_is_yes("sign_uid.dupe_okay",
      gettext ("Do you want to sign it " "again anyway? (y/N) ")))

        {


   xfree(user);
   continue;
        }

                    sprintf (buf, "%08lX%08lX",
                             (ulong)sk->keyid[0], (ulong)sk->keyid[1] );
                    write_status_text (63, buf);
      uidnode->flag &= ~(1<<4);

      xfree(user);
  }
     }
 }


 if( !count_uids_with_flag(keyblock, (1<<4)) )
   {
     tty_printf(gettext ("Nothing to sign with key %s\n"),keystr_from_sk(sk));
     continue;
   }


 tty_printf("\n");
 show_key_with_all_names( keyblock, 1, 0, 1, 0, 0 );
 tty_printf("\n");

 if(primary_pk->expiredate && !selfsig)
   {
     if(primary_pk->expiredate<=timestamp)
       {
  tty_printf(gettext ("This key has expired!"));

  if(opt.expert)
    {
      tty_printf("  ");
      if(!cpr_get_answer_is_yes("sign_uid.expired_okay",
           gettext ("Are you sure you still " "want to sign it? (y/N) ")))

        continue;
    }
  else
    {
      tty_printf(gettext ("  Unable to sign.\n"));
      continue;
    }
       }
     else
       {
  tty_printf(gettext ("This key is due to expire on %s.\n"),
      expirestr_from_pk(primary_pk));

  if(opt.ask_cert_expire)
    {
      char *answer=cpr_get("sign_uid.expire",
      gettext ("Do you want your signature to " "expire at the same time? (Y/n) "));

      if(answer_is_yes_no_default(answer,1))
        {


   duration=primary_pk->expiredate-timestamp;
   force_v4=1;
        }

      cpr_kill_prompt();
      xfree(answer);
    }
       }
   }



 if(!duration && !selfsig)
   {
     if(opt.ask_cert_expire)
       duration=ask_expire_interval(timestamp,1,opt.def_cert_expire);
     else
       duration=parse_expire_string(timestamp,opt.def_cert_expire);
   }

 if(duration)
   force_v4=1;




 if((opt.compliance==CO_PGP2) && all_v3 &&
    (sk->version>3 || force_v4) && primary_pk->version<=3)
   {
     tty_printf(gettext ("You may not make an OpenPGP signature on a " "PGP 2.x key while in --pgp2 mode.\n"));

     tty_printf(gettext ("This would make the key unusable in PGP 2.x.\n"));

     if(opt.expert)
       {
  if(!cpr_get_answer_is_yes("sign_uid.v4_on_v3_okay",
       gettext ("Are you sure you still " "want to sign it? (y/N) ")))

    continue;

  all_v3=0;
       }
     else
       continue;
   }

 if(selfsig)
   ;
 else
   {
     if(opt.batch || !opt.ask_cert_level)
       class=0x10+opt.def_cert_level;
     else
       {
  char *answer;

  tty_printf(gettext ("How carefully have you verified the key you are " "about to sign actually belongs\nto the person " "named above?  If you don't know what to " "answer, enter \"0\".\n"));



  tty_printf("\n");
  tty_printf(gettext ("   (0) I will not answer.%s\n"),
      opt.def_cert_level==0?" (default)":"");
  tty_printf(gettext ("   (1) I have not checked at all.%s\n"),
      opt.def_cert_level==1?" (default)":"");
  tty_printf(gettext ("   (2) I have done casual checking.%s\n"),
      opt.def_cert_level==2?" (default)":"");
  tty_printf(gettext ("   (3) I have done very careful checking.%s\n"),
      opt.def_cert_level==3?" (default)":"");
  tty_printf("\n");

  while(class==0)
    {
      answer = cpr_get("sign_uid.class",gettext ("Your selection? " "(enter `?' for more information): "));

      if(answer[0]=='\0')
        class=0x10+opt.def_cert_level;
      else if(ascii_strcasecmp(answer,"0")==0)
        class=0x10;
      else if(ascii_strcasecmp(answer,"1")==0)
        class=0x11;
      else if(ascii_strcasecmp(answer,"2")==0)
        class=0x12;
      else if(ascii_strcasecmp(answer,"3")==0)
        class=0x13;
      else
        tty_printf(gettext ("Invalid selection.\n"));

      xfree(answer);
    }
       }

     if(trust)
       trustsig_prompt(&trust_value,&trust_depth,&trust_regexp);
   }

 p=get_user_id_native(sk_keyid);
 tty_printf(gettext ("Are you sure that you want to sign this key with your\n" "key \"%s\" (%s)\n"),p,keystr_from_sk(sk));

 xfree(p);

 if(selfsig)
   {
            tty_printf("\n");
     tty_printf(gettext ("This will be a self-signature.\n"));

     if( local )
              {
                tty_printf("\n");
                tty_printf(
    gettext ("WARNING: the signature will not be marked " "as non-exportable.\n"));

              }

     if( nonrevocable )
              {
                tty_printf("\n");
                tty_printf(
    gettext ("WARNING: the signature will not be marked " "as non-revocable.\n"));

              }
   }
 else
   {
     if( local )
              {
                tty_printf("\n");
                tty_printf(
       gettext ("The signature will be marked as non-exportable.\n"));
              }

     if( nonrevocable )
              {
                tty_printf("\n");
                tty_printf(
        gettext ("The signature will be marked as non-revocable.\n"));
              }

     switch(class)
       {
       case 0x11:
                tty_printf("\n");
  tty_printf(gettext ("I have not checked this key at all.\n"));
  break;

       case 0x12:
                tty_printf("\n");
  tty_printf(gettext ("I have checked this key casually.\n"));
  break;

       case 0x13:
                tty_printf("\n");
  tty_printf(gettext ("I have checked this key very carefully.\n"));
  break;
       }
   }

 tty_printf("\n");

 if( opt.batch && opt.answer_yes )
   ;
 else if( !cpr_get_answer_is_yes("sign_uid.okay",
     gettext ("Really sign? (y/N) ")) )
     continue;


      reloop:
 primary_pk = ((void*)0);
 for( node=keyblock; node; node = node->next ) {
     if( node->pkt->pkttype == PKT_PUBLIC_KEY )
  primary_pk = node->pkt->pkt.public_key;
     else if( node->pkt->pkttype == PKT_USER_ID
       && (node->flag & (1<<4)) ) {
  PACKET *pkt;
  PKT_signature *sig;
  struct sign_attrib attrib;

  ((void)((primary_pk) || (__assert_fail("primary_pk", "keyedit.c", 1030, __func__),0)));
  memset( &attrib, 0, sizeof attrib );
  attrib.non_exportable = local;
  attrib.non_revocable = nonrevocable;
  attrib.trust_depth = trust_depth;
  attrib.trust_value = trust_value;
  attrib.trust_regexp = trust_regexp;
  node->flag &= ~(1<<4);






  if(selfsig)
    rc = make_keysig_packet( &sig, primary_pk,
        node->pkt->pkt.user_id,
        ((void*)0),
        sk,
        0x13, 0, force_v4?4:0, 0, 0,
        keygen_add_std_prefs, primary_pk);
  else
    rc = make_keysig_packet( &sig, primary_pk,
        node->pkt->pkt.user_id,
        ((void*)0),
        sk,
        class, 0, force_v4?4:0,
        timestamp, duration,
        sign_mk_attrib, &attrib );
  if( rc ) {
      g10_log_error(gettext ("signing failed: %s\n"), g10_errstr(rc));
      goto leave;
  }

  *ret_modified = 1;
  update_trust = 1;

  pkt = xmalloc_clear( sizeof *pkt );
  pkt->pkttype = PKT_SIGNATURE;
  pkt->pkt.signature = sig;
  insert_kbnode( node, new_kbnode(pkt), PKT_SIGNATURE );
  goto reloop;
     }
 }


 for( node=keyblock; node; node = node->next )
   if( node->flag & (1<<5))
     delete_kbnode(node);
    }

  leave:
    release_sk_list( sk_list );
    if( sk )
 free_secret_key(sk);
    return rc;
}







static int
change_passphrase( KBNODE keyblock )
{
    int rc = 0;
    int changed=0;
    KBNODE node;
    PKT_secret_key *sk;
    char *passphrase = ((void*)0);
    int no_primary_secrets = 0;
    int any;

    node = find_kbnode( keyblock, PKT_SECRET_KEY );
    if( !node ) {
 g10_log_error("Oops; secret key not found anymore!\n");
 goto leave;
    }
    sk = node->pkt->pkt.secret_key;

    for (any = 0, node=keyblock; node; node = node->next) {
 if (node->pkt->pkttype == PKT_SECRET_KEY
            || node->pkt->pkttype == PKT_SECRET_SUBKEY) {
     PKT_secret_key *tmpsk = node->pkt->pkt.secret_key;
            if (!(tmpsk->is_protected
                  && (tmpsk->protect.s2k.mode == 1001
                      || tmpsk->protect.s2k.mode == 1002))) {
                any = 1;
                break;
            }
        }
    }
    if (!any) {
        tty_printf (gettext ("Key has only stub or on-card key items - " "no passphrase to change.\n"));

        goto leave;
    }


    switch( is_secret_key_protected( sk ) ) {
      case -1:
 rc = 4;
 break;
      case 0:
 tty_printf(gettext ("This key is not protected.\n"));
 break;
      default:
 if( sk->protect.s2k.mode == 1001 ) {
     tty_printf(gettext ("Secret parts of primary key are not available.\n"));
     no_primary_secrets = 1;
 }
 else if( sk->protect.s2k.mode == 1002 ) {
     tty_printf(gettext ("Secret parts of primary key are stored on-card.\n"));
     no_primary_secrets = 1;
 }
 else {
     tty_printf(gettext ("Key is protected.\n"));
     rc = check_secret_key( sk, 0 );
     if( !rc )
  passphrase = get_last_passphrase();
 }
 break;
    }


    for(node=keyblock; !rc && node; node = node->next ) {
 if( node->pkt->pkttype == PKT_SECRET_SUBKEY ) {
     PKT_secret_key *subsk = node->pkt->pkt.secret_key;
            if ( !(subsk->is_protected
                   && (subsk->protect.s2k.mode == 1001
                       || subsk->protect.s2k.mode == 1002))) {
                set_next_passphrase( passphrase );
                rc = check_secret_key( subsk, 0 );
                if( !rc && !passphrase )
                    passphrase = get_last_passphrase();
            }
 }
    }

    if( rc )
 tty_printf(gettext ("Can't edit this key: %s\n"), g10_errstr(rc));
    else {
 DEK *dek = ((void*)0);
 STRING2KEY *s2k = xmalloc_secure( sizeof *s2k );
        const char *errtext = ((void*)0);

 tty_printf(gettext ("Enter the new passphrase for this secret key.\n\n") );

 set_next_passphrase( ((void*)0) );
 for(;;) {
     s2k->mode = opt.s2k_mode;
     s2k->hash_algo = (opt.s2k_digest_algo?opt.s2k_digest_algo:2);
     dek = passphrase_to_dek( ((void*)0), 0, opt.s2k_cipher_algo,
                                     s2k, 2, errtext, ((void*)0));
     if( !dek ) {
  errtext = ("passphrase not correctly repeated; try again");
  tty_printf ("%s.\n", gettext (errtext));
     }
     else if( !dek->keylen ) {
  rc = 0;
  tty_printf(gettext ("You don't want a passphrase -" " this is probably a *bad* idea!\n\n"));

  if( cpr_get_answer_is_yes("change_passwd.empty.okay",
          gettext ("Do you really want to do this? (y/N) ")))
    {
      changed++;
      break;
    }
     }
     else {
  rc = 0;
  if( !no_primary_secrets ) {
      sk->protect.algo = dek->algo;
      sk->protect.s2k = *s2k;
      rc = protect_secret_key( sk, dek );
  }
  for(node=keyblock; !rc && node; node = node->next ) {
      if( node->pkt->pkttype == PKT_SECRET_SUBKEY ) {
   PKT_secret_key *subsk = node->pkt->pkt.secret_key;
                        if ( !(subsk->is_protected
                               && (subsk->protect.s2k.mode == 1001
                                   || subsk->protect.s2k.mode == 1002))) {
                            subsk->protect.algo = dek->algo;
                            subsk->protect.s2k = *s2k;
                            rc = protect_secret_key( subsk, dek );
                        }
      }
  }
  if( rc )
      g10_log_error("protect_secret_key failed: %s\n",
                              g10_errstr(rc) );
  else
      changed++;
  break;
     }
 }
 xfree(s2k);
 xfree(dek);
    }

  leave:
    xfree( passphrase );
    set_next_passphrase( ((void*)0) );
    return changed && !rc;
}
# 1246 "keyedit.c"
static int
fix_keyblock( KBNODE keyblock )
{
    KBNODE node, last, subkey;
    int fixed=0;


    for( subkey=last=((void*)0), node = keyblock; node;
         last=node, node = node->next ) {
 switch( node->pkt->pkttype ) {
   case PKT_PUBLIC_SUBKEY:
   case PKT_SECRET_SUBKEY:
     if( !subkey )
  subkey = last;
     break;
   case PKT_SIGNATURE:
     if( subkey ) {
  PKT_signature *sig = node->pkt->pkt.signature;
  if( sig->sig_class >= 0x10 && sig->sig_class <= 0x13 ) {
      g10_log_info(gettext ("moving a key signature to the correct place\n"));

      last->next = node->next;
      node->next = subkey->next;
      subkey->next = node;
      node = last;
      fixed=1;
  }
     }
     break;
   default: break;
 }
    }

    return fixed;
}

static int
parse_sign_type(const char *str,int *localsig,int *nonrevokesig,int *trustsig)
{
  const char *p=str;

  while(*p)
    {
      if(ascii_strncasecmp(p,"l",1)==0)
 {
   *localsig=1;
   p++;
 }
      else if(ascii_strncasecmp(p,"nr",2)==0)
 {
   *nonrevokesig=1;
   p+=2;
 }
      else if(ascii_strncasecmp(p,"t",1)==0)
 {
   *trustsig=1;
   p++;
 }
      else
 return 0;
    }

  return 1;
}
# 1329 "keyedit.c"
enum cmdids
  {
    cmdNONE = 0,
    cmdQUIT, cmdHELP, cmdFPR, cmdLIST, cmdSELUID, cmdCHECK, cmdSIGN,
    cmdREVSIG, cmdREVKEY, cmdREVUID, cmdDELSIG, cmdPRIMARY, cmdDEBUG,
    cmdSAVE, cmdADDUID, cmdADDPHOTO, cmdDELUID, cmdADDKEY, cmdDELKEY,
    cmdADDREVOKER, cmdTOGGLE, cmdSELKEY, cmdPASSWD, cmdTRUST, cmdPREF,
    cmdEXPIRE, cmdBACKSIGN, cmdENABLEKEY, cmdDISABLEKEY, cmdSHOWPREF,
    cmdSETPREF, cmdPREFKS, cmdNOTATION, cmdINVCMD, cmdSHOWPHOTO, cmdUPDTRUST,
    cmdCHKTRUST, cmdADDCARDKEY, cmdKEYTOCARD, cmdBKUPTOCARD, cmdCLEAN,
    cmdMINIMIZE, cmdNOP
  };

static struct
{
  const char *name;
  enum cmdids id;
  int flags;
  const char *desc;
} cmds[] =
  {
    { "quit" , cmdQUIT , 0, ("quit this menu") },
    { "q" , cmdQUIT , 0, ((void*)0) },
    { "save" , cmdSAVE , 0, ("save and quit") },
    { "help" , cmdHELP , 0, ("show this help") },
    { "?" , cmdHELP , 0, ((void*)0) },
    { "fpr" , cmdFPR , 0, ("show key fingerprint") },
    { "list" , cmdLIST , 0, ("list key and user IDs") },
    { "l" , cmdLIST , 0, ((void*)0) },
    { "uid" , cmdSELUID , 0, ("select user ID N") },
    { "key" , cmdSELKEY , 0, ("select subkey N") },
    { "check" , cmdCHECK , 0, ("check signatures") },
    { "c" , cmdCHECK , 0, ((void*)0) },
    { "cross-certify", cmdBACKSIGN , 2|1, ((void*)0) },
    { "backsign", cmdBACKSIGN , 2|1, ((void*)0) },
    { "sign" , cmdSIGN , 2|8,
      ("sign selected user IDs [* see below for related commands]") },
    { "s" , cmdSIGN , 2, ((void*)0) },



    { "lsign" , cmdNOP , 0, ("sign selected user IDs locally") },
    { "tsign" , cmdNOP , 0,
      ("sign selected user IDs with a trust signature") },
    { "nrsign" , cmdNOP , 0,
      ("sign selected user IDs with a non-revocable signature") },

    { "debug" , cmdDEBUG , 0, ((void*)0) },
    { "adduid" , cmdADDUID , 2|1,
      ("add a user ID") },
    { "addphoto", cmdADDPHOTO , 2|1,
      ("add a photo ID") },
    { "deluid" , cmdDELUID , 2,
      ("delete selected user IDs") },

    { "delphoto", cmdDELUID , 2, ((void*)0) },

    { "addkey" , cmdADDKEY , 2|1,
      ("add a subkey") },


    { "addcardkey", cmdADDCARDKEY , 2|1,
      ("add a key to a smartcard") },
    { "keytocard", cmdKEYTOCARD , 1|4,
      ("move a key to a smartcard")},
    { "bkuptocard", cmdBKUPTOCARD , 1|4,
      ("move a backup key to a smartcard")},


    { "delkey" , cmdDELKEY , 2,
      ("delete selected subkeys") },
    { "addrevoker",cmdADDREVOKER,2|1,
      ("add a revocation key") },
    { "delsig" , cmdDELSIG , 2,
      ("delete signatures from the selected user IDs") },
    { "expire" , cmdEXPIRE , 2|1,
      ("change the expiration date for the key or selected subkeys") },
    { "primary" , cmdPRIMARY , 2|1,
      ("flag the selected user ID as primary")},
    { "toggle" , cmdTOGGLE , 1,
      ("toggle between the secret and public key listings") },
    { "t" , cmdTOGGLE , 1, ((void*)0) },
    { "pref" , cmdPREF , 2,
      ("list preferences (expert)")},
    { "showpref", cmdSHOWPREF , 2,
      ("list preferences (verbose)") },
    { "setpref" , cmdSETPREF , 2|1,
      ("set preference list for the selected user IDs") },

    { "updpref" , cmdSETPREF , 2|1, ((void*)0) },

    { "keyserver",cmdPREFKS , 2|1,
      ("set the preferred keyserver URL for the selected user IDs")},
    { "notation", cmdNOTATION , 2|1,
      ("set a notation for the selected user IDs")},
    { "passwd" , cmdPASSWD , 2|1,
      ("change the passphrase") },

    { "password", cmdPASSWD , 2|1, ((void*)0) },

    { "trust" , cmdTRUST , 2, ("change the ownertrust") },
    { "revsig" , cmdREVSIG , 2,
      ("revoke signatures on the selected user IDs") },
    { "revuid" , cmdREVUID , 2|1,
      ("revoke selected user IDs") },

    { "revphoto", cmdREVUID , 2|1, ((void*)0) },

    { "revkey" , cmdREVKEY , 2|1,
      ("revoke key or selected subkeys") },
    { "enable" , cmdENABLEKEY , 2, ("enable key") },
    { "disable" , cmdDISABLEKEY, 2, ("disable key") },
    { "showphoto",cmdSHOWPHOTO , 0, ("show selected photo IDs") },
    { "clean", cmdCLEAN , 2,
      ("compact unusable user IDs and remove unusable signatures from key")},
    { "minimize", cmdMINIMIZE , 2,
      ("compact unusable user IDs and remove all signatures from key") },
    { ((void*)0), cmdNONE, 0, ((void*)0) }
  };
# 1495 "keyedit.c"
void
keyedit_menu( const char *username, STRLIST locusr,
       STRLIST commands, int quiet, int seckey_check )
{
    enum cmdids cmd = 0;
    int rc = 0;
    KBNODE keyblock = ((void*)0);
    KEYDB_HANDLE kdbhd = ((void*)0);
    KBNODE sec_keyblock = ((void*)0);
    KEYDB_HANDLE sec_kdbhd = ((void*)0);
    KBNODE cur_keyblock;
    char *answer = ((void*)0);
    int redisplay = 1;
    int modified = 0;
    int sec_modified = 0;
    int run_subkey_warnings = 0;
    int toggle;
    int have_commands = !!commands;

    if ( opt.command_fd != -1 )
        ;
    else if( opt.batch && !have_commands )
      {
 g10_log_error(gettext ("can't do this in batch mode\n"));
 goto leave;
      }
# 1536 "keyedit.c"
    rc = get_pubkey_byname (((void*)0), username, &keyblock, &kdbhd, 1);
    if( rc )
      {
        g10_log_error (gettext ("key \"%s\" not found: %s\n"), username, g10_errstr (rc));
 goto leave;
      }

    if( fix_keyblock( keyblock ) )
 modified++;
    if( collapse_uids( &keyblock ) )
 modified++;
    reorder_keyblock(keyblock);


    if(modified)
      merge_keys_and_selfsig( keyblock );

    if(seckey_check)
      {
        PKT_public_key *pk = keyblock->pkt->pkt.public_key;

        sec_kdbhd = keydb_new (1);
        {
            byte afp[20];
            size_t an;

            fingerprint_from_pk (pk, afp, &an);
            while (an < 20)
                afp[an++] = 0;
            rc = keydb_search_fpr (sec_kdbhd, afp);
        }
 if (!rc)
   {
     rc = keydb_get_keyblock (sec_kdbhd, &sec_keyblock);
     if (rc)
       {
  g10_log_error (gettext ("error reading secret keyblock \"%s\": %s\n"),
      username, g10_errstr(rc));
       }
            else
       {
                merge_keys_and_selfsig( sec_keyblock );
                if( fix_keyblock( sec_keyblock ) )
    sec_modified++;
       }
   }

        if (rc) {
            sec_keyblock = ((void*)0);
            keydb_release (sec_kdbhd); sec_kdbhd = ((void*)0);
            rc = 0;
        }

 if( sec_keyblock && !quiet )
   tty_printf(gettext ("Secret key is available.\n"));
    }

    toggle = 0;
    cur_keyblock = keyblock;
    for(;;) {
 int i, arg_number, photo;
        const char *arg_string = "";
 char *p;
 PKT_public_key *pk=keyblock->pkt->pkt.public_key;

 tty_printf("\n");

 if( redisplay && !quiet )
   {
     show_key_with_all_names( cur_keyblock, 0, 1, 0, 1, 0 );
     tty_printf("\n");
     redisplay = 0;
   }

        if (run_subkey_warnings)
          {
            run_subkey_warnings = 0;
            if (!count_selected_keys (keyblock))
              subkey_expire_warning (keyblock);
          }

 do {
     xfree(answer);
     if( have_commands ) {
  if( commands ) {
      answer = xstrdup( commands->d );
      commands = commands->next;
  }
  else if( opt.batch ) {
      answer = xstrdup("quit");
  }
  else
      have_commands = 0;
     }
     if( !have_commands )
       {
                                           ;
  answer = cpr_get_no_help("keyedit.prompt", "gpg> ");
  cpr_kill_prompt();
                          ;
       }
     trim_spaces(answer);
 } while( *answer == '#' );

 arg_number = 0;
 photo = 0;
 if( !*answer )
     cmd = cmdLIST;
 else if( *answer == ('D' - 'A' + 1) )
     cmd = cmdQUIT;
 else if( (*(answer) >= '0' && *(answer) <= '9') ) {
     cmd = cmdSELUID;
     arg_number = atoi(answer);
 }
 else {
     if( (p=strchr(answer,' ')) ) {
  *p++ = 0;
  trim_spaces(answer);
  trim_spaces(p);
  arg_number = atoi(p);
                arg_string = p;
     }

     for(i=0; cmds[i].name; i++ )
       {
  if(cmds[i].flags & 8)
    {
      size_t l=strlen(cmds[i].name);
      size_t a=strlen(answer);
      if(a>=l)
        {
   if(ascii_strcasecmp(&answer[a-l],cmds[i].name)==0)
     {
       answer[a-l]='\0';
       break;
     }
        }
    }
  else if( !ascii_strcasecmp( answer, cmds[i].name ) )
    break;
       }
     if((cmds[i].flags & 1) && !sec_keyblock )
       {
  tty_printf(gettext ("Need the secret key to do this.\n"));
  cmd = cmdNOP;
       }
     else if(((cmds[i].flags & 2) && sec_keyblock
       && toggle)
                    ||((cmds[i].flags & 4) && sec_keyblock
         && !toggle))
       {
  tty_printf(gettext ("Please use the command \"toggle\" first.\n"));
  cmd = cmdNOP;
       }
     else
       cmd = cmds[i].id;
 }
 switch( cmd )
   {
   case cmdHELP:
     for(i=0; cmds[i].name; i++ )
       {
  if((cmds[i].flags & 1) && !sec_keyblock )
    ;
  else if( cmds[i].desc )
    tty_printf("%-11s %s\n", cmds[i].name, gettext (cmds[i].desc) );
       }

     tty_printf("\n");
     tty_printf(gettext ("* The `sign' command may be prefixed with an `l' for local ""signatures (lsign),\n""  a `t' for trust signatures (tsign), an `nr' for non-revocable signatures\n""  (nrsign), or any combination thereof (ltsign, tnrsign, etc.).\n"));





     break;

   case cmdLIST:
     redisplay = 1;
     break;

   case cmdFPR:
     show_key_and_fingerprint( keyblock );
     break;

   case cmdSELUID:
     if(strlen(arg_string)==20*2)
       redisplay=menu_select_uid_namehash(cur_keyblock,arg_string);
     else
       redisplay=menu_select_uid(cur_keyblock,arg_number);
     break;

   case cmdSELKEY:
     if( menu_select_key( cur_keyblock, arg_number ) )
  redisplay = 1;
     break;

   case cmdCHECK:



     check_all_keysigs( keyblock, count_selected_uids(keyblock) );
     break;

   case cmdSIGN:
     {
       int localsig=0,nonrevokesig=0,trustsig=0,interactive=0;

       if( pk->is_revoked )
  {
    tty_printf(gettext ("Key is revoked."));

    if(opt.expert)
      {
        tty_printf("  ");
        if(!cpr_get_answer_is_yes("keyedit.sign_revoked.okay",
      gettext ("Are you sure you still want" " to sign it? (y/N) ")))

   break;
      }
    else
      {
        tty_printf(gettext ("  Unable to sign.\n"));
        break;
      }
  }

       if(count_uids(keyblock) > 1 && !count_selected_uids(keyblock)
   && !cpr_get_answer_is_yes("keyedit.sign_all.okay",
        gettext ("Really sign all user IDs?" " (y/N) ")))

                {
                  if(opt.interactive)
      interactive=1;
    else
                    {
        tty_printf(gettext ("Hint: Select the user IDs to sign\n"));
                      have_commands = 0;
                      break;
                    }

                }

       if(!parse_sign_type(answer,&localsig,&nonrevokesig,&trustsig))
  {
    tty_printf(gettext ("Unknown signature type `%s'\n"),answer);
    break;
  }

       sign_uids(keyblock, locusr, &modified,
   localsig, nonrevokesig, trustsig, interactive);
     }
     break;

   case cmdDEBUG:
     dump_kbnode( cur_keyblock );
     break;

   case cmdTOGGLE:
     toggle = !toggle;
     cur_keyblock = toggle? sec_keyblock : keyblock;
     redisplay = 1;
     break;

   case cmdADDPHOTO:
            if ((opt.compliance==CO_RFC2440) || (opt.compliance==CO_RFC1991 || opt.compliance==CO_PGP2) || (opt.compliance==CO_PGP2))
              {
                tty_printf(
                   gettext ("This command is not allowed while in %s mode.\n"),
     compliance_option_string());
                break;
              }
     photo=1;


   case cmdADDUID:
     if( menu_adduid( keyblock, sec_keyblock, photo, arg_string ) )
       {
         update_trust = 1;
  redisplay = 1;
  sec_modified = modified = 1;
  merge_keys_and_selfsig( sec_keyblock );
  merge_keys_and_selfsig( keyblock );
       }
     break;

   case cmdDELUID: {
  int n1;

  if( !(n1=count_selected_uids(keyblock)) )
      tty_printf(gettext ("You must select at least one user ID.\n"));
  else if( real_uids_left(keyblock) < 1 )
      tty_printf(gettext ("You can't delete the last user ID!\n"));
  else if( cpr_get_answer_is_yes("keyedit.remove.uid.okay",
         n1 > 1? gettext ("Really remove all selected user IDs? (y/N) ")
       : gettext ("Really remove this user ID? (y/N) ")
         ) ) {
      menu_deluid( keyblock, sec_keyblock );
      redisplay = 1;
      modified = 1;
      if( sec_keyblock )
         sec_modified = 1;
  }
     }
     break;

   case cmdDELSIG: {
  int n1;

  if( !(n1=count_selected_uids(keyblock)) )
      tty_printf(gettext ("You must select at least one user ID.\n"));
  else if( menu_delsig( keyblock ) ) {


      modified = 1;
  }
     }
     break;

   case cmdADDKEY:
     if( generate_subkeypair( keyblock, sec_keyblock ) ) {
  redisplay = 1;
  sec_modified = modified = 1;
  merge_keys_and_selfsig( sec_keyblock );
  merge_keys_and_selfsig( keyblock );
     }
     break;


   case cmdADDCARDKEY:
     if (card_generate_subkey (keyblock, sec_keyblock)) {
  redisplay = 1;
  sec_modified = modified = 1;
  merge_keys_and_selfsig( sec_keyblock );
  merge_keys_and_selfsig( keyblock );
     }
     break;

        case cmdKEYTOCARD:
   {
     KBNODE node=((void*)0);
     switch ( count_selected_keys (sec_keyblock) )
       {
       case 0:
  if (cpr_get_answer_is_yes("keyedit.keytocard.use_primary",
         gettext ("Really move the primary key? (y/N) ")))
    node = sec_keyblock;
  break;
       case 1:
  for (node = sec_keyblock; node; node = node->next )
    {
      if (node->pkt->pkttype == PKT_SECRET_SUBKEY
   && node->flag & (1<<9))
        break;
    }
  break;
       default:
  tty_printf(gettext ("You must select exactly one key.\n"));
  break;
       }
     if (node)
       {
  PKT_public_key *xxpk = find_pk_from_sknode (keyblock, node);
  if (card_store_subkey (node, xxpk?xxpk->pubkey_usage:0))
    {
      redisplay = 1;
      sec_modified = 1;
    }
       }
   }
          break;

        case cmdBKUPTOCARD:
   {



     KBNODE node;
            const char *fname;
            PACKET *pkt;
            IOBUF a;

            fname = arg_string;
            if (!*fname)
              {
                tty_printf (gettext ("Command expects a filename argument\n"));
                break;
              }


            a = iobuf_open (fname);
            if (a && is_secured_file (iobuf_get_fd (a)))
              {
                iobuf_close (a);
                a = ((void*)0);
                (*__errno_location()) = (63);
              }
            if (!a)
              {
         tty_printf (gettext ("Can't open `%s': %s\n"),
                            fname, strerror((*__errno_location())));
                break;
              }


            pkt = xmalloc (sizeof *pkt);
            do { (pkt)->pkttype = 0; (pkt)->pkt.generic = ((void*)0); } while(0);
            rc = dbg_parse_packet( (a), (pkt), "keyedit.c", 1943 );
            iobuf_close (a);
            iobuf_ioctl (((void*)0), 2, 0, (char*)fname);
            if (!rc
                && pkt->pkttype != PKT_SECRET_KEY
                && pkt->pkttype != PKT_SECRET_SUBKEY)
              rc = 17;
            if (rc)
              {
                tty_printf(gettext ("Error reading backup key from `%s': %s\n"),
                           fname, g10_errstr (rc));
                free_packet (pkt);
                xfree (pkt);
                break;
              }
            node = new_kbnode (pkt);


            if (card_store_subkey (node, 0))
              {
                redisplay = 1;
                sec_modified = 1;
              }
            release_kbnode (node);
   }
          break;



   case cmdDELKEY: {
  int n1;

  if( !(n1=count_selected_keys( keyblock )) )
      tty_printf(gettext ("You must select at least one key.\n"));
  else if( !cpr_get_answer_is_yes( "keyedit.remove.subkey.okay",
         n1 > 1?
     gettext ("Do you really want to delete the selected keys? (y/N) "):
   gettext ("Do you really want to delete this key? (y/N) ")
         ))
      ;
  else {
      menu_delkey( keyblock, sec_keyblock );
      redisplay = 1;
      modified = 1;
      if( sec_keyblock )
         sec_modified = 1;
  }
     }
     break;

   case cmdADDREVOKER:
     {
       int sensitive=0;

       if(ascii_strcasecmp(arg_string,"sensitive")==0)
  sensitive=1;
       if( menu_addrevoker( keyblock, sec_keyblock, sensitive ) ) {
  redisplay = 1;
  sec_modified = modified = 1;
  merge_keys_and_selfsig( sec_keyblock );
  merge_keys_and_selfsig( keyblock );
       }
     }
     break;

   case cmdREVUID: {
  int n1;

  if( !(n1=count_selected_uids(keyblock)) )
      tty_printf(gettext ("You must select at least one user ID.\n"));
  else if( cpr_get_answer_is_yes(
       "keyedit.revoke.uid.okay",
         n1 > 1? gettext ("Really revoke all selected user IDs? (y/N) ")
               : gettext ("Really revoke this user ID? (y/N) ")
         ) ) {
    if(menu_revuid(keyblock,sec_keyblock))
      {
        modified=1;
        redisplay=1;
      }
  }
     }
     break;

   case cmdREVKEY:
     {
       int n1;

       if( !(n1=count_selected_keys( keyblock )) )
  {
    if(cpr_get_answer_is_yes("keyedit.revoke.subkey.okay",
        gettext ("Do you really want to revoke" " the entire key? (y/N) ")))

      {
        if(menu_revkey(keyblock,sec_keyblock))
   modified=1;

        redisplay=1;
      }
  }
       else if(cpr_get_answer_is_yes("keyedit.revoke.subkey.okay",
         n1 > 1?
         gettext ("Do you really want to revoke" " the selected subkeys? (y/N) "):

         gettext ("Do you really want to revoke" " this subkey? (y/N) ")))

  {
    if( menu_revsubkey( keyblock, sec_keyblock ) )
      modified = 1;

    redisplay = 1;
  }

       if(modified)
  merge_keys_and_selfsig( keyblock );
     }
     break;

   case cmdEXPIRE:
     if( menu_expire( keyblock, sec_keyblock ) )
       {
  merge_keys_and_selfsig( sec_keyblock );
  merge_keys_and_selfsig( keyblock );
                run_subkey_warnings = 1;
  sec_modified = 1;
  modified = 1;
  redisplay = 1;
       }
     break;

   case cmdBACKSIGN:
     if(menu_backsign(keyblock,sec_keyblock))
       {
  sec_modified = 1;
  modified = 1;
  redisplay = 1;
       }
     break;

   case cmdPRIMARY:
     if( menu_set_primary_uid ( keyblock, sec_keyblock ) ) {
  merge_keys_and_selfsig( keyblock );
  modified = 1;
  redisplay = 1;
     }
     break;

   case cmdPASSWD:
     if( change_passphrase( sec_keyblock ) )
  sec_modified = 1;
     break;

   case cmdTRUST:
     if(opt.trust_model==TM_EXTERNAL)
       {
  tty_printf(gettext ("Owner trust may not be set while " "using a user provided trust database\n"));

  break;
       }

     show_key_with_all_names( keyblock, 0, 0, 0, 1, 0 );
     tty_printf("\n");
     if( edit_ownertrust( find_kbnode( keyblock,
                                 PKT_PUBLIC_KEY )->pkt->pkt.public_key, 1 ) ) {
  redisplay = 1;



  update_trust=1;
            }
     break;

   case cmdPREF:
     {
       int count=count_selected_uids(keyblock);
       ((void)((keyblock->pkt->pkttype==PKT_PUBLIC_KEY) || (__assert_fail("keyblock->pkt->pkttype==PKT_PUBLIC_KEY", "keyedit.c", 2118, __func__),0)));
       show_names(keyblock,keyblock->pkt->pkt.public_key,
    count?(1<<8):0,1);
     }
     break;

   case cmdSHOWPREF:
     {
       int count=count_selected_uids(keyblock);
       ((void)((keyblock->pkt->pkttype==PKT_PUBLIC_KEY) || (__assert_fail("keyblock->pkt->pkttype==PKT_PUBLIC_KEY", "keyedit.c", 2127, __func__),0)));
       show_names(keyblock,keyblock->pkt->pkt.public_key,
    count?(1<<8):0,2);
     }
     break;

          case cmdSETPREF:
     {
       PKT_user_id *tempuid;

       keygen_set_std_prefs(!*arg_string?"default" : arg_string, 0);

       tempuid=keygen_get_std_prefs();
       tty_printf(gettext ("Set preference list to:\n"));
       show_prefs(tempuid,((void*)0),1);
       free_user_id(tempuid);

       if(cpr_get_answer_is_yes("keyedit.setpref.okay",
           count_selected_uids (keyblock)?
           gettext ("Really update the preferences" " for the selected user IDs? (y/N) "):

           gettext ("Really update the preferences? (y/N) ")))
  {
    if ( menu_set_preferences (keyblock, sec_keyblock) )
      {
        merge_keys_and_selfsig (keyblock);
        modified = 1;
        redisplay = 1;
      }
  }
     }
     break;

   case cmdPREFKS:
     if( menu_set_keyserver_url ( *arg_string?arg_string:((void*)0),
      keyblock, sec_keyblock ) )
       {
  merge_keys_and_selfsig( keyblock );
  modified = 1;
  redisplay = 1;
       }
     break;

   case cmdNOTATION:
     if( menu_set_notation ( *arg_string?arg_string:((void*)0),
        keyblock, sec_keyblock ) )
       {
  merge_keys_and_selfsig( keyblock );
  modified = 1;
  redisplay = 1;
       }
     break;

   case cmdNOP:
     break;

   case cmdREVSIG:
     if( menu_revsig( keyblock ) ) {
  redisplay = 1;
  modified = 1;
     }
     break;

   case cmdENABLEKEY:
   case cmdDISABLEKEY:
     if( enable_disable_key( keyblock, cmd == cmdDISABLEKEY ) ) {
  redisplay = 1;
  modified = 1;
     }
     break;

   case cmdSHOWPHOTO:
     menu_showphoto(keyblock);
     break;

   case cmdCLEAN:
     if(menu_clean(keyblock,0))
       redisplay=modified=1;
     break;

   case cmdMINIMIZE:
     if(menu_clean(keyblock,1))
       redisplay=modified=1;
     break;

   case cmdQUIT:
     if( have_commands )
  goto leave;
     if( !modified && !sec_modified )
  goto leave;
     if( !cpr_get_answer_is_yes("keyedit.save.okay",
     gettext ("Save changes? (y/N) ")) ) {
  if( cpr_enabled()
      || cpr_get_answer_is_yes("keyedit.cancel.okay",
          gettext ("Quit without saving? (y/N) ")))
      goto leave;
  break;
     }

   case cmdSAVE:
     if( modified || sec_modified ) {
  if( modified ) {
      rc = keydb_update_keyblock (kdbhd, keyblock);
      if( rc ) {
   g10_log_error(gettext ("update failed: %s\n"), g10_errstr(rc) );
   break;
      }
  }
  if( sec_modified ) {
      rc = keydb_update_keyblock (sec_kdbhd, sec_keyblock );
      if( rc ) {
   g10_log_error( gettext ("update secret failed: %s\n"),
                                   g10_errstr(rc) );
   break;
      }
  }
     }
     else
  tty_printf(gettext ("Key not changed so no update needed.\n"));

     if( update_trust )
       {
  revalidation_mark ();
  update_trust=0;
       }
     goto leave;

   case cmdINVCMD:
   default:
     tty_printf("\n");
     tty_printf(gettext ("Invalid command  (try \"help\")\n"));
     break;
 }
    }

  leave:
    release_kbnode( keyblock );
    release_kbnode( sec_keyblock );
    keydb_release (kdbhd);
    xfree(answer);
}

static void
tty_print_notations(int indent,PKT_signature *sig)
{
  int first=1;
  struct notation *notation,*nd;

  if(indent<0)
    {
      first=0;
      indent=-indent;
    }

  notation=sig_to_notation(sig);

  for(nd=notation;nd;nd=nd->next)
    {
      if(!first)
 tty_printf("%*s",indent,"");
      else
 first=0;

      tty_print_utf8_string(nd->name,strlen(nd->name));
      tty_printf("=");
      tty_print_utf8_string(nd->value,strlen(nd->value));
      tty_printf("\n");
    }

  free_notation(notation);
}




static void
show_prefs (PKT_user_id *uid, PKT_signature *selfsig, int verbose)
{
    const prefitem_t fake={0,0};
    const prefitem_t *prefs;
    int i;

    if( !uid )
        return;

    if( uid->prefs )
        prefs=uid->prefs;
    else if(verbose)
        prefs=&fake;
    else
      return;

    if (verbose) {
        int any, des_seen=0, sha1_seen=0, uncomp_seen=0;

        tty_printf ("     ");
 tty_printf (gettext ("Cipher: "));
        for(i=any=0; prefs[i].type; i++ ) {
            if( prefs[i].type == PREFTYPE_SYM ) {
                const char *s = cipher_algo_to_string (prefs[i].value);

                if (any)
                    tty_printf (", ");
                any = 1;

                if (s && prefs[i].value < 100 )
                    tty_printf ("%s", s );
                else
                    tty_printf ("[%d]", prefs[i].value);
                if (prefs[i].value == 2 )
                    des_seen = 1;
            }
        }
        if (!des_seen) {
            if (any)
                tty_printf (", ");
            tty_printf ("%s",cipher_algo_to_string(2));
        }
        tty_printf ("\n     ");
 tty_printf (gettext ("Digest: "));
        for(i=any=0; prefs[i].type; i++ ) {
            if( prefs[i].type == PREFTYPE_HASH ) {
                const char *s = digest_algo_to_string (prefs[i].value);

                if (any)
                    tty_printf (", ");
                any = 1;

                if (s && prefs[i].value < 100 )
                    tty_printf ("%s", s );
                else
                    tty_printf ("[%d]", prefs[i].value);
                if (prefs[i].value == 2 )
                    sha1_seen = 1;
            }
        }
        if (!sha1_seen) {
            if (any)
                tty_printf (", ");
            tty_printf ("%s",digest_algo_to_string(2));
        }
        tty_printf ("\n     ");
 tty_printf (gettext ("Compression: "));
        for(i=any=0; prefs[i].type; i++ ) {
            if( prefs[i].type == PREFTYPE_ZIP ) {
                const char *s=compress_algo_to_string(prefs[i].value);

                if (any)
                    tty_printf (", ");
                any = 1;

                if (s && prefs[i].value < 100 )
                    tty_printf ("%s", s );
                else
                    tty_printf ("[%d]", prefs[i].value);
                if (prefs[i].value == 0 )
                    uncomp_seen = 1;
            }
        }
        if (!uncomp_seen) {
            if (any)
                tty_printf (", ");
     else {
       tty_printf ("%s",compress_algo_to_string(1));
       tty_printf (", ");
     }
     tty_printf ("%s",compress_algo_to_string(0));
        }
 if(uid->flags.mdc || !uid->flags.ks_modify)
   {
     tty_printf ("\n     ");
     tty_printf (gettext ("Features: "));
     any=0;
     if(uid->flags.mdc)
       {
  tty_printf ("MDC");
  any=1;
       }
     if(!uid->flags.ks_modify)
       {
  if(any)
    tty_printf (", ");
  tty_printf (gettext ("Keyserver no-modify"));
       }
   }
 tty_printf("\n");

 if(selfsig)
   {
     const byte *pref_ks;
     size_t pref_ks_len;

     pref_ks=parse_sig_subpkt(selfsig->hashed,
         SIGSUBPKT_PREF_KS,&pref_ks_len);
     if(pref_ks && pref_ks_len)
       {
  tty_printf ("     ");
  tty_printf(gettext ("Preferred keyserver: "));
  tty_print_utf8_string(pref_ks,pref_ks_len);
  tty_printf("\n");
       }

     if(selfsig->flags.notation)
       {
  tty_printf ("     ");
  tty_printf(gettext ("Notations: "));
  tty_print_notations(5+strlen(gettext ("Notations: ")),selfsig);
       }
   }
    }
    else {
        tty_printf("    ");
        for(i=0; prefs[i].type; i++ ) {
            tty_printf( " %c%d", prefs[i].type == PREFTYPE_SYM ? 'S' :
                                 prefs[i].type == PREFTYPE_HASH ? 'H' :
                                 prefs[i].type == PREFTYPE_ZIP ? 'Z':'?',
                                 prefs[i].value);
        }
        if (uid->flags.mdc)
            tty_printf (" [mdc]");
        if (!uid->flags.ks_modify)
            tty_printf (" [no-ks-modify]");
        tty_printf("\n");
    }
}




static void
show_key_with_all_names_colon (KBNODE keyblock)
{
  KBNODE node;
  int i, j, ulti_hack=0;
  byte pk_version=0;
  PKT_public_key *primary=((void*)0);


  for ( node = keyblock; node; node = node->next )
    {
      if (node->pkt->pkttype == PKT_PUBLIC_KEY
          || (node->pkt->pkttype == PKT_PUBLIC_SUBKEY) )
        {
          PKT_public_key *pk = node->pkt->pkt.public_key;
          u32 keyid[2];

          if (node->pkt->pkttype == PKT_PUBLIC_KEY)
            {
              pk_version = pk->version;
       primary=pk;
     }

          keyid_from_pk (pk, keyid);

          fputs (node->pkt->pkttype == PKT_PUBLIC_KEY?"pub:":"sub:", (stdout));
          if (!pk->is_valid)
            putchar ('i');
          else if (pk->is_revoked)
            putchar ('r');
          else if (pk->has_expired)
            putchar ('e');
          else if (!(opt.fast_list_mode || opt.no_expensive_trust_checks ))
     {
       int trust = get_validity_info (pk, ((void*)0));
       if(trust=='u')
  ulti_hack=1;
       putchar (trust);
     }

          printf (":%u:%d:%08lX%08lX:%lu:%lu::",
                  nbits_from_pk (pk),
                  pk->pubkey_algo,
                  (ulong)keyid[0], (ulong)keyid[1],
                  (ulong)pk->timestamp,
                  (ulong)pk->expiredate );
          if (node->pkt->pkttype==PKT_PUBLIC_KEY
       && !(opt.fast_list_mode || opt.no_expensive_trust_checks ))
     putchar(get_ownertrust_info (pk));
          putchar(':');
          putchar('\n');

          print_fingerprint (pk, ((void*)0), 0);
   print_revokers(pk);
        }
    }


    i = 0;
    for (node = keyblock; node; node = node->next)
      {
 if ( node->pkt->pkttype == PKT_USER_ID )
          {
            PKT_user_id *uid = node->pkt->pkt.user_id;

     ++i;

     if(uid->attrib_data)
       printf("uat:");
     else
       printf("uid:");

     if ( uid->is_revoked )
       printf("r::::::::");
     else if ( uid->is_expired )
       printf("e::::::::");
     else if ( opt.fast_list_mode || opt.no_expensive_trust_checks )
       printf("::::::::");
     else
       {
  int uid_validity;

  if( primary && !ulti_hack )
    uid_validity = get_validity_info( primary, uid );
  else
    uid_validity = 'u';
  printf("%c::::::::",uid_validity);
       }

     if(uid->attrib_data)
       printf ("%u %lu",uid->numattribs,uid->attrib_len);
     else
       print_string ((stdout), uid->name, uid->len, ':');

            putchar (':');

            putchar (':');

            putchar (':');

            if (pk_version>3 || uid->selfsigversion>3)
              {
                const prefitem_t *prefs = uid->prefs;

                for (j=0; prefs && prefs[j].type; j++)
                  {
                    if (j)
                      putchar (' ');
                    printf ("%c%d", prefs[j].type == PREFTYPE_SYM ? 'S' :
                            prefs[j].type == PREFTYPE_HASH ? 'H' :
                            prefs[j].type == PREFTYPE_ZIP ? 'Z':'?',
                            prefs[j].value);
                  }
                if (uid->flags.mdc)
                  printf (",mdc");
                if (!uid->flags.ks_modify)
                  printf (",no-ks-modify");
              }
            putchar (':');

            printf ("%d,", i);
            if (uid->is_primary)
              putchar ('p');
            if (uid->is_revoked)
              putchar ('r');
            if (uid->is_expired)
              putchar ('e');
            if ((node->flag & (1<<8)))
              putchar ('s');
            if ((node->flag & (1<<4)))
              putchar ('m');
            putchar (':');
            putchar('\n');
          }
      }
}

static void
show_names(KBNODE keyblock,PKT_public_key *pk,unsigned int flag,int with_prefs)
{
  KBNODE node;
  int i=0;

  for( node = keyblock; node; node = node->next )
    {
      if( node->pkt->pkttype == PKT_USER_ID
   && !((node)->private_flag & 1))
 {
   PKT_user_id *uid = node->pkt->pkt.user_id;
   ++i;
   if(!flag || (flag && (node->flag & flag)))
     {
       if(!(flag&(1<<4)) && pk)
  tty_printf("%s ",uid_trust_string_fixed(pk,uid));

       if( flag & (1<<4) )
  tty_printf("     ");
       else if( node->flag & (1<<8) )
  tty_printf("(%d)* ", i);
       else if( uid->is_primary )
  tty_printf("(%d). ", i);
       else
  tty_printf("(%d)  ", i);
       tty_print_utf8_string( uid->name, uid->len );
       tty_printf("\n");
       if(with_prefs && pk)
  {
    if(pk->version>3 || uid->selfsigversion>3)
      {
        PKT_signature *selfsig=((void*)0);
        KBNODE signode;

        for(signode=node->next;
     signode && signode->pkt->pkttype==PKT_SIGNATURE;
     signode=signode->next)
   {
     if(signode->pkt->pkt.signature->
        flags.chosen_selfsig)
       {
         selfsig=signode->pkt->pkt.signature;
         break;
       }
   }

        show_prefs (uid, selfsig, with_prefs == 2);
      }
    else
      tty_printf(gettext ("There are no preferences on a" " PGP 2.x-style user ID.\n"));

  }
     }
 }
    }
}





static void
show_key_with_all_names( KBNODE keyblock, int only_marked, int with_revoker,
    int with_fpr, int with_subkeys, int with_prefs )
{
    KBNODE node;
    int i;
    int do_warn = 0;
    PKT_public_key *primary=((void*)0);

    if (opt.with_colons)
      {
        show_key_with_all_names_colon (keyblock);
        return;
      }


    for( node = keyblock; node; node = node->next ) {
 if( node->pkt->pkttype == PKT_PUBLIC_KEY
     || (with_subkeys && node->pkt->pkttype == PKT_PUBLIC_SUBKEY
  && !((node)->private_flag & 1)) ) {
     PKT_public_key *pk = node->pkt->pkt.public_key;
     const char *otrust="err",*trust="err";

     if( node->pkt->pkttype == PKT_PUBLIC_KEY ) {


                static int did_warn = 0;

                trust = get_validity_string (pk, ((void*)0));
  otrust = get_ownertrust_string (pk);


                if (!did_warn
                    && (get_validity (pk, ((void*)0)) & 256)) {
                    did_warn = 1;
                    do_warn = 1;
                }

  primary=pk;
     }

     if(pk->is_revoked)
       {
  char *user=get_user_id_string_native(pk->revoked.keyid);
  const char *algo=pubkey_algo_to_string(pk->revoked.algo);
  tty_printf(gettext ("This key was revoked on %s by %s key %s\n"),
      revokestr_from_pk(pk),algo?algo:"?",user);
  xfree(user);
       }

     if(with_revoker)
       {
         if( !pk->revkey && pk->numrevkeys )
    g10_log_bug0( "keyedit.c" , 2708, __FUNCTION__ );
         else
    for(i=0;i<pk->numrevkeys;i++)
      {
        u32 r_keyid[2];
        char *user;
        const char *algo=
   pubkey_algo_to_string(pk->revkey[i].algid);

        keyid_from_fingerprint(pk->revkey[i].fpr,
          20,r_keyid);

        user=get_user_id_string_native(r_keyid);
        tty_printf(gettext ("This key may be revoked by %s key %s"),
     algo?algo:"?",user);

        if(pk->revkey[i].class&0x40)
   {
     tty_printf(" ");
     tty_printf(gettext ("(sensitive)"));
   }

        tty_printf ("\n");
        xfree(user);
      }
       }

     keyid_from_pk(pk,((void*)0));
     tty_printf("%s%c %4u%c/%s  ",
         node->pkt->pkttype == PKT_PUBLIC_KEY? "pub":"sub",
         (node->flag & (1<<9))? '*':' ',
         nbits_from_pk( pk ),
         pubkey_letter( pk->pubkey_algo ),
         keystr(pk->keyid));

     tty_printf(gettext ("created: %s"),datestr_from_pk(pk));
     tty_printf("  ");
     if(pk->is_revoked)
       tty_printf(gettext ("revoked: %s"),revokestr_from_pk(pk));
     else if(pk->has_expired)
       tty_printf(gettext ("expired: %s"),expirestr_from_pk(pk));
     else
       tty_printf(gettext ("expires: %s"),expirestr_from_pk(pk));
     tty_printf("  ");
            tty_printf(gettext ("usage: %s"),usagestr_from_pk(pk));
     tty_printf("\n");

     if( node->pkt->pkttype == PKT_PUBLIC_KEY )
       {
  if(opt.trust_model!=TM_ALWAYS)
    {
      tty_printf("%*s", (int)keystrlen()+13,"");


      if(opt.trust_model==TM_PGP || opt.trust_model==TM_CLASSIC)
        {
   int width=14-strlen(otrust);
   if(width<=0)
     width=1;
   tty_printf(gettext ("trust: %s"), otrust);
   tty_printf("%*s",width,"");
        }

      tty_printf(gettext ("validity: %s"), trust );
      tty_printf("\n");
    }
  if( node->pkt->pkttype == PKT_PUBLIC_KEY
      && (get_ownertrust (pk)&128))
    {
      tty_printf("*** ");
      tty_printf(gettext ("This key has been disabled"));
      tty_printf("\n");
    }
       }

     if( node->pkt->pkttype == PKT_PUBLIC_KEY && with_fpr )
       {
  print_fingerprint ( pk, ((void*)0), 2 );
  tty_printf("\n");
       }
 }
 else if( node->pkt->pkttype == PKT_SECRET_KEY
     || (with_subkeys && node->pkt->pkttype == PKT_SECRET_SUBKEY) )
   {
     PKT_secret_key *sk = node->pkt->pkt.secret_key;
     tty_printf("%s%c %4u%c/%s  ",
         node->pkt->pkttype == PKT_SECRET_KEY? "sec":"ssb",
         (node->flag & (1<<9))? '*':' ',
         nbits_from_sk( sk ),
         pubkey_letter( sk->pubkey_algo ),
         keystr_from_sk(sk));
     tty_printf(gettext ("created: %s"),datestr_from_sk(sk));
     tty_printf("  ");
     tty_printf(gettext ("expires: %s"),expirestr_from_sk(sk));
     tty_printf("\n");
            if (sk->is_protected && sk->protect.s2k.mode == 1002)
              {
  tty_printf("                     ");
                tty_printf(gettext ("card-no: "));
                if (sk->protect.ivlen == 16
                    && !memcmp (sk->protect.iv, "\xD2\x76\x00\x01\x24\x01", 6))
                  {
                    for (i=8; i < 14; i++)
                      {
                        if (i == 10)
                          tty_printf (" ");
                        tty_printf ("%02X", sk->protect.iv[i]);
                      }
                  }
                else
                  {
                    for (i=0; i < sk->protect.ivlen; i++)
                      tty_printf ("%02X", sk->protect.iv[i]);
                  }
                tty_printf ("\n");
              }
   }
    }

    show_names(keyblock,primary,only_marked?(1<<4):0,with_prefs);

    if (do_warn)
        tty_printf (gettext ("Please note that the shown key validity" " is not necessarily correct\n" "unless you restart the program.\n"));


}






void
show_basic_key_info ( KBNODE keyblock )
{
  KBNODE node;
  int i;


  for (node = keyblock; node; node = node->next)
    {
      if (node->pkt->pkttype == PKT_PUBLIC_KEY)
        {
          PKT_public_key *pk = node->pkt->pkt.public_key;



          tty_printf ("%s  %4u%c/%s  ",
                      node->pkt->pkttype == PKT_PUBLIC_KEY? "pub":"sub",
                      nbits_from_pk( pk ),
                      pubkey_letter( pk->pubkey_algo ),
                      keystr_from_pk(pk));
   tty_printf(gettext ("created: %s"),datestr_from_pk(pk));
   tty_printf("  ");
   tty_printf(gettext ("expires: %s"),expirestr_from_pk(pk));
          tty_printf("\n");
          print_fingerprint ( pk, ((void*)0), 3 );
          tty_printf("\n");
 }
      else if (node->pkt->pkttype == PKT_SECRET_KEY)
        {
          PKT_secret_key *sk = node->pkt->pkt.secret_key;
          tty_printf("%s  %4u%c/%s",
                     node->pkt->pkttype == PKT_SECRET_KEY? "sec":"ssb",
                     nbits_from_sk( sk ),
                     pubkey_letter( sk->pubkey_algo ),
                     keystr_from_sk(sk));
   tty_printf(gettext ("created: %s"),datestr_from_sk(sk));
   tty_printf("  ");
   tty_printf(gettext ("expires: %s"),expirestr_from_sk(sk));
          tty_printf("\n");
          print_fingerprint (((void*)0), sk, 3 );
          tty_printf("\n");
 }
    }


  for (i=0, node = keyblock; node; node = node->next)
    {
      if (node->pkt->pkttype == PKT_USER_ID)
        {
          PKT_user_id *uid = node->pkt->pkt.user_id;
          ++i;

          tty_printf ("     ");
          if (uid->is_revoked)
            tty_printf("[%s] ",gettext ("revoked"));
          else if ( uid->is_expired )
            tty_printf("[%s] ",gettext ("expired"));
          tty_print_utf8_string (uid->name, uid->len);
          tty_printf ("\n");
        }
    }
}

static void
show_key_and_fingerprint( KBNODE keyblock )
{
  KBNODE node;
  PKT_public_key *pk = ((void*)0);

  for( node = keyblock; node; node = node->next )
    {
      if( node->pkt->pkttype == PKT_PUBLIC_KEY )
 {
   pk = node->pkt->pkt.public_key;
   tty_printf("pub   %4u%c/%s %s ",
       nbits_from_pk( pk ),
       pubkey_letter( pk->pubkey_algo ),
       keystr_from_pk(pk),
       datestr_from_pk(pk) );
 }
      else if( node->pkt->pkttype == PKT_USER_ID )
 {
   PKT_user_id *uid = node->pkt->pkt.user_id;
   tty_print_utf8_string( uid->name, uid->len );
   break;
 }
    }
  tty_printf("\n");
  if( pk )
    print_fingerprint( pk, ((void*)0), 2 );
}




static void
no_primary_warning(KBNODE keyblock)
{
  KBNODE node;
  int have_primary=0,uid_count=0;





  for(node=keyblock; node; node = node->next)
    {
      if(node->pkt->pkttype==PKT_USER_ID
  && node->pkt->pkt.user_id->attrib_data==((void*)0))
 {
   uid_count++;

   if(node->pkt->pkt.user_id->is_primary==2)
     {
       have_primary=1;
       break;
     }
 }
    }

  if(uid_count>1 && !have_primary)
    g10_log_info(gettext ("WARNING: no user ID has been marked as primary.  This command" " may\n              cause a different user ID to become" " the assumed primary.\n"));


}





static void
subkey_expire_warning (kbnode_t keyblock)
{
  u32 curtime = make_timestamp ();
  kbnode_t node;
  PKT_public_key *pk;

  u32 subexpire = 0;
  u32 latest_date = 0;

  for (node = keyblock; node; node = node->next)
    {
      if (node->pkt->pkttype != PKT_PUBLIC_SUBKEY)
        continue;
      pk = node->pkt->pkt.public_key;

      if (!pk->is_valid)
        continue;
      if (pk->is_revoked)
        continue;
      if (pk->timestamp > curtime)
        continue;
      if (!(pk->pubkey_usage & 2))
        continue;

      if (pk->timestamp > latest_date || (!pk->timestamp && !latest_date))
        {
          latest_date = pk->timestamp;
          subexpire = pk->expiredate;
        }
    }

  if (!subexpire)
    return;

  if (curtime + (10*86400) > subexpire)
    {
      g10_log_info (gettext ("WARNING: Your encryption subkey expires soon.\n"));
      g10_log_info (gettext ("You may want to change its expiration date too.\n"));
    }
}







static int
menu_adduid( KBNODE pub_keyblock, KBNODE sec_keyblock,
      int photo, const char *photo_name)
{
    PKT_user_id *uid;
    PKT_public_key *pk=((void*)0);
    PKT_secret_key *sk=((void*)0);
    PKT_signature *sig=((void*)0);
    PACKET *pkt;
    KBNODE node;
    KBNODE pub_where=((void*)0), sec_where=((void*)0);
    int rc;

    for( node = pub_keyblock; node; pub_where = node, node = node->next ) {
 if( node->pkt->pkttype == PKT_PUBLIC_KEY )
     pk = node->pkt->pkt.public_key;
 else if( node->pkt->pkttype == PKT_PUBLIC_SUBKEY )
     break;
    }
    if( !node )
 pub_where = ((void*)0);
    for( node = sec_keyblock; node; sec_where = node, node = node->next ) {
 if( node->pkt->pkttype == PKT_SECRET_KEY )
     sk = copy_secret_key( ((void*)0), node->pkt->pkt.secret_key);
 else if( node->pkt->pkttype == PKT_SECRET_SUBKEY )
     break;
    }
    if( !node )
 sec_where = ((void*)0);
    ((void)((pk && sk) || (__assert_fail("pk && sk", "keyedit.c", 3047, __func__),0)));

    if(photo) {
      int hasattrib=0;

      for( node = pub_keyblock; node; node = node->next )
 if( node->pkt->pkttype == PKT_USER_ID &&
     node->pkt->pkt.user_id->attrib_data!=((void*)0))
   {
     hasattrib=1;
     break;
   }






      if(pk->version==3 && !hasattrib)
 {
   if(opt.expert)
     {
       tty_printf(gettext ("WARNING: This is a PGP2-style key.  " "Adding a photo ID may cause some versions\n" "         of PGP to reject this key.\n"));



       if(!cpr_get_answer_is_yes("keyedit.v3_photo.okay",
     gettext ("Are you sure you still want " "to add it? (y/N) ")))

  return 0;
     }
   else
     {
       tty_printf(gettext ("You may not add a photo ID to " "a PGP2-style key.\n"));

       return 0;
     }
 }

      uid = generate_photo_id(pk,photo_name);
    } else
      uid = generate_user_id();
    if( !uid )
 return 0;

    rc = make_keysig_packet( &sig, pk, uid, ((void*)0), sk, 0x13, 0, 0, 0, 0,
        keygen_add_std_prefs, pk );
    free_secret_key( sk );
    if( rc ) {
 g10_log_error("signing failed: %s\n", g10_errstr(rc) );
 free_user_id(uid);
 return 0;
    }


    pkt = xmalloc_clear( sizeof *pkt );
    pkt->pkttype = PKT_USER_ID;
    pkt->pkt.user_id = scopy_user_id(uid);
    node = new_kbnode(pkt);
    if( sec_where )
 insert_kbnode( sec_where, node, 0 );
    else
 add_kbnode( sec_keyblock, node );
    pkt = xmalloc_clear( sizeof *pkt );
    pkt->pkttype = PKT_SIGNATURE;
    pkt->pkt.signature = copy_signature(((void*)0), sig);
    if( sec_where )
 insert_kbnode( node, new_kbnode(pkt), 0 );
    else
 add_kbnode( sec_keyblock, new_kbnode(pkt) );

    pkt = xmalloc_clear( sizeof *pkt );
    pkt->pkttype = PKT_USER_ID;
    pkt->pkt.user_id = uid;
    node = new_kbnode(pkt);
    if( pub_where )
 insert_kbnode( pub_where, node, 0 );
    else
 add_kbnode( pub_keyblock, node );
    pkt = xmalloc_clear( sizeof *pkt );
    pkt->pkttype = PKT_SIGNATURE;
    pkt->pkt.signature = copy_signature(((void*)0), sig);
    if( pub_where )
 insert_kbnode( node, new_kbnode(pkt), 0 );
    else
 add_kbnode( pub_keyblock, new_kbnode(pkt) );
    return 1;
}





static void
menu_deluid( KBNODE pub_keyblock, KBNODE sec_keyblock )
{
    KBNODE node;
    int selected=0;

    for( node = pub_keyblock; node; node = node->next ) {
 if( node->pkt->pkttype == PKT_USER_ID ) {
     selected = node->flag & (1<<8);
     if( selected ) {


  if(!node->pkt->pkt.user_id->is_revoked)
    update_trust=1;
  delete_kbnode( node );
  if( sec_keyblock ) {
      KBNODE snode;
      int s_selected = 0;
      PKT_user_id *uid = node->pkt->pkt.user_id;
      for( snode = sec_keyblock; snode; snode = snode->next ) {
   if( snode->pkt->pkttype == PKT_USER_ID ) {
       PKT_user_id *suid = snode->pkt->pkt.user_id;

       s_selected =
    (uid->len == suid->len
     && !memcmp( uid->name, suid->name, uid->len));
       if( s_selected )
    delete_kbnode( snode );
   }
   else if( s_selected
     && snode->pkt->pkttype == PKT_SIGNATURE )
       delete_kbnode( snode );
   else if( snode->pkt->pkttype == PKT_SECRET_SUBKEY )
       s_selected = 0;
      }
  }
     }
 }
 else if( selected && node->pkt->pkttype == PKT_SIGNATURE )
     delete_kbnode( node );
 else if( node->pkt->pkttype == PKT_PUBLIC_SUBKEY )
     selected = 0;
    }
    commit_kbnode( &pub_keyblock );
    if( sec_keyblock )
 commit_kbnode( &sec_keyblock );
}


static int
menu_delsig( KBNODE pub_keyblock )
{
    KBNODE node;
    PKT_user_id *uid = ((void*)0);
    int changed=0;

    for( node = pub_keyblock; node; node = node->next ) {
 if( node->pkt->pkttype == PKT_USER_ID ) {
     uid = (node->flag & (1<<8))? node->pkt->pkt.user_id : ((void*)0);
 }
 else if( uid && node->pkt->pkttype == PKT_SIGNATURE ) {
    int okay, valid, selfsig, inv_sig, no_key, other_err;

     tty_printf("uid  ");
     tty_print_utf8_string( uid->name, uid->len );
     tty_printf("\n");

     okay = inv_sig = no_key = other_err = 0;
     if(opt.with_colons)
       valid = print_and_check_one_sig_colon( pub_keyblock, node,
            &inv_sig, &no_key, &other_err,
            &selfsig, 1 );
     else
       valid = print_and_check_one_sig( pub_keyblock, node,
            &inv_sig, &no_key, &other_err,
            &selfsig, 1 );

    if( valid ) {
        okay = cpr_get_answer_yes_no_quit(
     "keyedit.delsig.valid",
     gettext ("Delete this good signature? (y/N/q)"));



        if(okay)
   update_trust=1;
    }
    else if( inv_sig || other_err )
        okay = cpr_get_answer_yes_no_quit(
     "keyedit.delsig.invalid",
     gettext ("Delete this invalid signature? (y/N/q)"));
    else if( no_key )
        okay = cpr_get_answer_yes_no_quit(
     "keyedit.delsig.unknown",
     gettext ("Delete this unknown signature? (y/N/q)"));

     if( okay == -1 )
  break;
    if( okay && selfsig && !cpr_get_answer_is_yes(
          "keyedit.delsig.selfsig",
         gettext ("Really delete this self-signature? (y/N)") ))
  okay = 0;
     if( okay ) {
  delete_kbnode( node );
  changed++;
     }

 }
 else if( node->pkt->pkttype == PKT_PUBLIC_SUBKEY )
     uid = ((void*)0);
    }

    if( changed ) {
 commit_kbnode( &pub_keyblock );
 tty_printf( changed == 1? gettext ("Deleted %d signature.\n")
    : gettext ("Deleted %d signatures.\n"), changed );
    }
    else
 tty_printf( gettext ("Nothing deleted.\n") );

    return changed;
}

static int
menu_clean(KBNODE keyblock,int self_only)
{
  KBNODE uidnode;
  int modified=0,select_all=!count_selected_uids(keyblock);

  for(uidnode=keyblock->next;
      uidnode && uidnode->pkt->pkttype!=PKT_PUBLIC_SUBKEY;
      uidnode=uidnode->next)
    {
      if(uidnode->pkt->pkttype==PKT_USER_ID
  && (uidnode->flag&(1<<8) || select_all))
 {
   int uids=0,sigs=0;
   char *user=utf8_to_native(uidnode->pkt->pkt.user_id->name,
        uidnode->pkt->pkt.user_id->len,
        0);

   clean_one_uid(keyblock,uidnode,opt.verbose,self_only,&uids,&sigs);
   if(uids)
     {
       const char *reason;

       if(uidnode->pkt->pkt.user_id->is_revoked)
  reason=gettext ("revoked");
       else if(uidnode->pkt->pkt.user_id->is_expired)
  reason=gettext ("expired");
       else
  reason=gettext ("invalid");

       tty_printf (gettext ("User ID \"%s\" compacted: %s\n"), user, reason);

       modified=1;
     }
   else if(sigs)
     {
       tty_printf (sigs==1?
     gettext ("User ID \"%s\": %d signature removed\n"):
                          gettext ("User ID \"%s\": %d signatures removed\n"),
                          user,sigs);

       modified=1;
     }
   else
     {
       tty_printf (self_only==1?
                          gettext ("User ID \"%s\": already minimized\n"):
                          gettext ("User ID \"%s\": already clean\n"),
                          user);
     }

   xfree(user);
 }
    }

  return modified;
}




static void
menu_delkey( KBNODE pub_keyblock, KBNODE sec_keyblock )
{
    KBNODE node;
    int selected=0;

    for( node = pub_keyblock; node; node = node->next ) {
 if( node->pkt->pkttype == PKT_PUBLIC_SUBKEY ) {
     selected = node->flag & (1<<9);
     if( selected ) {
  delete_kbnode( node );
  if( sec_keyblock ) {
      KBNODE snode;
      int s_selected = 0;
      u32 ki[2];

      keyid_from_pk( node->pkt->pkt.public_key, ki );
      for( snode = sec_keyblock; snode; snode = snode->next ) {
   if( snode->pkt->pkttype == PKT_SECRET_SUBKEY ) {
       u32 ki2[2];

       keyid_from_sk( snode->pkt->pkt.secret_key, ki2 );
       s_selected = (ki[0] == ki2[0] && ki[1] == ki2[1]);
       if( s_selected )
    delete_kbnode( snode );
   }
   else if( s_selected
     && snode->pkt->pkttype == PKT_SIGNATURE )
       delete_kbnode( snode );
   else
       s_selected = 0;
      }
  }
     }
 }
 else if( selected && node->pkt->pkttype == PKT_SIGNATURE )
     delete_kbnode( node );
 else
     selected = 0;
    }
    commit_kbnode( &pub_keyblock );
    if( sec_keyblock )
 commit_kbnode( &sec_keyblock );




}







static int
menu_addrevoker( KBNODE pub_keyblock, KBNODE sec_keyblock, int sensitive )
{
  PKT_public_key *pk=((void*)0),*revoker_pk=((void*)0);
  PKT_secret_key *sk=((void*)0);
  PKT_signature *sig=((void*)0);
  PACKET *pkt;
  struct revocation_key revkey;
  size_t fprlen;
  int rc;

  ((void)((pub_keyblock->pkt->pkttype==PKT_PUBLIC_KEY) || (__assert_fail("pub_keyblock->pkt->pkttype==PKT_PUBLIC_KEY", "keyedit.c", 3390, __func__),0)));
  ((void)((sec_keyblock->pkt->pkttype==PKT_SECRET_KEY) || (__assert_fail("sec_keyblock->pkt->pkttype==PKT_SECRET_KEY", "keyedit.c", 3391, __func__),0)));

  pk=pub_keyblock->pkt->pkt.public_key;

  if(pk->numrevkeys==0 && pk->version==3)
    {





      if(opt.expert)
 {
   tty_printf(gettext ("WARNING: This is a PGP 2.x-style key.  " "Adding a designated revoker may cause\n" "         some versions of PGP to reject this key.\n"));



   if(!cpr_get_answer_is_yes("keyedit.v3_revoker.okay",
        gettext ("Are you sure you still want " "to add it? (y/N) ")))

     return 0;
 }
      else
 {
   tty_printf(gettext ("You may not add a designated revoker to " "a PGP 2.x-style key.\n"));

   return 0;
 }
    }

  sk=copy_secret_key(((void*)0),sec_keyblock->pkt->pkt.secret_key);

  for(;;)
    {
      char *answer;

      if(revoker_pk)
 free_public_key(revoker_pk);

      revoker_pk=xmalloc_clear(sizeof(*revoker_pk));

      tty_printf("\n");

      answer=cpr_get_utf8("keyedit.add_revoker",
     gettext ("Enter the user ID of the designated revoker: "));
      if(answer[0]=='\0' || answer[0]=='\004')
 {
   xfree(answer);
   goto fail;
 }





      revoker_pk->req_usage=4;
      rc=get_pubkey_byname(revoker_pk,answer,((void*)0),((void*)0),1);
      if(rc)
 {
   g10_log_error (gettext ("key \"%s\" not found: %s\n"),answer,g10_errstr(rc));
   xfree(answer);
   continue;
 }

      xfree(answer);

      fingerprint_from_pk(revoker_pk,revkey.fpr,&fprlen);
      if(fprlen!=20)
 {
   g10_log_error(gettext ("cannot appoint a PGP 2.x style key as a " "designated revoker\n"));

   continue;
 }

      revkey.class=0x80;
      if(sensitive)
 revkey.class|=0x40;
      revkey.algid=revoker_pk->pubkey_algo;

      if(cmp_public_keys(revoker_pk,pk)==0)
 {



   g10_log_error(gettext ("you cannot appoint a key as its own " "designated revoker\n"));


   continue;
 }

      keyid_from_pk(pk,((void*)0));


      if(!pk->revkey && pk->numrevkeys)
 g10_log_bug0( "keyedit.c" , 3485, __FUNCTION__ );
      else
 {
   int i;

   for(i=0;i<pk->numrevkeys;i++)
     {
       if(memcmp(&pk->revkey[i],&revkey,
   sizeof(struct revocation_key))==0)
  {
    char buf[50];

    g10_log_error(gettext ("this key has already been designated " "as a revoker\n"));


    sprintf(buf,"%08lX%08lX",
     (ulong)pk->keyid[0],(ulong)pk->keyid[1]);
    write_status_text(63,buf);

    break;
  }
     }

   if(i<pk->numrevkeys)
     continue;
 }

      print_pubkey_info(((void*)0),revoker_pk);
      print_fingerprint(revoker_pk,((void*)0),2);
      tty_printf("\n");

      tty_printf(gettext ("WARNING: appointing a key as a designated revoker " "cannot be undone!\n"));


      tty_printf("\n");

      if(!cpr_get_answer_is_yes("keyedit.add_revoker.okay",
    gettext ("Are you sure you want to appoint this " "key as a designated revoker? (y/N) ")))

 continue;

      free_public_key(revoker_pk);
      revoker_pk=((void*)0);
      break;
    }



  rc = make_keysig_packet( &sig, pk, ((void*)0), ((void*)0), sk, 0x1F, 0, 4, 0, 0,
      keygen_add_revkey,&revkey );
  if( rc )
    {
      g10_log_error("signing failed: %s\n", g10_errstr(rc) );
      goto fail;
    }

  free_secret_key(sk);
  sk=((void*)0);


  pkt = xmalloc_clear( sizeof *pkt );
  pkt->pkttype = PKT_SIGNATURE;
  pkt->pkt.signature = copy_signature(((void*)0), sig);
  insert_kbnode( sec_keyblock, new_kbnode(pkt), PKT_SIGNATURE );


  pkt = xmalloc_clear( sizeof *pkt );
  pkt->pkttype = PKT_SIGNATURE;
  pkt->pkt.signature = sig;
  insert_kbnode( pub_keyblock, new_kbnode(pkt), PKT_SIGNATURE );

  return 1;

 fail:
  if(sk)
    free_secret_key(sk);
  if(sig)
    free_seckey_enc(sig);
  if(revoker_pk)
    free_public_key(revoker_pk);

  return 0;
}


static int
menu_expire( KBNODE pub_keyblock, KBNODE sec_keyblock )
{
    int n1, signumber, rc;
    u32 expiredate;
    int mainkey=0;
    PKT_secret_key *sk;
    PKT_public_key *main_pk, *sub_pk;
    PKT_user_id *uid;
    KBNODE node;
    u32 keyid[2];
    u32 timestamp=make_timestamp();

    if( count_selected_keys( sec_keyblock ) ) {
 tty_printf(gettext ("Please remove selections from the secret keys.\n"));
 return 0;
    }

    n1 = count_selected_keys( pub_keyblock );
    if( n1 > 1 ) {
 tty_printf(gettext ("Please select at most one subkey.\n"));
 return 0;
    }
    else if( n1 )
 tty_printf(gettext ("Changing expiration time for a subkey.\n"));
    else
      {
 tty_printf(gettext ("Changing expiration time for the primary key.\n"));
 mainkey=1;
 no_primary_warning(pub_keyblock);
      }

    expiredate=ask_expire_interval(timestamp,0,((void*)0));
    if(expiredate)
      expiredate+=timestamp;

    node = find_kbnode( sec_keyblock, PKT_SECRET_KEY );
    sk = copy_secret_key( ((void*)0), node->pkt->pkt.secret_key);


    main_pk = sub_pk = ((void*)0);
    uid = ((void*)0);
    signumber = 0;
    for( node=pub_keyblock; node; node = node->next ) {
 if( node->pkt->pkttype == PKT_PUBLIC_KEY ) {
     main_pk = node->pkt->pkt.public_key;
     keyid_from_pk( main_pk, keyid );
     main_pk->expiredate = expiredate;
 }
 else if( node->pkt->pkttype == PKT_PUBLIC_SUBKEY
   && (node->flag & (1<<9) ) ) {
     sub_pk = node->pkt->pkt.public_key;
     sub_pk->expiredate = expiredate;
 }
 else if( node->pkt->pkttype == PKT_USER_ID )
     uid = node->pkt->pkt.user_id;
 else if( main_pk && node->pkt->pkttype == PKT_SIGNATURE
   && ( mainkey || sub_pk ) ) {
     PKT_signature *sig = node->pkt->pkt.signature;
     if( keyid[0] == sig->keyid[0] && keyid[1] == sig->keyid[1]
  && ( (mainkey && uid
        && uid->created && (sig->sig_class&~3) == 0x10)
       || (!mainkey && sig->sig_class == 0x18) )
  && sig->flags.chosen_selfsig )
       {

  PKT_signature *newsig;
  PACKET *newpkt;
  KBNODE sn;
  int signumber2 = 0;

  signumber++;

  if( (mainkey && main_pk->version < 4)
      || (!mainkey && sub_pk->version < 4 ) ) {
      g10_log_info(gettext ("You can't change the expiration date of a v3 key\n"));

      free_secret_key( sk );
      return 0;
  }


  for( sn=sec_keyblock; sn; sn = sn->next ) {
      if( sn->pkt->pkttype == PKT_SIGNATURE ) {
   PKT_signature *b = sn->pkt->pkt.signature;
   if( keyid[0] == b->keyid[0] && keyid[1] == b->keyid[1]
       && sig->sig_class == b->sig_class
       && ++signumber2 == signumber )
       break;
      }
  }
  if( !sn )
      g10_log_info(gettext ("No corresponding signature in secret ring\n"));
# 3671 "keyedit.c"
  if( mainkey )
    rc = update_keysig_packet(&newsig, sig, main_pk, uid, ((void*)0),
         sk, keygen_add_key_expire, main_pk);
  else
    rc = update_keysig_packet(&newsig, sig, main_pk, ((void*)0), sub_pk,
         sk, keygen_add_key_expire, sub_pk );
  if( rc ) {
      g10_log_error("make_keysig_packet failed: %s\n",
          g10_errstr(rc));
      free_secret_key( sk );
      return 0;
  }

  newpkt = xmalloc_clear( sizeof *newpkt );
  newpkt->pkttype = PKT_SIGNATURE;
  newpkt->pkt.signature = newsig;
  free_packet( node->pkt );
  xfree( node->pkt );
  node->pkt = newpkt;
  if( sn ) {
      newpkt = xmalloc_clear( sizeof *newpkt );
      newpkt->pkttype = PKT_SIGNATURE;
      newpkt->pkt.signature = copy_signature( ((void*)0), newsig );
      free_packet( sn->pkt );
      xfree( sn->pkt );
      sn->pkt = newpkt;
  }
  sub_pk = ((void*)0);
     }
 }
    }

    free_secret_key( sk );
    update_trust=1;
    return 1;
}

static int
menu_backsign(KBNODE pub_keyblock,KBNODE sec_keyblock)
{
  int rc,modified=0;
  PKT_public_key *main_pk;
  PKT_secret_key *main_sk,*sub_sk=((void*)0);
  KBNODE node;
  u32 timestamp;

  ((void)((pub_keyblock->pkt->pkttype==PKT_PUBLIC_KEY) || (__assert_fail("pub_keyblock->pkt->pkttype==PKT_PUBLIC_KEY", "keyedit.c", 3717, __func__),0)));
  ((void)((sec_keyblock->pkt->pkttype==PKT_SECRET_KEY) || (__assert_fail("sec_keyblock->pkt->pkttype==PKT_SECRET_KEY", "keyedit.c", 3718, __func__),0)));

  merge_keys_and_selfsig(pub_keyblock);
  main_pk=pub_keyblock->pkt->pkt.public_key;
  main_sk=copy_secret_key(((void*)0),sec_keyblock->pkt->pkt.secret_key);
  keyid_from_pk(main_pk,((void*)0));



  timestamp = make_timestamp ();

  for(node=pub_keyblock;node;node=node->next)
    {
      PKT_public_key *sub_pk=((void*)0);
      KBNODE node2,sig_pk=((void*)0),sig_sk=((void*)0);
      char *passphrase;

      if(sub_sk)
 {
   free_secret_key(sub_sk);
   sub_sk=((void*)0);
 }


      if(node->pkt->pkttype==PKT_PUBLIC_SUBKEY)
 {
   if(node->pkt->pkt.public_key->pubkey_usage&1)
     {
       if(node->pkt->pkt.public_key->backsig)
  tty_printf(gettext ("signing subkey %s is already cross-certified\n"),
      keystr_from_pk(node->pkt->pkt.public_key));
       else
  sub_pk=node->pkt->pkt.public_key;
     }
   else
     tty_printf(gettext ("subkey %s does not sign and so does" " not need to be cross-certified\n"),

         keystr_from_pk(node->pkt->pkt.public_key));
 }

      if(!sub_pk)
 continue;


      for(node2=node->next;
   node2 && node2->pkt->pkttype==PKT_SIGNATURE;
   node2=node2->next)
 if(node2->pkt->pkt.signature->version>=4
    && node2->pkt->pkt.signature->flags.chosen_selfsig)
   {
     sig_pk=node2;
     break;
   }

      if(!sig_pk)
 continue;


      for(node2=sec_keyblock;node2;node2=node2->next)
 if(node2->pkt->pkttype==PKT_SECRET_SUBKEY
    && !cmp_public_secret_key(sub_pk,node2->pkt->pkt.secret_key))
   {
     sub_sk=copy_secret_key(((void*)0),node2->pkt->pkt.secret_key);
     break;
   }

      if(!sub_sk)
 {
   tty_printf(gettext ("no secret subkey for public subkey %s - ignoring\n"),
       keystr_from_pk(sub_pk));
   continue;
 }





      for(node2=node2->next;
   node2 && node2->pkt->pkttype!=PKT_SECRET_SUBKEY;
   node2=node2->next)
 if(node2->pkt->pkttype==PKT_SIGNATURE
    && node2->pkt->pkt.signature->version>=4
    && node2->pkt->pkt.signature->keyid[0]==sig_pk->pkt->pkt.signature->keyid[0]
    && node2->pkt->pkt.signature->keyid[1]==sig_pk->pkt->pkt.signature->keyid[1]
    && node2->pkt->pkt.signature->sig_class==sig_pk->pkt->pkt.signature->sig_class)
   {
     sig_sk=node2;
     break;
   }





      passphrase=get_last_passphrase();
      set_next_passphrase(passphrase);
      xfree(passphrase);

      rc = make_backsig (sig_pk->pkt->pkt.signature, main_pk, sub_pk, sub_sk,
                         timestamp);
      if(rc==0)
 {
   PKT_signature *newsig;
   PACKET *newpkt;

   passphrase=get_last_passphrase();
   set_next_passphrase(passphrase);
   xfree(passphrase);

   rc=update_keysig_packet(&newsig,sig_pk->pkt->pkt.signature,main_pk,
      ((void*)0),sub_pk,main_sk,((void*)0),((void*)0));
   if(rc==0)
     {

       newpkt=xmalloc_clear(sizeof(*newpkt));
       newpkt->pkttype=PKT_SIGNATURE;
       newpkt->pkt.signature=newsig;
       free_packet(sig_pk->pkt);
       xfree(sig_pk->pkt);
       sig_pk->pkt=newpkt;

       if(sig_sk)
  {

    newpkt=xmalloc_clear(sizeof(*newpkt));
    newpkt->pkttype=PKT_SIGNATURE;
    newpkt->pkt.signature=copy_signature(((void*)0),newsig);
    free_packet(sig_sk->pkt);
    xfree(sig_sk->pkt);
    sig_sk->pkt=newpkt;
  }

       modified=1;
     }
   else
     {
       g10_log_error("update_keysig_packet failed: %s\n",g10_errstr(rc));
       break;
     }
 }
      else
 {
   g10_log_error("make_backsig failed: %s\n",g10_errstr(rc));
   break;
 }
    }

  set_next_passphrase(((void*)0));

  free_secret_key(main_sk);
  if(sub_sk)
    free_secret_key(sub_sk);

  return modified;
}


static int
change_primary_uid_cb ( PKT_signature *sig, void *opaque )
{
    byte buf[1];



    delete_sig_subpkt (sig->hashed, SIGSUBPKT_PRIMARY_UID);
    delete_sig_subpkt (sig->unhashed, SIGSUBPKT_PRIMARY_UID);


    if (opaque) {
        buf[0] = 1;
        build_sig_subpkt (sig, SIGSUBPKT_PRIMARY_UID, buf, 1 );
    }

    return 0;
}
# 3903 "keyedit.c"
static int
menu_set_primary_uid ( KBNODE pub_keyblock, KBNODE sec_keyblock )
{
    PKT_secret_key *sk;
    PKT_public_key *main_pk;
    PKT_user_id *uid;
    KBNODE node;
    u32 keyid[2];
    int selected;
    int attribute = 0;
    int modified = 0;

    if ( count_selected_uids (pub_keyblock) != 1 ) {
 tty_printf(gettext ("Please select exactly one user ID.\n"));
 return 0;
    }

    node = find_kbnode( sec_keyblock, PKT_SECRET_KEY );
    sk = copy_secret_key( ((void*)0), node->pkt->pkt.secret_key);


    main_pk = ((void*)0);
    uid = ((void*)0);
    selected = 0;


    for ( node=pub_keyblock; node; node = node->next )
      if (node->pkt->pkttype == PKT_USER_ID && node->flag & (1<<8))
 attribute = (node->pkt->pkt.user_id->attrib_data!=((void*)0));

    for ( node=pub_keyblock; node; node = node->next ) {
 if ( node->pkt->pkttype == PKT_PUBLIC_SUBKEY )
            break;

 if ( node->pkt->pkttype == PKT_PUBLIC_KEY ) {
     main_pk = node->pkt->pkt.public_key;
     keyid_from_pk( main_pk, keyid );
 }
 else if ( node->pkt->pkttype == PKT_USER_ID ) {
     uid = node->pkt->pkt.user_id;
            selected = node->flag & (1<<8);
        }
 else if ( main_pk && uid && node->pkt->pkttype == PKT_SIGNATURE ) {
     PKT_signature *sig = node->pkt->pkt.signature;
     if ( keyid[0] == sig->keyid[0] && keyid[1] == sig->keyid[1]
   && (uid && (sig->sig_class&~3) == 0x10)
   && attribute == (uid->attrib_data!=((void*)0))
   && sig->flags.chosen_selfsig )
       {
       if(sig->version < 4) {
  char *user=utf8_to_native(uid->name,strlen(uid->name),0);

  g10_log_info(gettext ("skipping v3 self-signature on user ID \"%s\"\n"),
    user);
  xfree(user);
       }
       else {
# 3972 "keyedit.c"
  PKT_signature *newsig;
  PACKET *newpkt;
                const byte *p;
                int action;


                p = parse_sig_subpkt (sig->hashed,
                                      SIGSUBPKT_PRIMARY_UID, ((void*)0) );
                if ( !p )
                    p = parse_sig_subpkt (sig->unhashed,
                                          SIGSUBPKT_PRIMARY_UID, ((void*)0) );
                if ( p && *p )
                    action = selected? 0 : -1;
                else
                    action = selected? 1 : 0;

                if (action) {
                    int rc = update_keysig_packet (&newsig, sig,
            main_pk, uid, ((void*)0),
                                               sk,
                                               change_primary_uid_cb,
                                               action > 0? "x":((void*)0) );
                    if( rc ) {
                        g10_log_error ("update_keysig_packet failed: %s\n",
                                   g10_errstr(rc));
                        free_secret_key( sk );
                        return 0;
                    }

                    newpkt = xmalloc_clear( sizeof *newpkt );
                    newpkt->pkttype = PKT_SIGNATURE;
                    newpkt->pkt.signature = newsig;
                    free_packet( node->pkt );
                    xfree( node->pkt );
                    node->pkt = newpkt;
                    modified = 1;
  }
       }
     }
 }
    }

    free_secret_key( sk );
    return modified;
}





static int
menu_set_preferences (KBNODE pub_keyblock, KBNODE sec_keyblock )
{
    PKT_secret_key *sk;
    PKT_public_key *main_pk;
    PKT_user_id *uid;
    KBNODE node;
    u32 keyid[2];
    int selected, select_all;
    int modified = 0;

    no_primary_warning(pub_keyblock);

    select_all = !count_selected_uids (pub_keyblock);

    node = find_kbnode( sec_keyblock, PKT_SECRET_KEY );
    sk = copy_secret_key( ((void*)0), node->pkt->pkt.secret_key);


    main_pk = ((void*)0);
    uid = ((void*)0);
    selected = 0;
    for ( node=pub_keyblock; node; node = node->next ) {
 if ( node->pkt->pkttype == PKT_PUBLIC_SUBKEY )
            break;

 if ( node->pkt->pkttype == PKT_PUBLIC_KEY ) {
     main_pk = node->pkt->pkt.public_key;
     keyid_from_pk( main_pk, keyid );
 }
 else if ( node->pkt->pkttype == PKT_USER_ID ) {
     uid = node->pkt->pkt.user_id;
            selected = select_all || (node->flag & (1<<8));
        }
 else if ( main_pk && uid && selected
                  && node->pkt->pkttype == PKT_SIGNATURE ) {
     PKT_signature *sig = node->pkt->pkt.signature;
     if ( keyid[0] == sig->keyid[0] && keyid[1] == sig->keyid[1]
   && (uid && (sig->sig_class&~3) == 0x10)
   && sig->flags.chosen_selfsig ) {
       if( sig->version < 4 ) {
  char *user=utf8_to_native(uid->name,strlen(uid->name),0);

  g10_log_info(gettext ("skipping v3 self-signature on user ID \"%s\"\n"),
    user);
  xfree(user);
       }
       else {



  PKT_signature *newsig;
  PACKET *newpkt;
                int rc;

                rc = update_keysig_packet (&newsig, sig,
                                           main_pk, uid, ((void*)0),
                                           sk,
                                           keygen_upd_std_prefs,
                                           ((void*)0) );
                if( rc ) {
                    g10_log_error ("update_keysig_packet failed: %s\n",
                               g10_errstr(rc));
                    free_secret_key( sk );
                    return 0;
                }

                newpkt = xmalloc_clear( sizeof *newpkt );
                newpkt->pkttype = PKT_SIGNATURE;
                newpkt->pkt.signature = newsig;
                free_packet( node->pkt );
                xfree( node->pkt );
                node->pkt = newpkt;
                modified = 1;
       }
            }
 }
    }

    free_secret_key( sk );
    return modified;
}


static int
menu_set_keyserver_url (const char *url,
   KBNODE pub_keyblock, KBNODE sec_keyblock )
{
  PKT_secret_key *sk;
  PKT_public_key *main_pk;
  PKT_user_id *uid;
  KBNODE node;
  u32 keyid[2];
  int selected, select_all;
  int modified = 0;
  char *answer,*uri;

  no_primary_warning(pub_keyblock);

  if(url)
    answer=xstrdup(url);
  else
    {
      answer=cpr_get_utf8("keyedit.add_keyserver",
     gettext ("Enter your preferred keyserver URL: "));
      if(answer[0]=='\0' || answer[0]=='\004')
 {
   xfree(answer);
   return 0;
 }
    }

  if(ascii_strcasecmp(answer,"none")==0)
    uri=((void*)0);
  else
    {
      struct keyserver_spec *keyserver=((void*)0);

      keyserver=parse_keyserver_uri(answer,1,((void*)0),0);
      xfree(answer);
      if(!keyserver)
 {
   g10_log_info(gettext ("could not parse keyserver URL\n"));
   return 0;
 }
      uri=xstrdup(keyserver->uri);
      free_keyserver_spec(keyserver);
    }

  select_all = !count_selected_uids (pub_keyblock);

  node = find_kbnode( sec_keyblock, PKT_SECRET_KEY );
  sk = copy_secret_key( ((void*)0), node->pkt->pkt.secret_key);


  main_pk = ((void*)0);
  uid = ((void*)0);
  selected = 0;
  for ( node=pub_keyblock; node; node = node->next )
    {
      if ( node->pkt->pkttype == PKT_PUBLIC_SUBKEY )
 break;

      if ( node->pkt->pkttype == PKT_PUBLIC_KEY )
 {
   main_pk = node->pkt->pkt.public_key;
   keyid_from_pk( main_pk, keyid );
 }
      else if ( node->pkt->pkttype == PKT_USER_ID )
 {
   uid = node->pkt->pkt.user_id;
   selected = select_all || (node->flag & (1<<8));
 }
      else if ( main_pk && uid && selected
  && node->pkt->pkttype == PKT_SIGNATURE )
 {
   PKT_signature *sig = node->pkt->pkt.signature;
   if ( keyid[0] == sig->keyid[0] && keyid[1] == sig->keyid[1]
        && (uid && (sig->sig_class&~3) == 0x10)
        && sig->flags.chosen_selfsig)
     {
       char *user=utf8_to_native(uid->name,strlen(uid->name),0);
       if( sig->version < 4 )
  g10_log_info(gettext ("skipping v3 self-signature on user ID \"%s\"\n"),
    user);
       else
  {



    PKT_signature *newsig;
    PACKET *newpkt;
    int rc;
    const byte *p;
    size_t plen;

    p=parse_sig_subpkt(sig->hashed,SIGSUBPKT_PREF_KS,&plen);
    if(p && plen)
      {
        tty_printf("Current preferred keyserver for user"
     " ID \"%s\": ",user);
        tty_print_utf8_string(p,plen);
        tty_printf("\n");
        if(!cpr_get_answer_is_yes("keyedit.confirm_keyserver",
    uri?gettext ("Are you sure you want to replace it? (y/N) "):
        gettext ("Are you sure you want to delete it? (y/N) ")))
   continue;
      }
    else if(uri==((void*)0))
      {


        continue;
      }

    rc = update_keysig_packet (&newsig, sig,
          main_pk, uid, ((void*)0),
          sk,
          keygen_add_keyserver_url, uri );
    if( rc )
      {
        g10_log_error ("update_keysig_packet failed: %s\n",
     g10_errstr(rc));
        free_secret_key( sk );
        xfree(uri);
        return 0;
      }

    newpkt = xmalloc_clear( sizeof *newpkt );
    newpkt->pkttype = PKT_SIGNATURE;
    newpkt->pkt.signature = newsig;
    free_packet( node->pkt );
    xfree( node->pkt );
    node->pkt = newpkt;
    modified = 1;
  }

       xfree(user);
     }
 }
    }

  xfree(uri);
  free_secret_key( sk );
  return modified;
}

static int
menu_set_notation(const char *string,KBNODE pub_keyblock,KBNODE sec_keyblock)
{
  PKT_secret_key *sk;
  PKT_public_key *main_pk;
  PKT_user_id *uid;
  KBNODE node;
  u32 keyid[2];
  int selected, select_all;
  int modified = 0;
  char *answer;
  struct notation *notation;

  no_primary_warning(pub_keyblock);

  if(string)
    answer=xstrdup(string);
  else
    {
      answer=cpr_get_utf8("keyedit.add_notation",
     gettext ("Enter the notation: "));
      if(answer[0]=='\0' || answer[0]=='\004')
 {
   xfree(answer);
   return 0;
 }
    }

  if(ascii_strcasecmp(answer,"none")==0
     || ascii_strcasecmp(answer,"-")==0)
    notation=((void*)0);
  else
    {
      notation=string_to_notation(answer,0);
      if(!notation)
 {
   xfree(answer);
   return 0;
 }
    }

  xfree(answer);

  select_all = !count_selected_uids (pub_keyblock);

  node = find_kbnode( sec_keyblock, PKT_SECRET_KEY );
  sk = copy_secret_key( ((void*)0), node->pkt->pkt.secret_key);


  main_pk = ((void*)0);
  uid = ((void*)0);
  selected = 0;
  for ( node=pub_keyblock; node; node = node->next )
    {
      if ( node->pkt->pkttype == PKT_PUBLIC_SUBKEY )
 break;

      if ( node->pkt->pkttype == PKT_PUBLIC_KEY )
 {
   main_pk = node->pkt->pkt.public_key;
   keyid_from_pk( main_pk, keyid );
 }
      else if ( node->pkt->pkttype == PKT_USER_ID )
 {
   uid = node->pkt->pkt.user_id;
   selected = select_all || (node->flag & (1<<8));
 }
      else if ( main_pk && uid && selected
  && node->pkt->pkttype == PKT_SIGNATURE )
 {
   PKT_signature *sig = node->pkt->pkt.signature;
   if ( keyid[0] == sig->keyid[0] && keyid[1] == sig->keyid[1]
        && (uid && (sig->sig_class&~3) == 0x10)
        && sig->flags.chosen_selfsig)
     {
       char *user=utf8_to_native(uid->name,strlen(uid->name),0);
       if( sig->version < 4 )
  g10_log_info(gettext ("skipping v3 self-signature on user ID \"%s\"\n"),
    user);
       else
  {
    PKT_signature *newsig;
    PACKET *newpkt;
    int rc,skip=0,addonly=1;

    if(sig->flags.notation)
      {
        tty_printf("Current notations for user ID \"%s\":\n",
     user);
        tty_print_notations(-9,sig);
      }
    else
      {
        tty_printf("No notations on user ID \"%s\"\n",user);
        if(notation==((void*)0))
   {


     continue;
   }
      }

    if(notation)
      {
        struct notation *n;
        int deleting=0;

        notation->next=sig_to_notation(sig);

        for(n=notation->next;n;n=n->next)
   if(strcmp(n->name,notation->name)==0)
     {
       if(notation->value)
         {
    if(strcmp(n->value,notation->value)==0)
      {
        if(notation->flags.ignore)
          {


     n->flags.ignore=1;
     deleting=1;
          }
        else
          {



     skip=1;
     tty_printf("Skipping notation:"
         " %s=%s\n",
         notation->name,
         notation->value);
     break;
          }
      }
         }
       else
         {

    n->flags.ignore=1;
    deleting=1;
         }

       if(n->flags.ignore)
         {
    tty_printf("Removing notation: %s=%s\n",
        n->name,n->value);
    addonly=0;
         }
     }

        if(!notation->flags.ignore && !skip)
   tty_printf("Adding notation: %s=%s\n",
       notation->name,notation->value);


        if(notation->flags.ignore && !deleting)
   continue;
      }
    else
      {
        tty_printf("Removing all notations\n");
        addonly=0;
      }

    if(skip
       || (!addonly
    && !cpr_get_answer_is_yes("keyedit.confirm_notation",
         gettext ("Proceed? (y/N) "))))
      continue;

    rc = update_keysig_packet (&newsig, sig,
          main_pk, uid, ((void*)0),
          sk,
          keygen_add_notations, notation );
    if( rc )
      {
        g10_log_error ("update_keysig_packet failed: %s\n",
     g10_errstr(rc));
        free_secret_key( sk );
        free_notation(notation);
        xfree(user);
        return 0;
      }


    newpkt = xmalloc_clear( sizeof *newpkt );
    newpkt->pkttype = PKT_SIGNATURE;
    newpkt->pkt.signature = newsig;
    free_packet( node->pkt );
    xfree( node->pkt );
    node->pkt = newpkt;
    modified = 1;

    if(notation)
      {

        free_notation(notation->next);
        notation->next=((void*)0);
      }

    xfree(user);
  }
     }
 }
    }

  free_notation(notation);
  free_secret_key( sk );
  return modified;
}






static int
menu_select_uid( KBNODE keyblock, int idx )
{
    KBNODE node;
    int i;


    if( idx ) {
 for( i=0, node = keyblock; node; node = node->next ) {
     if( node->pkt->pkttype == PKT_USER_ID ) {
  if( ++i == idx )
      break;
     }
 }
 if( !node ) {
     tty_printf(gettext ("No user ID with index %d\n"), idx );
     return 0;
 }
    }
    else {
 for( i=0, node = keyblock; node; node = node->next ) {
     if( node->pkt->pkttype == PKT_USER_ID )
  node->flag &= ~(1<<8);
 }
 return 1;
    }

    for( i=0, node = keyblock; node; node = node->next ) {
 if( node->pkt->pkttype == PKT_USER_ID ) {
     if( ++i == idx ) {
  if( (node->flag & (1<<8)) )
      node->flag &= ~(1<<8);
  else
      node->flag |= (1<<8);
     }
 }
    }

    return 1;
}


static int
menu_select_uid_namehash( KBNODE keyblock, const char *namehash )
{
  byte hash[20];
  KBNODE node;
  int i;

  ((void)((strlen(namehash)==20*2) || (__assert_fail("strlen(namehash)==NAMEHASH_LEN*2", "keyedit.c", 4516, __func__),0)));

  for(i=0;i<20;i++)
    hash[i]=hextobyte(&namehash[i*2]);

  for(node=keyblock->next;node;node=node->next)
    {
      if(node->pkt->pkttype==PKT_USER_ID)
 {
   namehash_from_uid(node->pkt->pkt.user_id);
   if(memcmp(node->pkt->pkt.user_id->namehash,hash,20)==0)
     {
       if(node->flag&(1<<8))
  node->flag &= ~(1<<8);
       else
  node->flag |= (1<<8);

       break;
     }
 }
    }

    if(!node)
      {
 tty_printf(gettext ("No user ID with hash %s\n"),namehash);
 return 0;
      }

  return 1;
}





static int
menu_select_key( KBNODE keyblock, int idx )
{
    KBNODE node;
    int i;


    if( idx ) {
 for( i=0, node = keyblock; node; node = node->next ) {
     if( node->pkt->pkttype == PKT_PUBLIC_SUBKEY
  || node->pkt->pkttype == PKT_SECRET_SUBKEY ) {
  if( ++i == idx )
      break;
     }
 }
 if( !node ) {
     tty_printf(gettext ("No subkey with index %d\n"), idx );
     return 0;
 }
    }
    else {
 for( i=0, node = keyblock; node; node = node->next ) {
     if( node->pkt->pkttype == PKT_PUBLIC_SUBKEY
  || node->pkt->pkttype == PKT_SECRET_SUBKEY )
  node->flag &= ~(1<<9);
 }
 return 1;
    }

    for( i=0, node = keyblock; node; node = node->next ) {
 if( node->pkt->pkttype == PKT_PUBLIC_SUBKEY
     || node->pkt->pkttype == PKT_SECRET_SUBKEY ) {
     if( ++i == idx ) {
  if( (node->flag & (1<<9)) )
      node->flag &= ~(1<<9);
  else
      node->flag |= (1<<9);
     }
 }
    }

    return 1;
}


static int
count_uids_with_flag( KBNODE keyblock, unsigned flag )
{
    KBNODE node;
    int i=0;

    for( node = keyblock; node; node = node->next )
 if( node->pkt->pkttype == PKT_USER_ID && (node->flag & flag) )
     i++;
    return i;
}

static int
count_keys_with_flag( KBNODE keyblock, unsigned flag )
{
    KBNODE node;
    int i=0;

    for( node = keyblock; node; node = node->next )
 if( ( node->pkt->pkttype == PKT_PUBLIC_SUBKEY
       || node->pkt->pkttype == PKT_SECRET_SUBKEY)
     && (node->flag & flag) )
     i++;
    return i;
}

static int
count_uids( KBNODE keyblock )
{
    KBNODE node;
    int i=0;

    for( node = keyblock; node; node = node->next )
 if( node->pkt->pkttype == PKT_USER_ID )
     i++;
    return i;
}





static int
count_selected_uids( KBNODE keyblock )
{
    return count_uids_with_flag( keyblock, (1<<8));
}

static int
count_selected_keys( KBNODE keyblock )
{
    return count_keys_with_flag( keyblock, (1<<9));
}


static int
real_uids_left( KBNODE keyblock )
{
  KBNODE node;
  int real=0;

  for(node=keyblock;node;node=node->next)
    if(node->pkt->pkttype==PKT_USER_ID && !(node->flag&(1<<8)) &&
       !node->pkt->pkt.user_id->attrib_data)
      real++;

  return real;
}





static void
ask_revoke_sig( KBNODE keyblock, KBNODE node )
{
    int doit=0;
    PKT_user_id *uid;
    PKT_signature *sig = node->pkt->pkt.signature;
    KBNODE unode = find_prev_kbnode( keyblock, node, PKT_USER_ID );

    if( !unode ) {
 g10_log_error("Oops: no user ID for signature\n");
 return;
    }

    uid=unode->pkt->pkt.user_id;

    if(opt.with_colons)
      {
 if(uid->attrib_data)
   printf("uat:::::::::%u %lu",uid->numattribs,uid->attrib_len);
 else
   {
     printf("uid:::::::::");
     print_string ((stdout), uid->name, uid->len, ':');
   }

 printf("\n");

 print_and_check_one_sig_colon(keyblock,node,((void*)0),((void*)0),((void*)0),((void*)0),1);
      }
    else
      {
 char *p=utf8_to_native(unode->pkt->pkt.user_id->name,
    unode->pkt->pkt.user_id->len,0);
 tty_printf(gettext ("user ID: \"%s\"\n"),p);
 xfree(p);

 tty_printf(gettext ("signed by your key %s on %s%s%s\n"),
     keystr(sig->keyid),datestr_from_sig(sig),
     sig->flags.exportable?"":gettext (" (non-exportable)"),"");
      }
    if(sig->flags.expired)
      {
 tty_printf(gettext ("This signature expired on %s.\n"),
     expirestr_from_sig(sig));

 doit=cpr_get_answer_is_yes("ask_revoke_sig.expired",
   gettext ("Are you sure you still want to revoke it? (y/N) "));
      }
    else
      doit=cpr_get_answer_is_yes("ask_revoke_sig.one",
       gettext ("Create a revocation certificate for this signature? (y/N) "));

    if(doit) {
      node->flag |= (1<<4);
      unode->flag |= (1<<4);
    }
}







static int
menu_revsig( KBNODE keyblock )
{
    PKT_signature *sig;
    PKT_public_key *primary_pk;
    KBNODE node;
    int changed = 0;
    int rc, any, skip=1, all=!count_selected_uids(keyblock);
    struct revocation_reason_info *reason = ((void*)0);

    ((void)((keyblock->pkt->pkttype==PKT_PUBLIC_KEY) || (__assert_fail("keyblock->pkt->pkttype==PKT_PUBLIC_KEY", "keyedit.c", 4743, __func__),0)));


    any = 0;
    for (node = keyblock; node; node = node->next )
      {
 node->flag &= ~((1<<10) | (1<<4));
 if (node->pkt->pkttype == PKT_USER_ID) {
          if (node->flag&(1<<8) || all)
            skip = 0;
          else
            skip = 1;
 }
 else if (!skip && node->pkt->pkttype == PKT_SIGNATURE
                 && ((sig = node->pkt->pkt.signature),
                     !seckey_available(sig->keyid) ))
   {
     if ((sig->sig_class&~3) == 0x10)
       {
                any = 1;
                break;
              }
   }
      }

    if (!any)
      {
        tty_printf (gettext ("Not signed by you.\n"));
        return 0;
      }



    tty_printf(gettext ("You have signed these user IDs on key %s:\n"),
        keystr_from_pk(keyblock->pkt->pkt.public_key));
    for( node = keyblock; node; node = node->next ) {
 node->flag &= ~((1<<10) | (1<<4));
 if( node->pkt->pkttype == PKT_USER_ID ) {
     if( node->flag&(1<<8) || all ) {
       PKT_user_id *uid = node->pkt->pkt.user_id;

       tty_printf("     ");
       tty_print_utf8_string( uid->name, uid->len );
       tty_printf("\n");
       skip=0;
     }
     else
       skip=1;
 }
 else if( !skip && node->pkt->pkttype == PKT_SIGNATURE
  && ((sig = node->pkt->pkt.signature),
                     !seckey_available(sig->keyid) ) )
   {
     if( (sig->sig_class&~3) == 0x10 )
       {
  tty_printf("   ");
  tty_printf(gettext ("signed by your key %s on %s%s%s\n"),
      keystr(sig->keyid), datestr_from_sig(sig),
      sig->flags.exportable?"":gettext (" (non-exportable)"),
      sig->flags.revocable?"":gettext (" (non-revocable)"));
  if(sig->flags.revocable)
    node->flag |= (1<<10);
       }
     else if( sig->sig_class == 0x30 )
       {
  tty_printf("   ");
  tty_printf(gettext ("revoked by your key %s on %s\n"),
      keystr(sig->keyid),datestr_from_sig(sig));
       }
   }
    }

    tty_printf("\n");


    for( node = keyblock; node; node = node->next ) {
 if( !(node->flag & (1<<10)) )
     continue;
 ask_revoke_sig( keyblock, node );
    }


    any = 0;
    for( node = keyblock; node; node = node->next ) {
 if( !(node->flag & (1<<4)) )
     continue;
 if( !any ) {
     any = 1;
     tty_printf(gettext ("You are about to revoke these signatures:\n"));
 }
 if( node->pkt->pkttype == PKT_USER_ID ) {
     PKT_user_id *uid = node->pkt->pkt.user_id;
     tty_printf("     ");
     tty_print_utf8_string( uid->name, uid->len );
     tty_printf("\n");
 }
 else if( node->pkt->pkttype == PKT_SIGNATURE ) {
     sig = node->pkt->pkt.signature;
     tty_printf("   ");
     tty_printf(gettext ("signed by your key %s on %s%s%s\n"),
          keystr(sig->keyid), datestr_from_sig(sig),"",
         sig->flags.exportable?"":gettext (" (non-exportable)") );
 }
    }
    if( !any )
 return 0;

    if( !cpr_get_answer_is_yes("ask_revoke_sig.okay",
  gettext ("Really create the revocation certificates? (y/N) ")) )
 return 0;

    reason = ask_revocation_reason( 0, 1, 0 );
    if( !reason ) {
 return 0;
    }


  reloop:
    primary_pk = keyblock->pkt->pkt.public_key;
    for( node=keyblock; node; node = node->next ) {
 KBNODE unode;
 PACKET *pkt;
 struct sign_attrib attrib;
 PKT_secret_key *sk;

 if( !(node->flag & (1<<4))
     || node->pkt->pkttype != PKT_SIGNATURE )
     continue;
 unode = find_prev_kbnode( keyblock, node, PKT_USER_ID );
 ((void)((unode) || (__assert_fail("unode", "keyedit.c", 4872, __func__),0)));

 memset( &attrib, 0, sizeof attrib );
 attrib.reason = reason;
 attrib.non_exportable=!node->pkt->pkt.signature->flags.exportable;

 node->flag &= ~(1<<4);
 sk = xmalloc_secure_clear( sizeof *sk );
 if( get_seckey( sk, node->pkt->pkt.signature->keyid ) ) {
     g10_log_info(gettext ("no secret key\n"));
     continue;
 }
 rc = make_keysig_packet( &sig, primary_pk,
           unode->pkt->pkt.user_id,
           ((void*)0),
           sk,
           0x30, 0, 0, 0, 0,
           sign_mk_attrib,
           &attrib );
 free_secret_key(sk);
 if( rc ) {
     g10_log_error(gettext ("signing failed: %s\n"), g10_errstr(rc));
     release_revocation_reason_info( reason );
     return changed;
 }
 changed = 1;
 update_trust = 1;

 if(primary_pk->keyid[0]==sig->keyid[0] &&
    primary_pk->keyid[1]==sig->keyid[1])
   unode->pkt->pkt.user_id->is_revoked=1;
 pkt = xmalloc_clear( sizeof *pkt );
 pkt->pkttype = PKT_SIGNATURE;
 pkt->pkt.signature = sig;
 insert_kbnode( unode, new_kbnode(pkt), 0 );
 goto reloop;
    }

    release_revocation_reason_info( reason );
    return changed;
}



static int
menu_revuid( KBNODE pub_keyblock, KBNODE sec_keyblock )
{
  PKT_public_key *pk = pub_keyblock->pkt->pkt.public_key;
  PKT_secret_key *sk = copy_secret_key( ((void*)0),
     sec_keyblock->pkt->pkt.secret_key );
  KBNODE node;
  int changed = 0;
  int rc;
  struct revocation_reason_info *reason = ((void*)0);






  for( node = pub_keyblock; node; node = node->next )
    if(pk->version>3 || (node->pkt->pkttype==PKT_USER_ID &&
    node->pkt->pkt.user_id->selfsigversion>3))
      {
 if((reason = ask_revocation_reason( 0, 1, 4 )))
   break;
 else
   goto leave;
      }

 reloop:
  for( node = pub_keyblock; node; node = node->next )
    if(node->pkt->pkttype == PKT_USER_ID && (node->flag & (1<<8)))
      {
 PKT_user_id *uid=node->pkt->pkt.user_id;

 if(uid->is_revoked)
   {
     char *user=utf8_to_native(uid->name,uid->len,0);
     g10_log_info(gettext ("user ID \"%s\" is already revoked\n"),user);
     xfree(user);
   }
 else
   {
     PACKET *pkt;
     PKT_signature *sig;
     struct sign_attrib attrib;
     u32 timestamp=make_timestamp();

     if(uid->created>=timestamp)
       {





  g10_log_info(gettext ("WARNING: a user ID signature is dated %d" " seconds in the future\n"),uid->created-timestamp);


  timestamp=uid->created+1;
       }

     memset( &attrib, 0, sizeof attrib );
     attrib.reason = reason;

     node->flag &= ~(1<<8);

     rc = make_keysig_packet( &sig, pk, uid, ((void*)0), sk, 0x30, 0,
         (reason==((void*)0))?3:0, timestamp, 0,
         sign_mk_attrib, &attrib );
     if( rc )
       {
  g10_log_error(gettext ("signing failed: %s\n"), g10_errstr(rc));
  goto leave;
       }
     else
       {
  pkt = xmalloc_clear( sizeof *pkt );
  pkt->pkttype = PKT_SIGNATURE;
  pkt->pkt.signature = sig;
  insert_kbnode( node, new_kbnode(pkt), 0 );



  if(!update_trust
     && (get_validity(pk,uid)&15)>=2)
    update_trust=1;

  changed = 1;
  node->pkt->pkt.user_id->is_revoked=1;

  goto reloop;
       }
   }
      }

  if(changed)
    commit_kbnode( &pub_keyblock );

 leave:
  free_secret_key(sk);
  release_revocation_reason_info( reason );
  return changed;
}




static int
menu_revkey( KBNODE pub_keyblock, KBNODE sec_keyblock )
{
  PKT_public_key *pk=pub_keyblock->pkt->pkt.public_key;
  PKT_secret_key *sk;
  int rc,changed = 0;
  struct revocation_reason_info *reason;
  PACKET *pkt;
  PKT_signature *sig;

  if(pk->is_revoked)
    {
      tty_printf(gettext ("Key %s is already revoked.\n"),keystr_from_pk(pk));
      return 0;
    }

  reason = ask_revocation_reason( 1, 0, 0 );

  if( !reason )
    return 0;

  sk = copy_secret_key( ((void*)0), sec_keyblock->pkt->pkt.secret_key );
  rc = make_keysig_packet( &sig, pk, ((void*)0), ((void*)0), sk,
      0x20, 0, opt.force_v4_certs?4:0, 0, 0,
      revocation_reason_build_cb, reason );
  free_secret_key(sk);
  if( rc )
    {
      g10_log_error(gettext ("signing failed: %s\n"), g10_errstr(rc));
      goto scram;
    }

  changed = 1;

  pkt = xmalloc_clear( sizeof *pkt );
  pkt->pkttype = PKT_SIGNATURE;
  pkt->pkt.signature = sig;
  insert_kbnode( pub_keyblock, new_kbnode(pkt), 0 );
  commit_kbnode( &pub_keyblock );

  update_trust=1;

 scram:
  release_revocation_reason_info( reason );
  return changed;
}

static int
menu_revsubkey( KBNODE pub_keyblock, KBNODE sec_keyblock )
{
    PKT_public_key *mainpk;
    KBNODE node;
    int changed = 0;
    int rc;
    struct revocation_reason_info *reason = ((void*)0);

    reason = ask_revocation_reason( 1, 0, 0 );
    if( !reason ) {
 return 0;
    }

  reloop:
    mainpk = pub_keyblock->pkt->pkt.public_key;
    for( node = pub_keyblock; node; node = node->next ) {
 if( node->pkt->pkttype == PKT_PUBLIC_SUBKEY
     && (node->flag & (1<<9)) ) {
     PACKET *pkt;
     PKT_signature *sig;
     PKT_secret_key *sk;
     PKT_public_key *subpk = node->pkt->pkt.public_key;
     struct sign_attrib attrib;

     if(subpk->is_revoked)
       {
  tty_printf(gettext ("Subkey %s is already revoked.\n"),
      keystr_from_pk(subpk));
  continue;
       }

     memset( &attrib, 0, sizeof attrib );
     attrib.reason = reason;

     node->flag &= ~(1<<9);
     sk = copy_secret_key( ((void*)0), sec_keyblock->pkt->pkt.secret_key );
     rc = make_keysig_packet( &sig, mainpk, ((void*)0), subpk, sk,
                                     0x28, 0, 0, 0, 0,
         sign_mk_attrib, &attrib );
     free_secret_key(sk);
     if( rc ) {
  g10_log_error(gettext ("signing failed: %s\n"), g10_errstr(rc));
  release_revocation_reason_info( reason );
  return changed;
     }
     changed = 1;

     pkt = xmalloc_clear( sizeof *pkt );
     pkt->pkttype = PKT_SIGNATURE;
     pkt->pkt.signature = sig;
     insert_kbnode( node, new_kbnode(pkt), 0 );
     goto reloop;
 }
    }
    commit_kbnode( &pub_keyblock );






    release_revocation_reason_info( reason );
    return changed;
}





static int
enable_disable_key( KBNODE keyblock, int disable )
{
    PKT_public_key *pk = find_kbnode( keyblock, PKT_PUBLIC_KEY )
       ->pkt->pkt.public_key;
    unsigned int trust, newtrust;

    trust = newtrust = get_ownertrust (pk);
    newtrust &= ~128;
    if( disable )
 newtrust |= 128;
    if( trust == newtrust )
 return 0;
    update_ownertrust(pk, newtrust );
    return 0;
}


static void
menu_showphoto( KBNODE keyblock )
{
  KBNODE node;
  int select_all = !count_selected_uids(keyblock);
  int count=0;
  PKT_public_key *pk=((void*)0);





  for( node = keyblock; node; node = node->next )
    {
      if( node->pkt->pkttype == PKT_PUBLIC_KEY )
 pk = node->pkt->pkt.public_key;
      else if( node->pkt->pkttype == PKT_USER_ID )
 {
   PKT_user_id *uid = node->pkt->pkt.user_id;
   count++;

   if((select_all || (node->flag & (1<<8))) &&
      uid->attribs!=((void*)0))
     {
       int i;

       for(i=0;i<uid->numattribs;i++)
  {
    byte type;
    u32 size;

    if(uid->attribs[i].type==1 &&
       parse_image_header(&uid->attribs[i],&type,&size))
      {
        tty_printf(gettext ("Displaying %s photo ID of size %ld for " "key %s (uid %d)\n"),

     image_type_to_string(type,1),
     (ulong)size,keystr_from_pk(pk),count);
        show_photos(&uid->attribs[i],1,pk,((void*)0),uid);
      }
  }
     }
 }
    }
}
