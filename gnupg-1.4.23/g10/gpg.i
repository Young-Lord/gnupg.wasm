# 1 "gpg.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 363 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "gpg.c" 2
# 21 "gpg.c"
# 1 "../config.h" 1
# 22 "gpg.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/errno.h" 1 3







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/features.h" 1 3
# 9 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/errno.h" 2 3

# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/errno.h" 1 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 1 3
# 29 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 1 3
# 84 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_header_macro.h" 1 3
# 85 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3



# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 89 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_size_t.h" 1 3
# 18 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 94 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 103 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_wchar_t.h" 1 3
# 24 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_wchar_t.h" 3
typedef int wchar_t;
# 104 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_null.h" 1 3
# 109 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 123 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_max_align_t.h" 1 3
# 19 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 124 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stddef_offsetof.h" 1 3
# 129 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stddef.h" 2 3
# 30 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 2 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 1 3
# 56 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 1 3
# 20 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 146 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long int uintptr_t;
# 161 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int intptr_t;
# 177 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef signed char int8_t;




typedef short int16_t;




typedef int int32_t;




typedef long long int int64_t;




typedef long long int intmax_t;




typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long int uint64_t;
# 227 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int uintmax_t;
# 21 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 2 3

typedef int8_t int_fast8_t;
typedef int64_t int_fast64_t;

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;

typedef uint8_t uint_fast8_t;
typedef uint64_t uint_fast64_t;

typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
# 95 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/stdint.h" 1 3
typedef int32_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef uint32_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
# 96 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdint.h" 2 3
# 57 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdint.h" 2 3
# 31 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 2 3





                                                             ;
                                                              ;
                                                              ;
                                                               ;
                                                              ;
                                                               ;
                                                              ;
                                                               ;
                                                            ;







typedef long unsigned int __wasi_size_t;

                                                                  ;
                                                                     ;




typedef uint64_t __wasi_filesize_t;

                                                                      ;
                                                                         ;




typedef uint64_t __wasi_timestamp_t;

                                                                       ;
                                                                          ;




typedef uint32_t __wasi_clockid_t;
# 102 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;







typedef uint16_t __wasi_errno_t;
# 498 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                   ;
                                                                      ;




typedef uint64_t __wasi_rights_t;
# 663 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint32_t __wasi_fd_t;

                                                                ;
                                                                   ;




typedef struct __wasi_iovec_t {



    uint8_t * buf;




    __wasi_size_t buf_len;

} __wasi_iovec_t;

                                                                   ;
                                                                      ;
                                                                            ;
                                                                                ;




typedef struct __wasi_ciovec_t {



    const uint8_t * buf;




    __wasi_size_t buf_len;

} __wasi_ciovec_t;

                                                                    ;
                                                                       ;
                                                                             ;
                                                                                 ;




typedef int64_t __wasi_filedelta_t;

                                                                       ;
                                                                          ;




typedef uint8_t __wasi_whence_t;
# 744 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;






typedef uint64_t __wasi_dircookie_t;

                                                                       ;
                                                                          ;




typedef uint32_t __wasi_dirnamlen_t;

                                                                       ;
                                                                          ;




typedef uint64_t __wasi_inode_t;

                                                                   ;
                                                                      ;




typedef uint8_t __wasi_filetype_t;
# 818 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                      ;
                                                                         ;




typedef struct __wasi_dirent_t {



    __wasi_dircookie_t d_next;




    __wasi_inode_t d_ino;




    __wasi_dirnamlen_t d_namlen;




    __wasi_filetype_t d_type;

} __wasi_dirent_t;

                                                                     ;
                                                                       ;
                                                                                ;
                                                                               ;
                                                                                   ;
                                                                                 ;




typedef uint8_t __wasi_advice_t;
# 889 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint16_t __wasi_fdflags_t;
# 924 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef struct __wasi_fdstat_t {



    __wasi_filetype_t fs_filetype;




    __wasi_fdflags_t fs_flags;




    __wasi_rights_t fs_rights_base;





    __wasi_rights_t fs_rights_inheriting;

} __wasi_fdstat_t;

                                                                     ;
                                                                       ;
                                                                                     ;
                                                                                  ;
                                                                                        ;
                                                                                               ;





typedef uint64_t __wasi_device_t;

                                                                    ;
                                                                       ;




typedef uint16_t __wasi_fstflags_t;
# 995 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                      ;
                                                                         ;




typedef uint32_t __wasi_lookupflags_t;






                                                                         ;
                                                                            ;




typedef uint16_t __wasi_oflags_t;
# 1036 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint64_t __wasi_linkcount_t;

                                                                       ;
                                                                          ;




typedef struct __wasi_filestat_t {



    __wasi_device_t dev;




    __wasi_inode_t ino;




    __wasi_filetype_t filetype;




    __wasi_linkcount_t nlink;




    __wasi_filesize_t size;




    __wasi_timestamp_t atim;




    __wasi_timestamp_t mtim;




    __wasi_timestamp_t ctim;

} __wasi_filestat_t;

                                                                       ;
                                                                         ;
                                                                               ;
                                                                               ;
                                                                                     ;
                                                                                  ;
                                                                                 ;
                                                                                 ;
                                                                                 ;
                                                                                 ;





typedef uint64_t __wasi_userdata_t;

                                                                      ;
                                                                         ;




typedef uint8_t __wasi_eventtype_t;
# 1136 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                       ;
                                                                          ;





typedef uint16_t __wasi_eventrwflags_t;






                                                                          ;
                                                                             ;





typedef struct __wasi_event_fd_readwrite_t {



    __wasi_filesize_t nbytes;




    __wasi_eventrwflags_t flags;

} __wasi_event_fd_readwrite_t;

                                                                                 ;
                                                                                   ;
                                                                                            ;
                                                                                           ;




typedef union __wasi_event_u_t {



    __wasi_event_fd_readwrite_t fd_readwrite;

} __wasi_event_u_t;

                                                                      ;
                                                                        ;




typedef struct __wasi_event_t {



    __wasi_userdata_t userdata;




    __wasi_errno_t error;




    __wasi_eventtype_t type;




    __wasi_event_u_t u;

} __wasi_event_t;

                                                                    ;
                                                                      ;
                                                                                 ;
                                                                              ;
                                                                              ;
                                                                           ;





typedef uint16_t __wasi_subclockflags_t;
# 1237 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                           ;
                                                                              ;




typedef struct __wasi_subscription_clock_t {



    __wasi_clockid_t id;




    __wasi_timestamp_t timeout;





    __wasi_timestamp_t precision;




    __wasi_subclockflags_t flags;

} __wasi_subscription_clock_t;

                                                                                 ;
                                                                                   ;
                                                                                        ;
                                                                                             ;
                                                                                                ;
                                                                                            ;





typedef struct __wasi_subscription_fd_readwrite_t {



    __wasi_fd_t file_descriptor;

} __wasi_subscription_fd_readwrite_t;

                                                                                       ;
                                                                                          ;
                                                                                                            ;




typedef union __wasi_subscription_u_t {



    __wasi_subscription_clock_t clock;




    __wasi_subscription_fd_readwrite_t fd_readwrite;

} __wasi_subscription_u_t;

                                                                             ;
                                                                               ;




typedef struct __wasi_subscription_t {




    __wasi_userdata_t userdata;




    __wasi_eventtype_t type;




    __wasi_subscription_u_t u;

} __wasi_subscription_t;

                                                                           ;
                                                                             ;
                                                                                        ;
                                                                                    ;
                                                                                  ;




typedef uint32_t __wasi_exitcode_t;

                                                                      ;
                                                                         ;




typedef uint8_t __wasi_signal_t;
# 1536 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                    ;
                                                                       ;




typedef uint16_t __wasi_riflags_t;
# 1554 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef uint16_t __wasi_roflags_t;






                                                                     ;
                                                                        ;





typedef uint16_t __wasi_siflags_t;

                                                                     ;
                                                                        ;




typedef uint8_t __wasi_sdflags_t;
# 1594 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
                                                                     ;
                                                                        ;




typedef uint8_t __wasi_preopentype_t;






                                                                         ;
                                                                            ;




typedef struct __wasi_prestat_dir_t {



    __wasi_size_t pr_name_len;

} __wasi_prestat_dir_t;

                                                                         ;
                                                                            ;
                                                                                          ;




typedef union __wasi_prestat_u_t {



    __wasi_prestat_dir_t dir;

} __wasi_prestat_u_t;

                                                                       ;
                                                                          ;




typedef struct __wasi_prestat_t {



    __wasi_preopentype_t pr_type;




    __wasi_prestat_u_t u;

} __wasi_prestat_t;

                                                                     ;
                                                                        ;
                                                                                  ;
                                                                            ;
# 1669 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_args_get(
    uint8_t * * argv,

    uint8_t * argv_buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("args_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_args_sizes_get(



    __wasi_size_t *argc,



    __wasi_size_t *argv_buf_size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("args_sizes_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_environ_get(
    uint8_t * * environ,

    uint8_t * environ_buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("environ_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_environ_sizes_get(



    __wasi_size_t *argc,



    __wasi_size_t *argv_buf_size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("environ_sizes_get"),
    __warn_unused_result__
));







__wasi_errno_t __wasi_clock_res_get(



    __wasi_clockid_t id,




    __wasi_timestamp_t *resolution
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("clock_res_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_clock_time_get(



    __wasi_clockid_t id,




    __wasi_timestamp_t precision,




    __wasi_timestamp_t *time
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("clock_time_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_advise(
    __wasi_fd_t fd,




    __wasi_filesize_t offset,




    __wasi_filesize_t len,




    __wasi_advice_t advice
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_advise"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_allocate(
    __wasi_fd_t fd,




    __wasi_filesize_t offset,




    __wasi_filesize_t len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_allocate"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_close(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_close"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_datasync(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_datasync"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_get(
    __wasi_fd_t fd,




    __wasi_fdstat_t *stat
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_set_flags(
    __wasi_fd_t fd,




    __wasi_fdflags_t flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_set_flags"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_fdstat_set_rights(
    __wasi_fd_t fd,




    __wasi_rights_t fs_rights_base,

    __wasi_rights_t fs_rights_inheriting
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_fdstat_set_rights"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_filestat_get(
    __wasi_fd_t fd,




    __wasi_filestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_filestat_set_size(
    __wasi_fd_t fd,




    __wasi_filesize_t size
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_set_size"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_filestat_set_times(
    __wasi_fd_t fd,




    __wasi_timestamp_t atim,




    __wasi_timestamp_t mtim,




    __wasi_fstflags_t fst_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_filestat_set_times"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_pread(
    __wasi_fd_t fd,




    const __wasi_iovec_t *iovs,




    size_t iovs_len,




    __wasi_filesize_t offset,




    __wasi_size_t *nread
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_pread"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_prestat_get(
    __wasi_fd_t fd,




    __wasi_prestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_prestat_get"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_fd_prestat_dir_name(
    __wasi_fd_t fd,




    uint8_t * path,

    __wasi_size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_prestat_dir_name"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_pwrite(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *iovs,




    size_t iovs_len,




    __wasi_filesize_t offset,




    __wasi_size_t *nwritten
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_pwrite"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_read(
    __wasi_fd_t fd,




    const __wasi_iovec_t *iovs,




    size_t iovs_len,




    __wasi_size_t *nread
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_read"),
    __warn_unused_result__
));
# 2098 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_fd_readdir(
    __wasi_fd_t fd,




    uint8_t * buf,

    __wasi_size_t buf_len,




    __wasi_dircookie_t cookie,




    __wasi_size_t *bufused
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_readdir"),
    __warn_unused_result__
));
# 2133 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_fd_renumber(
    __wasi_fd_t fd,




    __wasi_fd_t to
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_renumber"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_seek(
    __wasi_fd_t fd,




    __wasi_filedelta_t offset,




    __wasi_whence_t whence,




    __wasi_filesize_t *newoffset
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_seek"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_sync(
    __wasi_fd_t fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_sync"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_tell(
    __wasi_fd_t fd,




    __wasi_filesize_t *offset
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_tell"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_fd_write(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *iovs,




    size_t iovs_len,




    __wasi_size_t *nwritten
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("fd_write"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_create_directory(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_create_directory"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_filestat_get(
    __wasi_fd_t fd,




    __wasi_lookupflags_t flags,




    const char *path,




    size_t path_len,




    __wasi_filestat_t *buf
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_filestat_get"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_filestat_set_times(
    __wasi_fd_t fd,




    __wasi_lookupflags_t flags,




    const char *path,




    size_t path_len,




    __wasi_timestamp_t atim,




    __wasi_timestamp_t mtim,




    __wasi_fstflags_t fst_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_filestat_set_times"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_link(
    __wasi_fd_t old_fd,




    __wasi_lookupflags_t old_flags,




    const char *old_path,




    size_t old_path_len,




    __wasi_fd_t new_fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_link"),
    __warn_unused_result__
));
# 2376 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_path_open(
    __wasi_fd_t fd,




    __wasi_lookupflags_t dirflags,





    const char *path,




    size_t path_len,




    __wasi_oflags_t oflags,
# 2409 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
    __wasi_rights_t fs_rights_base,

    __wasi_rights_t fs_rights_inherting,

    __wasi_fdflags_t fdflags,




    __wasi_fd_t *opened_fd
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_open"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_readlink(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len,




    uint8_t * buf,

    __wasi_size_t buf_len,




    __wasi_size_t *bufused
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_readlink"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_path_remove_directory(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_remove_directory"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_rename(
    __wasi_fd_t fd,




    const char *old_path,




    size_t old_path_len,




    __wasi_fd_t new_fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_rename"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_path_symlink(



    const char *old_path,




    size_t old_path_len,

    __wasi_fd_t fd,




    const char *new_path,




    size_t new_path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_symlink"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_path_unlink_file(
    __wasi_fd_t fd,




    const char *path,




    size_t path_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("path_unlink_file"),
    __warn_unused_result__
));




__wasi_errno_t __wasi_poll_oneoff(



    const __wasi_subscription_t * in,




    __wasi_event_t * out,




    __wasi_size_t nsubscriptions,




    __wasi_size_t *nevents
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("poll_oneoff"),
    __warn_unused_result__
));






_Noreturn void __wasi_proc_exit(



    __wasi_exitcode_t rval
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("proc_exit")));





__wasi_errno_t __wasi_proc_raise(



    __wasi_signal_t sig
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("proc_raise"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_sched_yield(
    void
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sched_yield"),
    __warn_unused_result__
));
# 2652 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/wasi/api.h" 3
__wasi_errno_t __wasi_random_get(



    uint8_t * buf,

    __wasi_size_t buf_len
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("random_get"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_sock_recv(
    __wasi_fd_t fd,




    const __wasi_iovec_t *ri_data,




    size_t ri_data_len,




    __wasi_riflags_t ri_flags,




    __wasi_size_t *ro_datalen,



    __wasi_roflags_t *ro_flags
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_recv"),
    __warn_unused_result__
));






__wasi_errno_t __wasi_sock_send(
    __wasi_fd_t fd,




    const __wasi_ciovec_t *si_data,




    size_t si_data_len,




    __wasi_siflags_t si_flags,




    __wasi_size_t *so_datalen
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_send"),
    __warn_unused_result__
));





__wasi_errno_t __wasi_sock_shutdown(
    __wasi_fd_t fd,




    __wasi_sdflags_t how
) __attribute__((
    __import_module__("wasi_snapshot_preview1"),
    __import_name__("sock_shutdown"),
    __warn_unused_result__
));
# 2 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/errno.h" 2 3
# 11 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/errno.h" 2 3


__attribute__((const))

int *__errno_location(void);



extern char *program_invocation_short_name, *program_invocation_name;
# 23 "gpg.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 1 3
# 30 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef __builtin_va_list va_list;




typedef __builtin_va_list __isoc_va_list;
# 141 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long int size_t;
# 156 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int ssize_t;
# 243 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long long int off_t;
# 400 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct _IO_FILE FILE;
# 31 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 2 3
# 66 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h" 3
typedef union _G_fpos64_t {
 char __opaque[16];
 long long __lldata;
 double __align;
} fpos_t;

extern FILE *const stdin;
extern FILE *const stdout;
extern FILE *const stderr;





FILE *fopen(const char *restrict, const char *restrict);
FILE *freopen(const char *restrict, const char *restrict, FILE *restrict);
int fclose(FILE *);

int remove(const char *);
int rename(const char *, const char *);

int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
void clearerr(FILE *);

int fseek(FILE *, long, int);
long ftell(FILE *);
void rewind(FILE *);

int fgetpos(FILE *restrict, fpos_t *restrict);
int fsetpos(FILE *, const fpos_t *);

size_t fread(void *restrict, size_t, size_t, FILE *restrict);
size_t fwrite(const void *restrict, size_t, size_t, FILE *restrict);

int fgetc(FILE *);
int getc(FILE *);
int getchar(void);
int ungetc(int, FILE *);

int fputc(int, FILE *);
int putc(int, FILE *);
int putchar(int);

char *fgets(char *restrict, int, FILE *restrict);




int fputs(const char *restrict, FILE *restrict);
int puts(const char *);

int printf(const char *restrict, ...);
int fprintf(FILE *restrict, const char *restrict, ...);
int sprintf(char *restrict, const char *restrict, ...);
int snprintf(char *restrict, size_t, const char *restrict, ...);

int vprintf(const char *restrict, __isoc_va_list);
int vfprintf(FILE *restrict, const char *restrict, __isoc_va_list);
int vsprintf(char *restrict, const char *restrict, __isoc_va_list);
int vsnprintf(char *restrict, size_t, const char *restrict, __isoc_va_list);

int scanf(const char *restrict, ...);
int fscanf(FILE *restrict, const char *restrict, ...);
int sscanf(const char *restrict, const char *restrict, ...);
int vscanf(const char *restrict, __isoc_va_list);
int vfscanf(FILE *restrict, const char *restrict, __isoc_va_list);
int vsscanf(const char *restrict, const char *restrict, __isoc_va_list);

void perror(const char *);

int setvbuf(FILE *restrict, char *restrict, int, size_t);
void setbuf(FILE *restrict, char *restrict);

char *tmpnam(char *);
FILE *tmpfile(void);




FILE *fmemopen(void *restrict, size_t, const char *restrict);
FILE *open_memstream(char **, size_t *);
FILE *fdopen(int, const char *);
FILE *popen(const char *, const char *);
int pclose(FILE *);
int fileno(FILE *);
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
int dprintf(int, const char *restrict, ...);
int vdprintf(int, const char *restrict, __isoc_va_list);
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);
ssize_t getdelim(char **restrict, size_t *restrict, int, FILE *restrict);
ssize_t getline(char **restrict, size_t *restrict, FILE *restrict);
int renameat(int, const char *, int, const char *);
char *ctermid(char *);







char *tempnam(const char *, const char *);




char *cuserid(char *);
void setlinebuf(FILE *);
void setbuffer(FILE *, char *, size_t);
int fgetc_unlocked(FILE *);
int fputc_unlocked(int, FILE *);
int fflush_unlocked(FILE *);
size_t fread_unlocked(void *, size_t, size_t, FILE *);
size_t fwrite_unlocked(const void *, size_t, size_t, FILE *);
void clearerr_unlocked(FILE *);
int feof_unlocked(FILE *);
int ferror_unlocked(FILE *);
int fileno_unlocked(FILE *);
int getw(FILE *);
int putw(int, FILE *);
char *fgetln(FILE *, size_t *);
int asprintf(char **, const char *, ...);
int vasprintf(char **, const char *, __isoc_va_list);



char *fgets_unlocked(char *, int, FILE *);
int fputs_unlocked(const char *, FILE *);

typedef ssize_t (cookie_read_function_t)(void *, char *, size_t);
typedef ssize_t (cookie_write_function_t)(void *, const char *, size_t);
typedef int (cookie_seek_function_t)(void *, off_t *, int);
typedef int (cookie_close_function_t)(void *);

typedef struct _IO_cookie_io_functions_t {
 cookie_read_function_t *read;
 cookie_write_function_t *write;
 cookie_seek_function_t *seek;
 cookie_close_function_t *close;
} cookie_io_functions_t;

FILE *fopencookie(void *, const char *, cookie_io_functions_t);
# 24 "gpg.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h" 1 3







int getloadavg(double loadavg[], int nelem);





# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 1 3
# 21 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 40 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int wchar_t;
# 22 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 2 3

int atoi (const char *);
long atol (const char *);
long long atoll (const char *);
double atof (const char *);

float strtof (const char *restrict, char **restrict);
double strtod (const char *restrict, char **restrict);
long double strtold (const char *restrict, char **restrict);

long strtol (const char *restrict, char **restrict, int);
unsigned long strtoul (const char *restrict, char **restrict, int);
long long strtoll (const char *restrict, char **restrict, int);
unsigned long long strtoull (const char *restrict, char **restrict, int);

int rand (void);
void srand (unsigned);

void *malloc (size_t);
void *calloc (size_t, size_t);
void *realloc (void *, size_t);
void free (void *);
void *aligned_alloc(size_t, size_t);

_Noreturn void abort (void);
int atexit (void (*) (void));
_Noreturn void exit (int);
_Noreturn void _Exit (int);
int at_quick_exit (void (*) (void));
_Noreturn void quick_exit (int);

char *getenv (const char *);

int system (const char *);

void *bsearch (const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
void qsort (void *, size_t, size_t, int (*)(const void *, const void *));

int abs (int);
long labs (long);
long long llabs (long long);

typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;
typedef struct { long long quot, rem; } lldiv_t;

div_t div (int, int);
ldiv_t ldiv (long, long);
lldiv_t lldiv (long long, long long);

int mblen (const char *, size_t);
int mbtowc (wchar_t *restrict, const char *restrict, size_t);
int wctomb (char *, wchar_t);
size_t mbstowcs (wchar_t *restrict, const char *restrict, size_t);
size_t wcstombs (char *restrict, const wchar_t *restrict, size_t);




size_t __ctype_get_mb_cur_max(void);
# 101 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 3
int posix_memalign (void **, size_t, size_t);
int setenv (const char *, const char *, int);
int unsetenv (const char *);
int mkstemp (char *);
int mkostemp (char *, int);
char *mkdtemp (char *);
int getsubopt (char **, char *const *, char **);
int rand_r (unsigned *);






char *realpath (const char *restrict, char *restrict);
long int random (void);
void srandom (unsigned int);
char *initstate (unsigned int, char *, size_t);
char *setstate (char *);
int putenv (char *);
int posix_openpt (int);
int grantpt (int);
int unlockpt (int);
char *ptsname (int);
char *l64a (long);
long a64l (const char *);
void setkey (const char *);
double drand48 (void);
double erand48 (unsigned short [3]);
long int lrand48 (void);
long int nrand48 (unsigned short [3]);
long mrand48 (void);
long jrand48 (unsigned short [3]);
void srand48 (long);
unsigned short *seed48 (unsigned short [3]);
void lcong48 (unsigned short [7]);



# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h" 1 3








# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h" 2 3

void *alloca(size_t);
# 141 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h" 2 3
char *mktemp (char *);
int mkstemps (char *, int);
int mkostemps (char *, int, int);
void *valloc (size_t);
void *memalign(size_t, size_t);
int getloadavg(double *, int);
int clearenv(void);


void *reallocarray (void *, size_t, size_t);
void qsort_r (void *, size_t, size_t, int (*)(const void *, const void *, void *), void *);



int ptsname_r(int, char *, size_t);
char *ecvt(double, int, int *, int *);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
char *secure_getenv(const char *);
struct __locale_struct;
float strtof_l(const char *restrict, char **restrict, struct __locale_struct *);
double strtod_l(const char *restrict, char **restrict, struct __locale_struct *);
long double strtold_l(const char *restrict, char **restrict, struct __locale_struct *);
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h" 2 3
# 25 "gpg.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/string.h" 1 3







extern char* strlwr(char *);
extern char* strupr(char *);





# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 1 3
# 25 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 412 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __locale_struct * locale_t;
# 26 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 2 3

void *memcpy (void *restrict, const void *restrict, size_t);
void *memmove (void *, const void *, size_t);
void *memset (void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void *memchr (const void *, int, size_t);

char *strcpy (char *restrict, const char *restrict);
char *strncpy (char *restrict, const char *restrict, size_t);

char *strcat (char *restrict, const char *restrict);
char *strncat (char *restrict, const char *restrict, size_t);

int strcmp (const char *, const char *);
int strncmp (const char *, const char *, size_t);

int strcoll (const char *, const char *);
size_t strxfrm (char *restrict, const char *restrict, size_t);

char *strchr (const char *, int);
char *strrchr (const char *, int);

size_t strcspn (const char *, const char *);
size_t strspn (const char *, const char *);
char *strpbrk (const char *, const char *);
char *strstr (const char *, const char *);
char *strtok (char *restrict, const char *restrict);

size_t strlen (const char *);

char *strerror (int);


# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/strings.h" 2 3




int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
char *index (const char *, int);
char *rindex (const char *, int);



int ffs (int);
int ffsl (long);
int ffsll (long long);


int strcasecmp (const char *, const char *);
int strncasecmp (const char *, const char *, size_t);

int strcasecmp_l (const char *, const char *, locale_t);
int strncasecmp_l (const char *, const char *, size_t, locale_t);
# 60 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/string.h" 2 3





char *strtok_r (char *restrict, const char *restrict, char **restrict);
int strerror_r (int, char *, size_t);
char *stpcpy(char *restrict, const char *restrict);
char *stpncpy(char *restrict, const char *restrict, size_t);
size_t strnlen (const char *, size_t);
char *strdup (const char *);
char *strndup (const char *, size_t);
char *strsignal(int);
char *strerror_l (int, locale_t);
int strcoll_l (const char *, const char *, locale_t);
size_t strxfrm_l (char *restrict, const char *restrict, size_t, locale_t);
void *memmem(const void *, size_t, const void *, size_t);




void *memccpy (void *restrict, const void *restrict, int, size_t);



char *strsep(char **, const char *);
size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
void explicit_bzero (void *, size_t);




int strverscmp (const char *, const char *);
char *strchrnul(const char *, int);
char *strcasestr(const char *, const char *);
void *memrchr(const void *, int, size_t);
void *mempcpy(void *, const void *, size_t);
# 16 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/string.h" 2 3
# 26 "gpg.c" 2



# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/ctype.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/ctype.h" 3
int isalnum(int);
int isalpha(int);
int isblank(int);
int iscntrl(int);
int isdigit(int);
int isgraph(int);
int islower(int);
int isprint(int);
int ispunct(int);
int isspace(int);
int isupper(int);
int isxdigit(int);
int tolower(int);
int toupper(int);


static inline int __isspace(int _c)
{
 return _c == ' ' || (unsigned)_c-'\t' < 5;
}
# 46 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/ctype.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 47 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/ctype.h" 2 3

int isalnum_l(int, locale_t);
int isalpha_l(int, locale_t);
int isblank_l(int, locale_t);
int iscntrl_l(int, locale_t);
int isdigit_l(int, locale_t);
int isgraph_l(int, locale_t);
int islower_l(int, locale_t);
int isprint_l(int, locale_t);
int ispunct_l(int, locale_t);
int isspace_l(int, locale_t);
int isupper_l(int, locale_t);
int isxdigit_l(int, locale_t);
int tolower_l(int, locale_t);
int toupper_l(int, locale_t);

int isascii(int);
int toascii(int);
# 30 "gpg.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/unistd.h" 1 3
# 47 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/unistd.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 320 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int pid_t;
# 330 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned uid_t;




typedef unsigned gid_t;
# 345 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned useconds_t;
# 48 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/unistd.h" 2 3

int pipe(int [2]);
int pipe2(int [2], int);
int close(int);
int posix_close(int, int);
int dup(int);
int dup2(int, int);
int dup3(int, int, int);
off_t lseek(int, off_t, int);
int fsync(int);
int fdatasync(int);

ssize_t read(int, void *, size_t);
ssize_t write(int, const void *, size_t);
ssize_t pread(int, void *, size_t, off_t);
ssize_t pwrite(int, const void *, size_t, off_t);

int chown(const char *, uid_t, gid_t);
int fchown(int, uid_t, gid_t);
int lchown(const char *, uid_t, gid_t);
int fchownat(int, const char *, uid_t, gid_t, int);

int link(const char *, const char *);
int linkat(int, const char *, int, const char *, int);
int symlink(const char *, const char *);
int symlinkat(const char *, int, const char *);
ssize_t readlink(const char *restrict, char *restrict, size_t);
ssize_t readlinkat(int, const char *restrict, char *restrict, size_t);
int unlink(const char *);
int unlinkat(int, const char *, int);
int rmdir(const char *);
int truncate(const char *, off_t);
int ftruncate(int, off_t);






int access(const char *, int);
int faccessat(int, const char *, int, int);

int chdir(const char *);
int fchdir(int);
char *getcwd(char *, size_t);

unsigned alarm(unsigned);
unsigned sleep(unsigned);
int pause(void);

pid_t fork(void);
pid_t _Fork(void);
int execve(const char *, char *const [], char *const []);
int execv(const char *, char *const []);
int execle(const char *, const char *, ...);
int execl(const char *, const char *, ...);
int execvp(const char *, char *const []);
int execlp(const char *, const char *, ...);
int fexecve(int, char *const [], char *const []);
_Noreturn void _exit(int);

pid_t getpid(void);
pid_t getppid(void);
pid_t getpgrp(void);
pid_t getpgid(pid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
pid_t getsid(pid_t);
char *ttyname(int);
int ttyname_r(int, char *, size_t);
int isatty(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);

uid_t getuid(void);
uid_t geteuid(void);
gid_t getgid(void);
gid_t getegid(void);
int getgroups(int, gid_t []);
int setuid(uid_t);
int seteuid(uid_t);
int setgid(gid_t);
int setegid(gid_t);

char *getlogin(void);
int getlogin_r(char *, size_t);
int gethostname(char *, size_t);
char *ctermid(char *);

int getopt(int, char * const [], const char *);
extern char *optarg;
extern int optind, opterr, optopt;

long pathconf(const char *, int);
long fpathconf(int, int);
long sysconf(int);
size_t confstr(int, char *, size_t);






int setreuid(uid_t, uid_t);
int setregid(gid_t, gid_t);
int lockf(int, int, off_t);
long gethostid(void);
int nice(int);
void sync(void);
pid_t setpgrp(void);
char *crypt(const char *, const char *);
void encrypt(char *, int);
void swab(const void *restrict, void *restrict, ssize_t);




int usleep(unsigned);
unsigned ualarm(unsigned, unsigned);






int brk(void *);
void *sbrk(intptr_t);
pid_t vfork(void);
int vhangup(void);
int chroot(const char *);
int getpagesize(void);
int getdtablesize(void);
int sethostname(const char *, size_t);
int getdomainname(char *, size_t);
int setdomainname(const char *, size_t);
int setgroups(size_t, const gid_t *);
char *getpass(const char *);
int daemon(int, int);
void setusershell(void);
void endusershell(void);
char *getusershell(void);
int acct(const char *);

int execvpe(const char *, char *const [], char *const []);
int issetugid(void);
int getentropy(void *, size_t);
extern int optreset;



extern char **environ;
int setresuid(uid_t, uid_t, uid_t);
int setresgid(gid_t, gid_t, gid_t);
int getresuid(uid_t *, uid_t *, uid_t *);
int getresgid(gid_t *, gid_t *, gid_t *);
char *get_current_dir_name(void);
int syncfs(int);
int euidaccess(const char *, int);
int eaccess(const char *, int);
ssize_t copy_file_range(int, off_t *, int, off_t *, size_t, unsigned);
pid_t gettid(void);
# 292 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/unistd.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/posix.h" 1 3
# 293 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/unistd.h" 2 3
# 31 "gpg.c" 2
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/assert.h" 1 3
# 19 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/assert.h" 3
_Noreturn void __assert_fail (const char *, const char *, int, const char *);
# 32 "gpg.c" 2




# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/sys/stat.h" 1 3







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/stat.h" 1 3
# 28 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/stat.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 83 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long long int time_t;
# 233 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned mode_t;




typedef unsigned long int nlink_t;
# 248 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int ino_t;




typedef unsigned int dev_t;




typedef int blksize_t;




typedef int blkcnt_t;
# 314 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
struct timespec { time_t tv_sec; long tv_nsec; };
# 29 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/stat.h" 2 3

# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/stat.h" 1 3



struct stat
{
 dev_t st_dev;




 mode_t st_mode;
 nlink_t st_nlink;
 uid_t st_uid;
 gid_t st_gid;
 dev_t st_rdev;



 off_t st_size;
 blksize_t st_blksize;
 blkcnt_t st_blocks;
 struct timespec st_atim;
 struct timespec st_mtim;
 struct timespec st_ctim;
 ino_t st_ino;
};
# 31 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/stat.h" 2 3
# 80 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/stat.h" 3
int stat(const char *restrict, struct stat *restrict);
int fstat(int, struct stat *);
int lstat(const char *restrict, struct stat *restrict);
int fstatat(int, const char *restrict, struct stat *restrict, int);
int chmod(const char *, mode_t);
int fchmod(int, mode_t);
int fchmodat(int, const char *, mode_t, int);
mode_t umask(mode_t);
int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);
int mkdirat(int, const char *, mode_t);
int mkfifoat(int, const char *, mode_t);


int mknod(const char *, mode_t, dev_t);
int mknodat(int, const char *, mode_t, dev_t);


int futimens(int, const struct timespec [2]);
int utimensat(int, const char *, const struct timespec [2], int);


int lchmod(const char *, mode_t);
# 124 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/stat.h" 3
struct statx_timestamp {
 int64_t tv_sec;
 uint32_t tv_nsec, __pad;
};

struct statx {
 uint32_t stx_mask;
 uint32_t stx_blksize;
 uint64_t stx_attributes;
 uint32_t stx_nlink;
 uint32_t stx_uid;
 uint32_t stx_gid;
 uint16_t stx_mode;
 uint16_t __pad0[1];
 uint64_t stx_ino;
 uint64_t stx_size;
 uint64_t stx_blocks;
 uint64_t stx_attributes_mask;
 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;
 uint32_t stx_rdev_major;
 uint32_t stx_rdev_minor;
 uint32_t stx_dev_major;
 uint32_t stx_dev_minor;
 uint64_t __pad1[14];
};

int statx(int, const char *restrict, int, unsigned, struct statx *restrict);
# 9 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/sys/stat.h" 2 3
# 37 "gpg.c" 2

# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/fcntl.h" 1 3
# 24 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/fcntl.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 424 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
struct iovec { void *iov_base; size_t iov_len; };
# 25 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/fcntl.h" 2 3

# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/fcntl.h" 1 3
# 27 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/fcntl.h" 2 3

struct flock {
 short l_type;
 short l_whence;
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
};

int creat(const char *, mode_t);
int fcntl(int, int, ...);
int open(const char *, int, ...);
int openat(int, const char *, int, ...);
int posix_fadvise(int, off_t, off_t, int);
int posix_fallocate(int, off_t, off_t);
# 169 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/fcntl.h" 3
int lockf(int, int, off_t);







struct file_handle {
 unsigned handle_bytes;
 int handle_type;
 unsigned char f_handle[];
};
struct f_owner_ex {
 int type;
 pid_t pid;
};
# 196 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/fcntl.h" 3
int fallocate(int, int, off_t, off_t);
int name_to_handle_at(int, const char *, struct file_handle *, int *, int);
int open_by_handle_at(int, struct file_handle *, int);
ssize_t readahead(int, off_t, size_t);
int sync_file_range(int, off_t, off_t, unsigned);
ssize_t vmsplice(int, const struct iovec *, size_t, unsigned);
ssize_t splice(int, off_t *, int, off_t *, size_t, unsigned);
ssize_t tee(int, int, size_t, unsigned);
# 39 "gpg.c" 2








# 1 "./packet.h" 1
# 24 "./packet.h"
# 1 "../include/types.h" 1
# 24 "../include/types.h"
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 1 3
# 24 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 13 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/inttypes.h" 2 3

typedef struct { intmax_t quot, rem; } imaxdiv_t;

intmax_t imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);

intmax_t strtoimax(const char *restrict, char **restrict, int);
uintmax_t strtoumax(const char *restrict, char **restrict, int);

intmax_t wcstoimax(const wchar_t *restrict, wchar_t **restrict, int);
uintmax_t wcstoumax(const wchar_t *restrict, wchar_t **restrict, int);
# 25 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/inttypes.h" 2 3
# 25 "../include/types.h" 2
# 43 "../include/types.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 1 3
# 57 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 88 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int suseconds_t;





typedef struct {
    union {
        int __i[10];
        volatile int __vi[10];
        unsigned long __s[10];
    } __u;



    const char *_a_transferredcanvases;

} pthread_attr_t;




typedef struct { union { int __i[6]; volatile int __vi[6]; volatile void *__p[6]; } __u; } pthread_mutex_t;
# 120 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct { union { int __i[12]; volatile int __vi[12]; void *__p[12]; } __u; } pthread_cond_t;
# 130 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct { union { int __i[sizeof(long)==8?14:8]; volatile int __vi[sizeof(long)==8?14:8]; void *__p[sizeof(long)==8?7:8]; } __u; } pthread_rwlock_t;




typedef struct { union { int __i[5]; volatile int __vi[5]; void *__p[5]; } __u; } pthread_barrier_t;
# 171 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef long int register_t;
# 222 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned long long int u_int64_t;
# 268 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned int fsblkcnt_t;




typedef unsigned int fsfilcnt_t;
# 289 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef void * timer_t;




typedef int clockid_t;




typedef int clock_t;
# 325 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef unsigned id_t;
# 340 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef int key_t;
# 358 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __pthread * pthread_t;





typedef int pthread_once_t;




typedef unsigned pthread_key_t;




typedef int pthread_spinlock_t;




typedef struct { unsigned __attr; } pthread_mutexattr_t;




typedef struct { unsigned __attr; } pthread_condattr_t;




typedef struct { unsigned __attr; } pthread_barrierattr_t;




typedef struct { unsigned __attr[2]; } pthread_rwlockattr_t;
# 58 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3


typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned u_int32_t;
typedef char *caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short, ushort;
typedef unsigned u_int, uint;
typedef unsigned long u_long, ulong;
typedef long long quad_t;
typedef unsigned long long u_quad_t;
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 1 3
# 10 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 11 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/endian.h" 2 3








static inline uint16_t __bswap16(uint16_t __x)
{
 return __x<<8 | __x>>8;
}

static inline uint32_t __bswap32(uint32_t __x)
{
 return __x>>24 | __x>>8&0xff00 | __x<<8&0xff0000 | __x<<24;
}

static inline uint64_t __bswap64(uint64_t __x)
{
 return __bswap32(__x)+0ULL<<32 | __bswap32(__x>>32);
}
# 71 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 1 3
# 16 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 309 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
struct timeval { time_t tv_sec; suseconds_t tv_usec; };
# 418 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 3
typedef struct __sigset_t { unsigned long __bits[128/sizeof(long)]; } sigset_t;
# 17 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/select.h" 2 3



typedef unsigned long fd_mask;

typedef struct {
 unsigned long fds_bits[1024 / 8 / sizeof(long)];
} fd_set;






int select (int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict);
int pselect (int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict);
# 72 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/sys/types.h" 2 3
# 44 "../include/types.h" 2





typedef unsigned char byte;
# 76 "../include/types.h"
typedef unsigned short u16;
# 86 "../include/types.h"
typedef unsigned int u32;
# 103 "../include/types.h"
typedef uint64_t u64;
# 126 "../include/types.h"
typedef union {
    int a;
    short b;
    char c[1];
    long d;

    u64 e;

    float f;
    double g;
} PROPERLY_ALIGNED_TYPE;

struct string_list {
    struct string_list *next;
    unsigned int flags;
    char d[1];
};
typedef struct string_list *STRLIST;
typedef struct string_list *strlist_t;
# 25 "./packet.h" 2
# 1 "../include/iobuf.h" 1
# 36 "../include/iobuf.h"
typedef struct iobuf_struct *IOBUF;
typedef struct iobuf_struct *iobuf_t;


struct iobuf_struct {
    int use;
    off_t nlimit;
    off_t nbytes;
    off_t ntotal;
    int nofast;
    void *directfp;
    struct {
 size_t size;
 size_t start;
 size_t len;
 byte *buf;
    } d;
    int filter_eof;
    int error;
    int (*filter)( void *opaque, int control,
     IOBUF chain, byte *buf, size_t *len);
    void *filter_ov;
    int filter_ov_owner;
    char *real_fname;
    IOBUF chain;
    int no, subno;
    void *opaque;

    struct {
 size_t size;
 size_t start;
 size_t len;
 byte *buf;
    } unget;
};
# 81 "../include/iobuf.h"
int iobuf_debug_mode;

void iobuf_enable_special_filenames ( int yes );
int iobuf_is_pipe_filename (const char *fname);
IOBUF iobuf_alloc(int use, size_t bufsize);
IOBUF iobuf_temp(void);
IOBUF iobuf_temp_with_content( const char *buffer, size_t length );
IOBUF iobuf_open( const char *fname );
IOBUF iobuf_fdopen( int fd, const char *mode );
IOBUF iobuf_sockopen( int fd, const char *mode );
IOBUF iobuf_create( const char *fname );
IOBUF iobuf_append( const char *fname );
IOBUF iobuf_openrw( const char *fname );
int iobuf_ioctl ( IOBUF a, int cmd, int intval, void *ptrval );
int iobuf_close( IOBUF iobuf );
int iobuf_cancel( IOBUF iobuf );

int iobuf_push_filter( IOBUF a, int (*f)(void *opaque, int control,
         IOBUF chain, byte *buf, size_t *len), void *ov );
int iobuf_push_filter2( IOBUF a,
      int (*f)(void *opaque, int control,
      IOBUF chain, byte *buf, size_t *len),
      void *ov, int rel_ov );
int iobuf_flush(IOBUF a);
void iobuf_clear_eof(IOBUF a);



void iobuf_set_limit( IOBUF a, off_t nlimit );

off_t iobuf_tell( IOBUF a );
int iobuf_seek( IOBUF a, off_t newpos );

int iobuf_readbyte(IOBUF a);
int iobuf_read(IOBUF a, byte *buf, unsigned buflen );
unsigned iobuf_read_line( IOBUF a, byte **addr_of_buffer,
     unsigned *length_of_buffer, unsigned *max_length );
int iobuf_peek(IOBUF a, byte *buf, unsigned buflen );
int iobuf_writebyte(IOBUF a, unsigned c);
int iobuf_write(IOBUF a, byte *buf, unsigned buflen );
int iobuf_writestr(IOBUF a, const char *buf );

void iobuf_flush_temp( IOBUF temp );
int iobuf_write_temp( IOBUF a, IOBUF temp );
size_t iobuf_temp_to_buffer( IOBUF a, byte *buffer, size_t buflen );
void iobuf_unget_and_close_temp( IOBUF a, IOBUF temp );

int iobuf_get_fd (IOBUF a);
off_t iobuf_get_filelength (IOBUF a, int *overflow);

const char *iobuf_get_real_fname( IOBUF a );
const char *iobuf_get_fname( IOBUF a );

void iobuf_set_partial_block_mode( IOBUF a, size_t len );

int iobuf_translate_file_handle ( int fd, int for_write );
# 160 "../include/iobuf.h"
void iobuf_skip_rest (IOBUF a, unsigned long n, int partial);
# 26 "./packet.h" 2
# 1 "../include/mpi.h" 1
# 32 "../include/mpi.h"
# 1 "../config.h" 1
# 33 "../include/mpi.h" 2



# 1 "../include/memory.h" 1
# 57 "../include/memory.h"
void *xmalloc( size_t n );
void *xtrymalloc (size_t n);
void *xmalloc_clear( size_t n );
void *xmalloc_secure( size_t n );
void *xmalloc_secure_clear( size_t n );
void *xrealloc( void *a, size_t n );
void xfree( void *p );
void m_check( const void *a );

char *xstrdup( const char * a);
char *xtrystrdup (const char *a);


size_t m_size( const void *a );
void m_print_stats(const char *prefix);


void *xcalloc (size_t n, size_t m);
void *xcalloc_secure (size_t n, size_t m);



int secmem_init( size_t npool );
void secmem_term( void );
void *secmem_malloc( size_t size );
void *secmexrealloc( void *a, size_t newsize );
void secmem_free( void *a );
int m_is_secure( const void *p );
void secmem_dump_stats(void);
void secmem_set_flags( unsigned flags );
unsigned secmem_get_flags(void);
# 102 "../include/memory.h"
int memory_debug_mode;
int memory_stat_debug_mode;
# 37 "../include/mpi.h" 2
# 49 "../include/mpi.h"
int mpi_debug_mode;


struct gcry_mpi;
typedef struct gcry_mpi *MPI;
# 72 "../include/mpi.h"
MPI mpi_alloc( unsigned nlimbs );
MPI mpi_alloc_secure( unsigned nlimbs );
MPI mpi_alloc_like( MPI a );
void mpi_free( MPI a );
void mpi_resize( MPI a, unsigned nlimbs );
MPI mpi_copy( MPI a );


MPI mpi_set_opaque( MPI a, void *p, unsigned int len );
void *mpi_get_opaque( MPI a, unsigned int *len );

void mpi_set_secure( MPI a );
void mpi_clear( MPI a );
void mpi_set( MPI w, MPI u);
void mpi_set_cond( MPI w, MPI u, unsigned long set);
void mpi_set_ui( MPI w, ulong u);
MPI mpi_alloc_set_ui( unsigned long u);
void mpi_m_check( MPI a );
void mpi_swap( MPI a, MPI b);
int mpi_get_nlimbs (MPI a);
int mpi_is_neg (MPI a);
unsigned int mpi_nlimb_hint_from_nbytes (unsigned int nbytes);
unsigned int mpi_nlimb_hint_from_nbits (unsigned int nbits);
unsigned int mpi_get_flags (MPI a);


int mpi_write( IOBUF out, MPI a );




MPI mpi_read(IOBUF inp, unsigned *nread, int secure);

MPI mpi_read_from_buffer(byte *buffer, unsigned *ret_nread, int secure);
int mpi_fromstr(MPI val, const char *str);
int mpi_print( FILE *fp, MPI a, int mode );
void g10_log_mpidump( const char *text, MPI a );
u32 mpi_get_keyid( MPI a, u32 *keyid );
byte *mpi_get_buffer( MPI a, unsigned *nbytes, int *sign );
byte *mpi_get_secure_buffer( MPI a, unsigned *nbytes, int *sign );
void mpi_set_buffer( MPI a, const byte *buffer, unsigned nbytes, int sign );




void mpi_add_ui(MPI w, MPI u, ulong v );
void mpi_add(MPI w, MPI u, MPI v);
void mpi_addm(MPI w, MPI u, MPI v, MPI m);
void mpi_sub_ui(MPI w, MPI u, ulong v );
void mpi_sub( MPI w, MPI u, MPI v);
void mpi_subm( MPI w, MPI u, MPI v, MPI m);


void mpi_mul_ui(MPI w, MPI u, ulong v );
void mpi_mul_2exp( MPI w, MPI u, ulong cnt);
void mpi_mul( MPI w, MPI u, MPI v);
void mpi_mulm( MPI w, MPI u, MPI v, MPI m);


ulong mpi_fdiv_r_ui( MPI rem, MPI dividend, ulong divisor );
void mpi_fdiv_r( MPI rem, MPI dividend, MPI divisor );
void mpi_fdiv_q( MPI quot, MPI dividend, MPI divisor );
void mpi_fdiv_qr( MPI quot, MPI rem, MPI dividend, MPI divisor );
void mpi_tdiv_r( MPI rem, MPI num, MPI den);
void mpi_tdiv_qr( MPI quot, MPI rem, MPI num, MPI den);
void mpi_tdiv_q_2exp( MPI w, MPI u, unsigned count );
int mpi_divisible_ui(MPI dividend, ulong divisor );


int mpi_gcd( MPI g, MPI a, MPI b );


void mpi_pow( MPI w, MPI u, MPI v);
void mpi_powm( MPI res, MPI base, MPI exponent, MPI mod);


void mpi_mulpowm( MPI res, MPI *basearray, MPI *exparray, MPI mod);


int mpi_cmp_ui( MPI u, ulong v );
int mpi_cmp( MPI u, MPI v );


int mpi_getbyte( MPI a, unsigned idx );
void mpi_putbyte( MPI a, unsigned idx, int value );
unsigned mpi_trailing_zeros( MPI a );


void mpi_normalize( MPI a );
unsigned mpi_get_nbits( MPI a );
int mpi_test_bit( MPI a, unsigned n );
void mpi_set_bit( MPI a, unsigned n );
void mpi_set_highbit( MPI a, unsigned n );
void mpi_clear_highbit( MPI a, unsigned n );
void mpi_clear_bit( MPI a, unsigned n );
void mpi_rshift( MPI x, MPI a, unsigned n );


void mpi_invm( MPI x, MPI u, MPI v );
# 27 "./packet.h" 2
# 1 "../include/cipher.h" 1
# 26 "../include/cipher.h"
# 1 "../include/../cipher/random.h" 1
# 25 "../include/../cipher/random.h"
void random_dump_stats(void);
void secure_randoxmalloc(void);
void set_random_seed_file(const char *);
void update_random_seed_file(void);
int quick_random_gen( int onoff );
int random_is_faked(void);
void random_disable_locking (void);
void randomize_buffer( byte *buffer, size_t length, int level );
void randomize_mpi (MPI mpi, size_t nbits, int level);
byte *get_random_bits( size_t nbits, int level, int secure );
void fast_random_poll( void );
# 27 "../include/cipher.h" 2
# 82 "../include/cipher.h"
typedef struct
{
  int algo;
  int keylen;
  int algo_info_printed;
  int use_mdc;
  int symmetric;
  byte key[32];
} DEK;

struct cipher_handle_s;
typedef struct cipher_handle_s *CIPHER_HANDLE;
# 103 "../include/cipher.h"
struct md_digest_list_s;

struct gcry_md_context {
    int secure;
    FILE *debug;
    int finalized;
    struct md_digest_list_s *list;
    int bufcount;
    int bufsize;
    byte buffer[1];
};

typedef struct gcry_md_context *MD_HANDLE;
# 126 "../include/cipher.h"
int g10c_debug_mode;
int g10_opt_verbose;
const char *g10_opt_homedir;



void register_cipher_extension( const char *mainpgm, const char *fname );


int string_to_digest_algo( const char *string );
const char * digest_algo_to_string( int algo );
int check_digest_algo( int algo );
MD_HANDLE md_open( int algo, int secure );
void md_enable( MD_HANDLE hd, int algo );
MD_HANDLE md_copy( MD_HANDLE a );
void md_reset( MD_HANDLE a );
void md_close(MD_HANDLE a);
void md_write( MD_HANDLE a, const byte *inbuf, size_t inlen);
void md_final(MD_HANDLE a);
byte *md_read( MD_HANDLE a, int algo );
int md_digest( MD_HANDLE a, int algo, byte *buffer, int buflen );
int md_get_algo( MD_HANDLE a );
int md_algo_present( MD_HANDLE a, int algo );
int md_digest_length( int algo );
const byte *md_asn_oid( int algo, size_t *asnlen, size_t *mdlen );
void md_start_debug( MD_HANDLE a, const char *suffix );
void md_stop_debug( MD_HANDLE a );
# 161 "../include/cipher.h"
void rmd160_hash_buffer (char *outbuf, const char *buffer, size_t length);
void sha1_hash_buffer (char *outbuf, const char *buffer, size_t length);



int string_to_cipher_algo( const char *string );
const char * cipher_algo_to_string( int algo );
void disable_cipher_algo( int algo );
int check_cipher_algo( int algo );
unsigned cipher_get_keylen( int algo );
unsigned cipher_get_blocksize( int algo );
CIPHER_HANDLE cipher_open( int algo, int mode, int secure );
void cipher_close( CIPHER_HANDLE c );
int cipher_setkey( CIPHER_HANDLE c, byte *key, unsigned keylen );
void cipher_setiv( CIPHER_HANDLE c, const byte *iv, unsigned ivlen );
void cipher_encrypt( CIPHER_HANDLE c, byte *out, byte *in, unsigned nbytes );
void cipher_decrypt( CIPHER_HANDLE c, byte *out, byte *in, unsigned nbytes );
void cipher_sync( CIPHER_HANDLE c );







int string_to_pubkey_algo( const char *string );
const char * pubkey_algo_to_string( int algo );
void disable_pubkey_algo( int algo );
int check_pubkey_algo( int algo );
int check_pubkey_algo2( int algo, unsigned use );
int pubkey_get_npkey( int algo );
int pubkey_get_nskey( int algo );
int pubkey_get_nsig( int algo );
int pubkey_get_nenc( int algo );
unsigned pubkey_nbits( int algo, MPI *pkey );
int pubkey_generate( int algo, unsigned nbits, MPI *skey, MPI **retfactors );
int dsa2_generate( int algo, unsigned nbits, unsigned qbits,
     MPI *skey, MPI **retfactors );
int pubkey_check_secret_key( int algo, MPI *skey );
int pubkey_encrypt( int algo, MPI *resarr, MPI data, MPI *pkey );
int pubkey_decrypt( int algo, MPI *result, MPI *data, MPI *skey );
int pubkey_sign( int algo, MPI *resarr, MPI hash, MPI *skey );
int pubkey_verify( int algo, MPI hash, MPI *data, MPI *pkey );


extern ushort small_prime_numbers[];


void register_primegen_progress ( void (*cb)( void *, int), void *cb_data );
MPI generate_secret_prime( unsigned nbits );
MPI generate_public_prime( unsigned nbits );
MPI generate_elg_prime( int mode, unsigned pbits, unsigned qbits,
        MPI g, MPI **factors );


void register_pk_dsa_progress ( void (*cb)( void *, int), void *cb_data );
void register_pk_elg_progress ( void (*cb)( void *, int), void *cb_data );
# 28 "./packet.h" 2
# 1 "./filter.h" 1
# 26 "./filter.h"
typedef struct {
    MD_HANDLE md;
    MD_HANDLE md2;
    size_t maxbuf_size;
} md_filter_context_t;

typedef struct {
    int refcount;



    int what;
    int only_keyblocks;
    const char *hdrlines;


    int no_openpgp_data;
    int key_failed_code;



    int inp_checked;
    int inp_bypass;
    int in_cleartext;
    int not_dash_escaped;
    int hashes;
    int faked;
    int truncated;
    int qp_detected;
    int pgp2mode;
    byte eol[3];




    byte *buffer;
    unsigned buffer_size;
    unsigned buffer_len;
    unsigned buffer_pos;

    byte radbuf[4];
    int idx, idx2;
    u32 crc;

    int status;
    int cancel;
    int any_data;
    int pending_lf;
} armor_filter_context_t;

struct unarmor_pump_s;
typedef struct unarmor_pump_s *UnarmorPump;


struct compress_filter_context_s {
    int status;
    void *opaque;
    byte *inbuf;
    unsigned inbufsize;
    byte *outbuf;
    unsigned outbufsize;
    int algo;
    int algo1hack;
    int new_ctb;
    void (*release)(struct compress_filter_context_s*);
};
typedef struct compress_filter_context_s compress_filter_context_t;


typedef struct {
    DEK *dek;
    u32 datalen;
    CIPHER_HANDLE cipher_hd;
    int header;
    MD_HANDLE mdc_hash;
    byte enchash[20];
    int create_mdc;
} cipher_filter_context_t;



typedef struct {
    byte *buffer;
    unsigned buffer_size;
    unsigned buffer_len;
    unsigned buffer_pos;
    int truncated;
    int not_dash_escaped;
    int escape_from;
    MD_HANDLE md;
    int pending_lf;
    int pending_esc;
} text_filter_context_t;


typedef struct {
    char *what;
    u32 last_time;
    unsigned long last;
    unsigned long offset;
    unsigned long total;
} progress_filter_context_t;




int md_filter( void *opaque, int control, IOBUF a, byte *buf, size_t *ret_len);
void free_md_filter_context( md_filter_context_t *mfx );


armor_filter_context_t *new_armor_context (void);
void release_armor_context (armor_filter_context_t *afx);
int push_armor_filter (armor_filter_context_t *afx, IOBUF iobuf);
int use_armor_filter( IOBUF a );
int armor_filter( void *opaque, int control,
    IOBUF chain, byte *buf, size_t *ret_len);
UnarmorPump unarmor_pump_new (void);
void unarmor_pump_release (UnarmorPump x);
int unarmor_pump (UnarmorPump x, int c);


void push_compress_filter(IOBUF out,compress_filter_context_t *zfx,int algo);
void push_compress_filter2(IOBUF out,compress_filter_context_t *zfx,
      int algo,int rel);


int cipher_filter( void *opaque, int control,
     IOBUF chain, byte *buf, size_t *ret_len);


int text_filter( void *opaque, int control,
   IOBUF chain, byte *buf, size_t *ret_len);
int copy_clearsig_text( IOBUF out, IOBUF inp, MD_HANDLE md,
     int escape_dash, int escape_from, int pgp2mode );


int progress_filter (void *opaque, int control,
       IOBUF a, byte *buf, size_t *ret_len);
void handle_progress (progress_filter_context_t *pfx,
        IOBUF inp, const char *name);
# 29 "./packet.h" 2
# 1 "./global.h" 1
# 25 "./global.h"
typedef struct kbnode_struct *KBNODE;
typedef struct kbnode_struct *kbnode_t;
typedef struct keydb_search_desc KEYDB_SEARCH_DESC;
# 30 "./packet.h" 2



typedef enum {
 PKT_NONE =0,
 PKT_PUBKEY_ENC =1,
 PKT_SIGNATURE =2,
 PKT_SYMKEY_ENC =3,
 PKT_ONEPASS_SIG =4,
 PKT_SECRET_KEY =5,
 PKT_PUBLIC_KEY =6,
 PKT_SECRET_SUBKEY =7,
 PKT_COMPRESSED =8,
 PKT_ENCRYPTED =9,
 PKT_MARKER =10,
 PKT_PLAINTEXT =11,
 PKT_RING_TRUST =12,
 PKT_USER_ID =13,
 PKT_PUBLIC_SUBKEY =14,
 PKT_OLD_COMMENT =16,
 PKT_ATTRIBUTE =17,
 PKT_ENCRYPTED_MDC =18,
 PKT_MDC =19,
 PKT_COMMENT =61,
        PKT_GPG_CONTROL =63
} pkttype_t;

typedef struct packet_struct PACKET;


typedef enum {
    CTRLPKT_CLEARSIGN_START = 1,
    CTRLPKT_PIPEMODE = 2,
    CTRLPKT_PLAINTEXT_MARK =3
} ctrlpkttype_t;

typedef enum {
    PREFTYPE_NONE = 0,
    PREFTYPE_SYM = 1,
    PREFTYPE_HASH = 2,
    PREFTYPE_ZIP = 3
} preftype_t;

typedef struct {
    byte type;
    byte value;
} prefitem_t;

typedef struct {
    int mode;
    byte hash_algo;
    byte salt[8];
    u32 count;
} STRING2KEY;

typedef struct {
    byte version;
    byte cipher_algo;
    STRING2KEY s2k;
    byte seskeylen;
    byte seskey[1];
} PKT_symkey_enc;

typedef struct {
    u32 keyid[2];
    byte version;
    byte pubkey_algo;
    byte throw_keyid;
    MPI data[2];
} PKT_pubkey_enc;


typedef struct {
    u32 keyid[2];
    byte sig_class;
    byte digest_algo;
    byte pubkey_algo;
    byte last;
} PKT_onepass_sig;


typedef struct {
    size_t size;
    size_t len;
    byte data[1];
} subpktarea_t;

struct revocation_key {
  byte class;
  byte algid;
  byte fpr[20];
};



typedef struct
{
  int valid;
  int checked;

  char *uri;

  unsigned char fpr[20];
  char email[1];
} pka_info_t;



typedef struct
{
  struct
  {
    unsigned checked:1;
    unsigned valid:1;
    unsigned chosen_selfsig:1;
    unsigned unknown_critical:1;
    unsigned exportable:1;
    unsigned revocable:1;
    unsigned policy_url:1;
    unsigned notation:1;
    unsigned pref_ks:1;
    unsigned expired:1;
    unsigned pka_tried:1;
  } flags;
  u32 keyid[2];
  u32 timestamp;
  u32 expiredate;
  byte version;
  byte sig_class;
  byte pubkey_algo;

  byte digest_algo;
  byte trust_depth;
  byte trust_value;
  const byte *trust_regexp;
  struct revocation_key **revkey;
  int numrevkeys;
  pka_info_t *pka_info;

  subpktarea_t *hashed;
  subpktarea_t *unhashed;
  byte digest_start[2];
  MPI data[2];
} PKT_signature;




struct user_attribute {
  byte type;
  const byte *data;
  u32 len;
};

typedef struct
{
  int ref;
  int len;
  struct user_attribute *attribs;
  int numattribs;
  byte *attrib_data;
  unsigned long attrib_len;
  byte *namehash;
  int help_key_usage;
  u32 help_key_expire;
  int help_full_count;
  int help_marginal_count;
  int is_primary;
  int is_revoked;
  int is_expired;
  u32 expiredate;
  prefitem_t *prefs;
  u32 created;
  byte selfsigversion;
  struct
  {

    unsigned mdc:1;
    unsigned ks_modify:1;
    unsigned compacted:1;
  } flags;
  char name[1];
} PKT_user_id;

struct revoke_info
{

  u32 date;

  u32 keyid[2];

  byte algo;
};







typedef struct {
    u32 timestamp;
    u32 expiredate;
    u32 max_expiredate;
    struct revoke_info revoked;
    byte hdrbytes;
    byte version;
    byte selfsigversion;
    byte pubkey_algo;
    byte pubkey_usage;
    byte req_usage;
    byte req_algo;
    u32 has_expired;
    int is_revoked;

    int maybe_revoked;

    int is_valid;
    int dont_cache;
    byte backsig;
    u32 main_keyid[2];
    u32 keyid[2];
    byte is_primary;
    byte is_disabled;
    prefitem_t *prefs;
    int mdc_feature;
    PKT_user_id *user_id;
    struct revocation_key *revkey;
    int numrevkeys;
    u32 trust_timestamp;
    byte trust_depth;
    byte trust_value;
    const byte *trust_regexp;
    MPI pkey[4];
} PKT_public_key;





typedef struct {
    u32 timestamp;
    u32 expiredate;
    u32 max_expiredate;
    byte hdrbytes;
    byte version;
    byte pubkey_algo;
    byte pubkey_usage;
    byte req_usage;
    byte req_algo;
    u32 has_expired;
    int is_revoked;
    int is_valid;
    u32 main_keyid[2];
    u32 keyid[2];
    byte is_primary;
    byte is_protected;



    struct {
 byte algo;
        byte sha1chk;
 STRING2KEY s2k;
 byte ivlen;
 byte iv[16];
    } protect;
    MPI skey[6];
    u16 csum;
} PKT_secret_key;


typedef struct {
    int len;
    char data[1];
} PKT_comment;

typedef struct {
    u32 len;
    byte new_ctb;
    byte algorithm;
    IOBUF buf;
} PKT_compressed;

typedef struct {
    u32 len;
    int extralen;
    byte new_ctb;
    byte is_partial;
    byte mdc_method;
    IOBUF buf;
} PKT_encrypted;

typedef struct {
    byte hash[20];
} PKT_mdc;

typedef struct {
    unsigned int trustval;
    unsigned int sigcache;
} PKT_ring_trust;

typedef struct {
    u32 len;
    IOBUF buf;
    byte new_ctb;
    byte is_partial;
    int mode;
    u32 timestamp;
    int namelen;
    char name[1];
} PKT_plaintext;

typedef struct {
    int control;
    size_t datalen;
    char data[1];
} PKT_gpg_control;


struct packet_struct {
    pkttype_t pkttype;
    union {
 void *generic;
 PKT_symkey_enc *symkey_enc;
 PKT_pubkey_enc *pubkey_enc;
 PKT_onepass_sig *onepass_sig;
 PKT_signature *signature;
 PKT_public_key *public_key;
 PKT_secret_key *secret_key;
 PKT_comment *comment;
 PKT_user_id *user_id;
 PKT_compressed *compressed;
 PKT_encrypted *encrypted;
 PKT_mdc *mdc;
 PKT_ring_trust *ring_trust;
 PKT_plaintext *plaintext;
        PKT_gpg_control *gpg_control;
    } pkt;
};





typedef enum {
    SIGSUBPKT_TEST_CRITICAL=-3,
    SIGSUBPKT_LIST_UNHASHED=-2,
    SIGSUBPKT_LIST_HASHED =-1,
    SIGSUBPKT_NONE = 0,
    SIGSUBPKT_SIG_CREATED = 2,
    SIGSUBPKT_SIG_EXPIRE = 3,
    SIGSUBPKT_EXPORTABLE = 4,
    SIGSUBPKT_TRUST = 5,
    SIGSUBPKT_REGEXP = 6,
    SIGSUBPKT_REVOCABLE = 7,
    SIGSUBPKT_KEY_EXPIRE = 9,
    SIGSUBPKT_ARR =10,
    SIGSUBPKT_PREF_SYM =11,
    SIGSUBPKT_REV_KEY =12,
    SIGSUBPKT_ISSUER =16,
    SIGSUBPKT_NOTATION =20,
    SIGSUBPKT_PREF_HASH =21,
    SIGSUBPKT_PREF_COMPR =22,
    SIGSUBPKT_KS_FLAGS =23,
    SIGSUBPKT_PREF_KS =24,
    SIGSUBPKT_PRIMARY_UID =25,
    SIGSUBPKT_POLICY =26,
    SIGSUBPKT_KEY_FLAGS =27,
    SIGSUBPKT_SIGNERS_UID =28,
    SIGSUBPKT_REVOC_REASON =29,
    SIGSUBPKT_FEATURES =30,

    SIGSUBPKT_SIGNATURE =32,

    SIGSUBPKT_FLAG_CRITICAL=128
} sigsubpkttype_t;

struct notation
{
  char *name;
  char *value;
  char *altvalue;
  unsigned char *bdat;
  size_t blen;
  struct
  {
    unsigned int critical:1;
    unsigned int ignore:1;
  } flags;
  struct notation *next;
};


void reset_literals_seen(void);
int proc_packets( void *ctx, IOBUF a );
int proc_signature_packets( void *ctx, IOBUF a,
       STRLIST signedfiles, const char *sigfile );
int proc_encryption_packets( void *ctx, IOBUF a );
int list_packets( IOBUF a );


int set_packet_list_mode( int mode );


int dbg_search_packet( IOBUF inp, PACKET *pkt, off_t *retpos, int with_uid,
                       const char* file, int lineno );
int dbg_parse_packet( IOBUF inp, PACKET *ret_pkt,
                      const char* file, int lineno );
int dbg_copy_all_packets( IOBUF inp, IOBUF out,
                          const char* file, int lineno );
int dbg_copy_some_packets( IOBUF inp, IOBUF out, off_t stopoff,
                           const char* file, int lineno );
int dbg_skip_some_packets( IOBUF inp, unsigned n,
                           const char* file, int lineno );
# 463 "./packet.h"
int parse_signature( IOBUF inp, int pkttype, unsigned long pktlen,
       PKT_signature *sig );
const byte *enum_sig_subpkt ( const subpktarea_t *subpkts,
                              sigsubpkttype_t reqtype,
                              size_t *ret_n, int *start, int *critical );
const byte *parse_sig_subpkt ( const subpktarea_t *buffer,
                               sigsubpkttype_t reqtype,
                               size_t *ret_n );
const byte *parse_sig_subpkt2 ( PKT_signature *sig,
                                sigsubpkttype_t reqtype,
                                size_t *ret_n );
int parse_one_sig_subpkt( const byte *buffer, size_t n, int type );
void parse_revkeys(PKT_signature *sig);
int parse_attribute_subpkts(PKT_user_id *uid);
void make_attribute_uidname(PKT_user_id *uid, size_t max_namelen);
PACKET *create_gpg_control ( ctrlpkttype_t type,
                             const byte *data,
                             size_t datalen );


int build_packet( IOBUF inp, PACKET *pkt );
u32 calc_packet_length( PACKET *pkt );
void build_sig_subpkt( PKT_signature *sig, sigsubpkttype_t type,
   const byte *buffer, size_t buflen );
void build_sig_subpkt_from_sig( PKT_signature *sig );
int delete_sig_subpkt(subpktarea_t *buffer, sigsubpkttype_t type );
void build_attribute_subpkt(PKT_user_id *uid,byte type,
       const void *buf,u32 buflen,
       const void *header,u32 headerlen);
struct notation *string_to_notation(const char *string,int is_utf8);
struct notation *sig_to_notation(PKT_signature *sig);
void free_notation(struct notation *notation);


void free_symkey_enc( PKT_symkey_enc *enc );
void free_pubkey_enc( PKT_pubkey_enc *enc );
void free_seckey_enc( PKT_signature *enc );
int digest_algo_from_sig( PKT_signature *sig );
void release_public_key_parts( PKT_public_key *pk );
void free_public_key( PKT_public_key *key );
void release_secret_key_parts( PKT_secret_key *sk );
void free_secret_key( PKT_secret_key *sk );
void free_attributes(PKT_user_id *uid);
void free_user_id( PKT_user_id *uid );
void free_comment( PKT_comment *rem );
void free_packet( PACKET *pkt );
prefitem_t *copy_prefs (const prefitem_t *prefs);
PKT_public_key *copy_public_key( PKT_public_key *d, PKT_public_key *s );
void copy_public_parts_to_secret_key( PKT_public_key *pk, PKT_secret_key *sk );
PKT_secret_key *copy_secret_key( PKT_secret_key *d, PKT_secret_key *s );
PKT_signature *copy_signature( PKT_signature *d, PKT_signature *s );
PKT_user_id *scopy_user_id (PKT_user_id *sd );
int cmp_public_keys( PKT_public_key *a, PKT_public_key *b );
int cmp_secret_keys( PKT_secret_key *a, PKT_secret_key *b );
int cmp_signatures( PKT_signature *a, PKT_signature *b );
int cmp_public_secret_key( PKT_public_key *pk, PKT_secret_key *sk );
int cmp_user_ids( PKT_user_id *a, PKT_user_id *b );



int signature_check( PKT_signature *sig, MD_HANDLE digest );
int signature_check2( PKT_signature *sig, MD_HANDLE digest, u32 *r_expiredate,
        int *r_expired, int *r_revoked, PKT_public_key *ret_pk );


int is_secret_key_protected( PKT_secret_key *sk );
int check_secret_key( PKT_secret_key *sk, int retries );
int protect_secret_key( PKT_secret_key *sk, DEK *dek );


int get_session_key( PKT_pubkey_enc *k, DEK *dek );
int get_override_session_key( DEK *dek, const char *string );


int handle_compressed( void *ctx, PKT_compressed *cd,
         int (*callback)(IOBUF, void *), void *passthru );


int decrypt_data( void *ctx, PKT_encrypted *ed, DEK *dek );


int handle_plaintext( PKT_plaintext *pt, md_filter_context_t *mfx,
     int nooutput, int clearsig );
int ask_for_detached_datafile( MD_HANDLE md, MD_HANDLE md2,
          const char *inname, int textmode );


int make_keysig_packet( PKT_signature **ret_sig, PKT_public_key *pk,
   PKT_user_id *uid, PKT_public_key *subpk,
   PKT_secret_key *sk, int sigclass, int digest_algo,
   int sigversion, u32 timestamp, u32 duration,
   int (*mksubpkt)(PKT_signature *, void *),
   void *opaque );
int update_keysig_packet( PKT_signature **ret_sig,
                      PKT_signature *orig_sig,
                      PKT_public_key *pk,
                      PKT_user_id *uid,
                      PKT_public_key *subpk,
                      PKT_secret_key *sk,
                      int (*mksubpkt)(PKT_signature *, void *),
                      void *opaque );


PKT_user_id *generate_user_id(void);
# 48 "gpg.c" 2


# 1 "../include/util.h" 1
# 23 "../include/util.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 1 3
# 14 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 1 3
# 47 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_header_macro.h" 1 3
# 48 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3



# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___gnuc_va_list.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___gnuc_va_list.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 52 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_list.h" 1 3
# 12 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_list.h" 3
typedef __builtin_va_list va_list;
# 57 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_arg.h" 1 3
# 62 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg___va_copy.h" 1 3
# 67 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3




# 1 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/__stdarg_va_copy.h" 1 3
# 72 "/home/yang/wasm/emsdk/upstream/lib/clang/20/include/stdarg.h" 2 3
# 15 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdarg.h" 2 3
# 24 "../include/util.h" 2


# 1 "../include/errors.h" 1
# 27 "../include/util.h" 2


# 1 "../include/compat.h" 1







int hextobyte( const char *s );
int ascii_toupper (int c);
int ascii_tolower (int c);
int ascii_strcasecmp( const char *a, const char *b );
int ascii_strncasecmp( const char *a, const char *b, size_t n);






char *xstrconcat (const char *s1, ...) __attribute__ ((sentinel(0)));
# 30 "../include/util.h" 2
# 39 "../include/util.h"
typedef struct {
     int *argc;
     char ***argv;
     unsigned flags;
     int err;

     int r_opt;
     int r_type;
     union {
  int ret_int;
  long ret_long;
  ulong ret_ulong;
  char *ret_str;
     } r;
     struct {
  int idx;
  int inarg;
  int stopped;
  const char *last;
  void *aliases;
  const void *cur_alias;
         void *iio_list;
     } internal;
} ARGPARSE_ARGS;

typedef struct {
    int short_opt;
    const char *long_opt;
    unsigned flags;
    const char *description;
} ARGPARSE_OPTS;


void log_set_logfile( const char *name, int fd );
FILE *log_stream(void);
void g10_log_print_prefix(const char *text);
void log_set_name( const char *name );
const char *log_get_name(void);
void log_set_pid( int pid );
int log_get_errorcount( int clear );
void log_inc_errorcount(void);
int log_set_strict(int val);
void g10_log_hexdump( const char *text, const char *buf, size_t len );



  void g10_log_bug( const char *fmt, ... )
       __attribute__ ((noreturn, format (printf,1,2)));
  void g10_log_bug0( const char *, int, const char * ) __attribute__ ((noreturn));
  void g10_log_fatal( const char *fmt, ... )
       __attribute__ ((noreturn, format (printf,1,2)));
  void g10_log_error( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_info( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_warning( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
  void g10_log_debug( const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
# 121 "../include/util.h"
const char * g10_errstr( int no );


int arg_parse( ARGPARSE_ARGS *arg, ARGPARSE_OPTS *opts);
int optfile_parse( FILE *fp, const char *filename, unsigned *lineno,
     ARGPARSE_ARGS *arg, ARGPARSE_OPTS *opts);
void usage( int level );
const char *default_strusage( int level );



const char *strusage( int level );



# 1 "../include/../include/dotlock.h" 1
# 97 "../include/../include/dotlock.h"
struct dotlock_handle;
typedef struct dotlock_handle *dotlock_t;

void dotlock_disable (void);
dotlock_t dotlock_create (const char *file_to_lock, unsigned int flags);
void dotlock_set_fd (dotlock_t h, int fd);
int dotlock_get_fd (dotlock_t h);
void dotlock_destroy (dotlock_t h, int reclaim);
int dotlock_take (dotlock_t h, long timeout);
int dotlock_release (dotlock_t h);
void dotlock_remove_lockfiles (int reclaim);
void dotlock_remove_lockfiles_reclaim (void);
# 137 "../include/util.h" 2


char * make_basename(const char *filepath, const char *inputpath);
char * make_dirname(const char *filepath);
char *make_filename( const char *first_part, ... );
int compare_filenames( const char *a, const char *b );
int same_file_p (const char *name1, const char *name2);
const char *print_fname_stdin( const char *s );
const char *print_fname_stdout( const char *s );
int is_file_compressed(const char *s, int *r_status);


u32 make_timestamp(void);
u32 scan_isodatestr( const char *string );
u32 isotime2seconds (const char *string);
const char *strtimevalue( u32 stamp );
const char *strtimestamp( u32 stamp );
const char *isotimestamp( u32 stamp );
const char *asctimestamp( u32 stamp );
void print_string( FILE *fp, const byte *p, size_t n, int delim );
void print_string2( FILE *fp, const byte *p, size_t n, int delim, int delim2 );
void print_utf8_string( FILE *fp, const byte *p, size_t n );
void print_utf8_string2( FILE *fp, const byte *p, size_t n, int delim);
char *make_printable_string( const byte *p, size_t n, int delim );
int answer_is_yes_no_default( const char *s, int def_answer );
int answer_is_yes( const char *s );
int answer_is_yes_no_quit( const char *s );
int answer_is_okay_cancel (const char *s, int def_answer);
int match_multistr(const char *multistr,const char *match);


void free_strlist( STRLIST sl );

STRLIST add_to_strlist( STRLIST *list, const char *string );
STRLIST add_to_strlist2( STRLIST *list, const char *string, int is_utf8 );
STRLIST append_to_strlist( STRLIST *list, const char *string );
STRLIST append_to_strlist2( STRLIST *list, const char *string, int is_utf8 );
STRLIST strlist_prev( STRLIST head, STRLIST node );
STRLIST strlist_last( STRLIST node );
char *pop_strlist( STRLIST *list );
const char *memistr( const char *buf, size_t buflen, const char *sub );
const char *ascii_memistr( const char *buf, size_t buflen, const char *sub );
char *mem2str( char *, const void *, size_t);
char *trim_spaces( char *string );
unsigned int trim_trailing_chars( byte *line, unsigned int len,
                                  const char *trimchars);
unsigned int trim_trailing_ws( byte *line, unsigned len );
unsigned int check_trailing_chars( const byte *line, unsigned int len,
                                   const char *trimchars );
unsigned int check_trailing_ws( const byte *line, unsigned int len );
int string_count_chr( const char *string, int c );
int has_invalid_email_chars (const char *s);
int is_valid_mailbox (const char *name);
int set_native_charset( const char *newset );
const char* get_native_charset(void);
char *native_to_utf8( const char *string );
char *utf8_to_native( const char *string, size_t length, int delim);
char *string_to_utf8 (const char *string);

int ascii_isupper (int c);
int ascii_islower (int c);
int ascii_memcasecmp( const char *a, const char *b, size_t n);
char *ascii_strlwr (char *s);
# 223 "../include/util.h"
struct private_membuf_s {
  size_t len;
  size_t size;
  char *buf;
  int out_of_core;
};

typedef struct private_membuf_s membuf_t;

void init_membuf (membuf_t *mb, int initiallen);
void put_membuf (membuf_t *mb, const void *buf, size_t len);
void put_membuf_str (membuf_t *mb, const char *buf);
void *get_membuf (membuf_t *mb, size_t *len);
# 249 "../include/util.h"
char *xasprintf (const char *fmt, ...);
char *xtryasprintf (const char *fmt, ...);
char *xtryvasprintf (const char *fmt, va_list arg_ptr);
char *strconcat (const char *s1, ...) __attribute__ ((sentinel(0)));


char *get_pka_info (const char *address, void *fprbuf, size_t fprbuflen);


int get_cert (const char *name, int want_ipgp, size_t max_size, IOBUF *iobuf,
              unsigned char **fpr,size_t *fpr_len,char **url);


int hex2bin (const char *string, void *buffer, size_t length);
int hexcolon2bin (const char *string, void *buffer, size_t length);
char *bin2hex (const void *buffer, size_t length, char *stringbuf);
char *bin2hexcolon (const void *buffer, size_t length, char *stringbuf);
const char *hex2str (const char *hexstring,
                     char *buffer, size_t bufsize, size_t *buflen);
char *hex2str_alloc (const char *hexstring, size_t *r_count);
# 51 "gpg.c" 2
# 1 "./main.h" 1
# 26 "./main.h"
# 1 "./keydb.h" 1
# 43 "./keydb.h"
struct getkey_ctx_s;
typedef struct getkey_ctx_s *GETKEY_CTX;
# 54 "./keydb.h"
struct kbnode_struct {
    KBNODE next;
    PACKET *pkt;
    int flag;
    int private_flag;
    ulong recno;
};





enum resource_type {
    rt_UNKNOWN = 0,
    rt_RING = 1
};






struct keyblock_pos_struct {
    int resno;
    enum resource_type rt;
    off_t offset;
    unsigned count;
    IOBUF fp;
    int secret;
    PACKET *pkt;
    int valid;
};
typedef struct keyblock_pos_struct KBPOS;


typedef struct pk_list *PK_LIST;
struct pk_list {
    PK_LIST next;
    PKT_public_key *pk;
    int flags;
};


typedef struct sk_list *SK_LIST;
struct sk_list {
    SK_LIST next;
    PKT_secret_key *sk;
    int mark;
};



typedef struct pubkey_find_info *PUBKEY_FIND_INFO;
struct pubkey_find_info {
    u32 keyid[2];
    unsigned nbits;
    byte pubkey_algo;
    byte fingerprint[20];
    char userid[1];
};


typedef struct keydb_handle *KEYDB_HANDLE;

typedef enum {
    KEYDB_SEARCH_MODE_NONE,
    KEYDB_SEARCH_MODE_EXACT,
    KEYDB_SEARCH_MODE_SUBSTR,
    KEYDB_SEARCH_MODE_MAIL,
    KEYDB_SEARCH_MODE_MAILSUB,
    KEYDB_SEARCH_MODE_MAILEND,
    KEYDB_SEARCH_MODE_WORDS,
    KEYDB_SEARCH_MODE_SHORT_KID,
    KEYDB_SEARCH_MODE_LONG_KID,
    KEYDB_SEARCH_MODE_FPR16,
    KEYDB_SEARCH_MODE_FPR20,
    KEYDB_SEARCH_MODE_FPR,
    KEYDB_SEARCH_MODE_FIRST,
    KEYDB_SEARCH_MODE_NEXT
} KeydbSearchMode;

struct keydb_search_desc {
    KeydbSearchMode mode;
    int (*skipfnc)(void *,u32*,PKT_user_id*);
    void *skipfncvalue;
    union {
        const char *name;
        byte fpr[20];
        u32 kid[2];
    } u;
    int exact;
};







int keydb_add_resource (const char *url, int flags, int secret);
KEYDB_HANDLE keydb_new (int secret);
void keydb_release (KEYDB_HANDLE hd);
const char *keydb_get_resource_name (KEYDB_HANDLE hd);
int keydb_get_keyblock (KEYDB_HANDLE hd, KBNODE *ret_kb);
int keydb_update_keyblock (KEYDB_HANDLE hd, KBNODE kb);
int keydb_insert_keyblock (KEYDB_HANDLE hd, KBNODE kb);
int keydb_delete_keyblock (KEYDB_HANDLE hd);
int keydb_locate_writable (KEYDB_HANDLE hd, const char *reserved);
void keydb_rebuild_caches (int noisy);
int keydb_search_reset (KEYDB_HANDLE hd);

int keydb_search2 (KEYDB_HANDLE hd, KEYDB_SEARCH_DESC *desc,
     size_t ndesc, size_t *descindex);
int keydb_search_first (KEYDB_HANDLE hd);
int keydb_search_next (KEYDB_HANDLE hd);
int keydb_search_kid (KEYDB_HANDLE hd, u32 *kid);
int keydb_search_fpr (KEYDB_HANDLE hd, const byte *fpr);



void show_revocation_reason( PKT_public_key *pk, int mode );
int check_signatures_trust( PKT_signature *sig );
void release_pk_list( PK_LIST pk_list );
int build_pk_list( STRLIST rcpts, PK_LIST *ret_pk_list, unsigned use );
union pref_hint
{
  int digest_length;
};
int algo_available( preftype_t preftype, int algo,
       const union pref_hint *hint );
int select_algo_from_prefs( PK_LIST pk_list, int preftype,
        int request, const union pref_hint *hint );
int select_mdc_from_pklist (PK_LIST pk_list);


void release_sk_list( SK_LIST sk_list );
int build_sk_list( STRLIST locusr, SK_LIST *ret_sk_list,
         int unlock, unsigned use );
# 200 "./keydb.h"
typedef int assuan_error_t;
typedef void *assuan_context_t;

int have_static_passphrase(void);
void set_passphrase_from_string(const char *pass);
void read_passphrase_from_fd( int fd );
void passphrase_clear_cache ( u32 *keyid, const char *cacheid, int algo );
char *ask_passphrase (const char *description,
                      const char *tryagain_text,
                      const char *promptid,
                      const char *prompt,
                      const char *cacheid, int *canceled);
DEK *passphrase_to_dek( u32 *keyid, int pubkey_algo,
   int cipher_algo, STRING2KEY *s2k, int mode,
                        const char *tryagain_text, int *canceled);
void set_next_passphrase( const char *s );
char *get_last_passphrase(void);
void next_to_last_passphrase(void);


int classify_user_id( const char *name, KEYDB_SEARCH_DESC *desc);
void cache_public_key( PKT_public_key *pk );
void getkey_disable_caches(void);
int get_pubkey( PKT_public_key *pk, u32 *keyid );
int get_pubkey_fast ( PKT_public_key *pk, u32 *keyid );
KBNODE get_pubkeyblock( u32 *keyid );
int get_pubkey_byname( PKT_public_key *pk, const char *name,
                       KBNODE *ret_keyblock, KEYDB_HANDLE *ret_kdbhd,
         int include_unusable );
int get_pubkey_bynames( GETKEY_CTX *rx, PKT_public_key *pk,
   STRLIST names, KBNODE *ret_keyblock );
int get_pubkey_next( GETKEY_CTX ctx, PKT_public_key *pk, KBNODE *ret_keyblock );
void get_pubkey_end( GETKEY_CTX ctx );
int get_seckey( PKT_secret_key *sk, u32 *keyid );
int get_primary_seckey( PKT_secret_key *sk, u32 *keyid );
int get_pubkey_byfprint( PKT_public_key *pk, const byte *fprint,
       size_t fprint_len );
int get_pubkey_byfprint_fast (PKT_public_key *pk,
                              const byte *fprint, size_t fprint_len);
int get_keyblock_byfprint( KBNODE *ret_keyblock, const byte *fprint,
       size_t fprint_len );
int get_keyblock_bylid( KBNODE *ret_keyblock, ulong lid );
int seckey_available( u32 *keyid );
int get_seckey_byname( PKT_secret_key *sk, const char *name, int unlock );
int get_seckey_bynames( GETKEY_CTX *rx, PKT_secret_key *sk,
   STRLIST names, KBNODE *ret_keyblock );
int get_seckey_next (GETKEY_CTX ctx, PKT_secret_key *sk, KBNODE *ret_keyblock);
void get_seckey_end( GETKEY_CTX ctx );

int get_seckey_byfprint( PKT_secret_key *sk,
    const byte *fprint, size_t fprint_len);
int get_seckeyblock_byfprint (KBNODE *ret_keyblock, const byte *fprint,
                              size_t fprint_len );


int enum_secret_keys( void **context, PKT_secret_key *sk,
        int with_subkeys, int with_spm );
void merge_keys_and_selfsig( KBNODE keyblock );
char*get_user_id_string( u32 *keyid );
char*get_user_id_string_native( u32 *keyid );
char*get_long_user_id_string( u32 *keyid );
char*get_user_id( u32 *keyid, size_t *rn );
char*get_user_id_native( u32 *keyid );
KEYDB_HANDLE get_ctx_handle(GETKEY_CTX ctx);
void release_akl(void);
int parse_auto_key_locate(char *options);


int pubkey_letter( int algo );
void hash_public_key( MD_HANDLE md, PKT_public_key *pk );
size_t keystrlen(void);
const char *keystr(u32 *keyid);
const char *keystr_from_pk(PKT_public_key *pk);
const char *keystr_from_sk(PKT_secret_key *sk);
const char *keystr_from_desc(KEYDB_SEARCH_DESC *desc);
u32 keyid_from_sk( PKT_secret_key *sk, u32 *keyid );
u32 keyid_from_pk( PKT_public_key *pk, u32 *keyid );
u32 keyid_from_sig( PKT_signature *sig, u32 *keyid );
u32 keyid_from_fingerprint(const byte *fprint, size_t fprint_len, u32 *keyid);
byte *namehash_from_uid(PKT_user_id *uid);
unsigned nbits_from_pk( PKT_public_key *pk );
unsigned nbits_from_sk( PKT_secret_key *sk );
const char *datestr_from_pk( PKT_public_key *pk );
const char *datestr_from_sk( PKT_secret_key *sk );
const char *datestr_from_sig( PKT_signature *sig );
const char *expirestr_from_pk( PKT_public_key *pk );
const char *expirestr_from_sk( PKT_secret_key *sk );
const char *expirestr_from_sig( PKT_signature *sig );
const char *revokestr_from_pk( PKT_public_key *pk );
const char *usagestr_from_pk( PKT_public_key *pk );
const char *colon_strtime (u32 t);
const char *colon_datestr_from_pk (PKT_public_key *pk);
const char *colon_datestr_from_sk (PKT_secret_key *sk);
const char *colon_datestr_from_sig (PKT_signature *sig);
const char *colon_expirestr_from_sig (PKT_signature *sig);
byte *fingerprint_from_sk( PKT_secret_key *sk, byte *buf, size_t *ret_len );
byte *fingerprint_from_pk( PKT_public_key *pk, byte *buf, size_t *ret_len );


KBNODE new_kbnode( PACKET *pkt );
KBNODE clone_kbnode( KBNODE node );
void release_kbnode( KBNODE n );
void delete_kbnode( KBNODE node );
void add_kbnode( KBNODE root, KBNODE node );
void insert_kbnode( KBNODE root, KBNODE node, int pkttype );
void move_kbnode( KBNODE *root, KBNODE node, KBNODE where );
void remove_kbnode( KBNODE *root, KBNODE node );
KBNODE find_prev_kbnode( KBNODE root, KBNODE node, int pkttype );
KBNODE find_next_kbnode( KBNODE node, int pkttype );
KBNODE find_kbnode( KBNODE node, int pkttype );
KBNODE walk_kbnode( KBNODE root, KBNODE *context, int all );
void clear_kbnode_flags( KBNODE n );
int commit_kbnode( KBNODE *root );
void dump_kbnode( KBNODE node );
# 27 "./main.h" 2
# 47 "./main.h"
typedef struct
{
  int header_okay;
  PK_LIST pk_list;
  DEK *symkey_dek;
  STRING2KEY *symkey_s2k;
  cipher_filter_context_t cfx;
} encrypt_filter_context_t;

struct groupitem
{
  char *name;
  STRLIST values;
  struct groupitem *next;
};

struct weakhash
{
  int algo;
  int rejection_shown;
  struct weakhash *next;
};



extern int g10_errors_seen;


  void g10_exit(int rc) __attribute__ ((noreturn));



void print_pubkey_algo_note( int algo );
void print_cipher_algo_note( int algo );
void print_digest_algo_note( int algo );
void additional_weak_digest (const char* digestname);


char *make_radix64_string( const byte *data, size_t len );
int parse_key_failed_line (const void *lineptr, unsigned int len);


void trap_unaligned(void);
int disable_core_dumps(void);
void register_secured_file (const char *fname);
void unregister_secured_file (const char *fname);
int is_secured_file (int fd);
int is_secured_filename (const char *fname);
u16 checksum_u16( unsigned n );
u16 checksum( byte *p, unsigned n );
u16 checksum_mpi( MPI a );
u32 buffer_to_u32( const byte *buffer );
const byte *get_session_marker( size_t *rlen );
int openpgp_cipher_test_algo( int algo );
int openpgp_pk_test_algo( int algo, unsigned int usage_flags );
int openpgp_pk_algo_usage ( int algo );
int openpgp_md_test_algo( int algo );

void md5_digest_warn (int show);

void not_in_gpg1_notice (void);

struct expando_args
{
  PKT_public_key *pk;
  PKT_secret_key *sk;
  byte imagetype;
  int validity_info;
  const char *validity_string;
};

char *pct_expando(const char *string,struct expando_args *args);
void deprecated_warning(const char *configname,unsigned int configlineno,
   const char *option,const char *repl1,const char *repl2);
void deprecated_command (const char *name);

const char *compress_algo_to_string(int algo);
int string_to_compress_algo(const char *string);
int check_compress_algo(int algo);
int default_cipher_algo(void);
int default_compress_algo(void);
const char *compliance_option_string(void);
void compliance_failure(void);

struct parse_options
{
  char *name;
  unsigned int bit;
  char **value;
  char *help;
};

char *optsep(char **stringp);
char *argsplit(char *string);
int parse_options(char *str,unsigned int *options,
    struct parse_options *opts,int noisy);
char *unescape_percent_string (const unsigned char *s);
char *default_homedir (void);
const char *get_libexecdir (void);
int path_access(const char *file,int mode);


void display_online_help( const char *keyword );


int setup_symkey(STRING2KEY **symkey_s2k,DEK **symkey_dek);
int encode_symmetric( const char *filename );
int encode_store( const char *filename );
int encode_crypt( const char *filename, STRLIST remusr, int use_symkey );
void encode_crypt_files(int nfiles, char **files, STRLIST remusr);
int encrypt_filter( void *opaque, int control,
      IOBUF a, byte *buf, size_t *ret_len);



int complete_sig( PKT_signature *sig, PKT_secret_key *sk, MD_HANDLE md );
int sign_file( STRLIST filenames, int detached, STRLIST locusr,
        int do_encrypt, STRLIST remusr, const char *outfile );
int clearsign_file( const char *fname, STRLIST locusr, const char *outfile );
int sign_symencrypt_file (const char *fname, STRLIST locusr);


int check_revocation_keys (PKT_public_key *pk, PKT_signature *sig);
int check_backsig(PKT_public_key *main_pk,PKT_public_key *sub_pk,
    PKT_signature *backsig);
int check_key_signature( KBNODE root, KBNODE node, int *is_selfsig );
int check_key_signature2( KBNODE root, KBNODE node, PKT_public_key *check_pk,
     PKT_public_key *ret_pk, int *is_selfsig,
     u32 *r_expiredate, int *r_expired );


int delete_keys( STRLIST names, int secret, int allow_both );


void keyedit_menu( const char *username, STRLIST locusr,
     STRLIST commands, int quiet, int seckey_check );
void show_basic_key_info (KBNODE keyblock);


u32 parse_expire_string(u32 timestamp,const char *string);
u32 ask_expire_interval(u32 timestamp,int object,const char *def_expire);
void generate_keypair( const char *fname, const char *card_serialno,
                       const char *backup_encryption_dir );
int keygen_set_std_prefs (const char *string,int personal);
PKT_user_id *keygen_get_std_prefs (void);
int keygen_add_key_expire( PKT_signature *sig, void *opaque );
int keygen_add_std_prefs( PKT_signature *sig, void *opaque );
int keygen_upd_std_prefs( PKT_signature *sig, void *opaque );
int keygen_add_keyserver_url(PKT_signature *sig, void *opaque);
int keygen_add_notations(PKT_signature *sig,void *opaque);
int keygen_add_revkey(PKT_signature *sig, void *opaque);
int make_backsig(PKT_signature *sig,PKT_public_key *pk,
   PKT_public_key *sub_pk,PKT_secret_key *sub_sk,
                 u32 timestamp);
int generate_subkeypair( KBNODE pub_keyblock, KBNODE sec_keyblock );

int generate_card_subkeypair (KBNODE pub_keyblock, KBNODE sec_keyblock,
                              int keyno, const char *serialno);
int save_unprotected_key_to_card (PKT_secret_key *sk, int keyno);



int overwrite_filep( const char *fname );
char *make_outfile_name( const char *iname );
char *ask_outfile_name( const char *name, size_t namelen );
int open_outfile( const char *iname, int mode, IOBUF *a );
char *get_matching_datafile (const char *sigfilename);
IOBUF open_sigfile( const char *iname, progress_filter_context_t *pfx );
void try_make_homedir( const char *fname );


void make_session_key( DEK *dek );
MPI encode_session_key( DEK *dek, unsigned nbits );
MPI pkcs1_encode_md( MD_HANDLE md, int algo, size_t len, unsigned nbits,
       const byte *asn, size_t asnlen );
MPI encode_md_value( PKT_public_key *pk, PKT_secret_key *sk,
       MD_HANDLE md, int hash_algo );



typedef int (*import_filter_t)(kbnode_t keyblock, void *arg);

int parse_import_options(char *str,unsigned int *options,int noisy);
void import_keys( char **fnames, int nnames,
    void *stats_hd, unsigned int options );
int import_keys_stream (IOBUF inp,void *stats_hd,unsigned char **fpr,
                        size_t *fpr_len,unsigned int options,
                        import_filter_t filter, void *filter_arg,
                        int *r_gpgkeys_err);
void *import_new_stats_handle (void);
void import_release_stats_handle (void *p);
void import_print_stats (void *hd);

int collapse_uids( KBNODE *keyblock );

int auto_create_card_key_stub ( const char *serialnostr,
                                const unsigned char *fpr1,
                                const unsigned char *fpr2,
                                const unsigned char *fpr3);


int parse_export_options(char *str,unsigned int *options,int noisy);
int export_pubkeys( STRLIST users, unsigned int options );
int export_pubkeys_stream( IOBUF out, STRLIST users,
      KBNODE *keyblock_out, unsigned int options );
int export_seckeys( STRLIST users );
int export_secsubkeys( STRLIST users );


int dearmor_file( const char *fname );
int enarmor_file( const char *fname );


struct revocation_reason_info;
int gen_revoke( const char *uname );
int gen_desig_revoke( const char *uname, STRLIST locusr);
int revocation_reason_build_cb( PKT_signature *sig, void *opaque );
struct revocation_reason_info *
  ask_revocation_reason( int key_rev, int cert_rev, int hint );
void release_revocation_reason_info( struct revocation_reason_info *reason );


void public_key_list( STRLIST list );
void secret_key_list( STRLIST list );
void print_subpackets_colon(PKT_signature *sig);
void reorder_keyblock (KBNODE keyblock);
void list_keyblock( KBNODE keyblock, int secret, int fpr, void *opaque );
void print_fingerprint (PKT_public_key *pk, PKT_secret_key *sk, int mode);
void print_revokers(PKT_public_key *pk);
void show_policy_url(PKT_signature *sig,int indent,int mode);
void show_keyserver_url(PKT_signature *sig,int indent,int mode);
void show_notation(PKT_signature *sig,int indent,int mode,int which);
void dump_attribs(const PKT_user_id *uid,
    PKT_public_key *pk,PKT_secret_key *sk);
void set_attrib_fd(int fd);
void print_seckey_info (PKT_secret_key *sk);
void print_pubkey_info (FILE *fp, PKT_public_key *pk);
void print_card_key_info (FILE *fp, KBNODE keyblock);


void print_file_status( int status, const char *name, int what );
int verify_signatures( int nfiles, char **files );
int verify_files( int nfiles, char **files );


int decrypt_message( const char *filename );
void decrypt_messages(int nfiles, char *files[]);


int hash_datafiles( MD_HANDLE md, MD_HANDLE md2,
      STRLIST files, const char *sigfilename, int textmode );
PKT_plaintext *setup_plaintext_name(const char *filename,IOBUF iobuf);


void run_in_pipemode (void);


void init_signals(void);
void pause_on_sigusr( int which );
void block_all_signals(void);
void unblock_all_signals(void);




void change_pin (int no, int allow_admin);
void card_status (FILE *fp, char *serialno, size_t serialnobuflen);
void card_edit (STRLIST commands);
int card_generate_subkey (KBNODE pub_keyblock, KBNODE sec_keyblock);
int card_store_subkey (KBNODE node, int use);
# 52 "gpg.c" 2
# 1 "./options.h" 1
# 39 "./options.h"
struct
{
  int verbose;
  int quiet;
  unsigned debug;
  int armor;
  char *outfile;
  off_t max_output;
  int dry_run;
  int list_only;
  int textmode;
  int expert;
  const char *def_sig_expire;
  int ask_sig_expire;
  const char *def_cert_expire;
  int ask_cert_expire;
  int batch;
  int answer_yes;
  int answer_no;
  int check_sigs;
  int with_colons;
  int with_key_data;
  int with_fingerprint;
  int fingerprint;
  int list_sigs;
  int no_armor;
  int list_packets;
  int def_cipher_algo;
  int force_v3_sigs;
  int force_v4_certs;
  int force_mdc;
  int disable_mdc;
  int def_digest_algo;
  int cert_digest_algo;
  int compress_algo;
  int compress_level;
  int bz2_compress_level;
  int bz2_decompress_lowmem;
  const char *def_secret_key;
  char *def_recipient;
  int def_recipient_self;
  int def_cert_level;
  int min_cert_level;
  int ask_cert_level;
  int emit_version;




  int marginals_needed;
  int completes_needed;
  int max_cert_depth;
  const char *homedir;

  char *display;
  char *ttyname;
  char *ttytype;
  char *lc_ctype;
  char *lc_messages;

  int skip_verify;
  int compress_keys;
  int compress_sigs;


  enum
    {
      TM_CLASSIC=0, TM_PGP=1, TM_EXTERNAL=2, TM_ALWAYS, TM_DIRECT, TM_AUTO
    } trust_model;
  int force_ownertrust;
  enum
    {
      CO_GNUPG, CO_RFC4880, CO_RFC2440, CO_RFC1991, CO_PGP2,
      CO_PGP6, CO_PGP7, CO_PGP8
    } compliance;
  enum
    {
      KF_SHORT, KF_LONG, KF_0xSHORT, KF_0xLONG
    } keyid_format;
  int pgp2_workarounds;
  int shm_coprocess;
  const char *set_filename;
  STRLIST comments;
  int throw_keyid;
  const char *photo_viewer;
  int s2k_mode;
  int s2k_digest_algo;
  int s2k_cipher_algo;
  unsigned char s2k_count;

  int simple_sk_checksum;

  int not_dash_escaped;
  int escape_from;
  int lock_once;
  struct keyserver_spec
  {
    char *uri;
    char *scheme;
    char *auth;
    char *host;
    char *port;
    char *path;
    char *opaque;
    STRLIST options;
    struct
    {
      unsigned int direct_uri:1;
    } flags;
    struct keyserver_spec *next;
  } *keyserver;
  struct
  {
    unsigned int options;
    unsigned int import_options;
    unsigned int export_options;
    STRLIST other;
  } keyserver_options;
  int exec_disable;
  int exec_path_set;
  unsigned int import_options;
  unsigned int export_options;
  unsigned int list_options;
  unsigned int verify_options;
  const char *def_preference_list;
  const char *def_keyserver_url;
  prefitem_t *personal_cipher_prefs;
  prefitem_t *personal_digest_prefs;
  prefitem_t *personal_compress_prefs;
  struct weakhash *weak_digests;
  int no_perm_warn;
  int no_mdc_warn;
  char *temp_dir;
  int no_encrypt_to;
  int interactive;
  struct notation *sig_notations;
  struct notation *cert_notations;
  STRLIST sig_policy_url;
  STRLIST cert_policy_url;
  STRLIST sig_keyserver_url;
  STRLIST cert_subpackets;
  STRLIST sig_subpackets;
  int allow_non_selfsigned_uid;
  int allow_freeform_uid;
  int no_literal;
  ulong set_filesize;
  int fast_list_mode;
  int fixed_list_mode;
  int ignore_time_conflict;
  int ignore_valid_from;
  int ignore_crc_error;
  int ignore_mdc_error;
  int command_fd;
  const char *override_session_key;
  int show_session_key;
  int use_agent;
  const char *gpg_agent_info;
  int try_all_secrets;
  int no_expensive_trust_checks;
  int no_sig_cache;
  int no_auto_check_trustdb;
  int preserve_permissions;
  int no_homedir_creation;
  struct groupitem *grouplist;
  int strict;
  int mangle_dos_filenames;
  int enable_progress_filter;
  unsigned int screen_columns;
  unsigned int screen_lines;
  byte *show_subpackets;
  int rfc2440_text;


  int exit_on_status_write_error;



  int limit_card_insert_tries;


  const char *ctapi_driver;
  const char *pcsc_driver;
  int disable_ccid;
  int disable_keypad;


  struct
  {



    unsigned int require_cross_cert:1;
    unsigned int use_embedded_filename:1;
    unsigned int utf8_filename:1;
    unsigned int dsa2:1;
    unsigned int allow_multiple_messages:1;
    unsigned int allow_weak_digest_algos:1;
    unsigned int large_rsa:1;
  } flags;



  struct akl
  {
    enum {AKL_CERT, AKL_PKA, AKL_LDAP, AKL_KEYSERVER, AKL_SPEC} type;
    struct keyserver_spec *spec;
    struct akl *next;
  } *auto_key_locate;

  int passwd_repeat;
} opt;





struct {
  int in_auto_key_retrieve;

} glo_ctrl;
# 53 "gpg.c" 2

# 1 "./trustdb.h" 1
# 43 "./trustdb.h"
void register_trusted_keyid(u32 *keyid);
void register_trusted_key( const char *string );
void check_trustdb (void);
void update_trustdb (void);
int setup_trustdb( int level, const char *dbname );
void how_to_fix_the_trustdb (void);
void init_trustdb( void );
void check_trustdb_stale(void);
void sync_trustdb( void );

const char *uid_trust_string_fixed(PKT_public_key *key,PKT_user_id *uid);
const char *trust_value_to_string (unsigned int value);
int string_to_trust_value (const char *str);

void revalidation_mark (void);
int trustdb_pending_check(void);
void trustdb_check_or_update(void);

int cache_disabled_value(PKT_public_key *pk);

unsigned int get_validity (PKT_public_key *pk, PKT_user_id *uid);
int get_validity_info (PKT_public_key *pk, PKT_user_id *uid);
const char *get_validity_string (PKT_public_key *pk, PKT_user_id *uid);

void list_trust_path( const char *username );
int enum_cert_paths( void **context, ulong *lid,
       unsigned *ownertrust, unsigned *validity );
void enum_cert_paths_print( void **context, FILE *fp,
        int refresh, ulong selected_lid );

void read_trust_options(byte *trust_model,ulong *created,ulong *nextcheck,
   byte *marginals,byte *completes,byte *cert_depth,
   byte *min_cert_level);

unsigned int get_ownertrust (PKT_public_key *pk);
unsigned int get_min_ownertrust (PKT_public_key *pk);
int get_ownertrust_info (PKT_public_key *pk);
const char *get_ownertrust_string (PKT_public_key *pk);

void update_ownertrust (PKT_public_key *pk, unsigned int new_trust );
int clear_ownertrusts (PKT_public_key *pk);

void clean_one_uid(KBNODE keyblock,KBNODE uidnode,int noisy,int self_only,
     int *uids_cleaned,int *sigs_cleaned);
void clean_key(KBNODE keyblock,int noisy,int self_only,
        int *uids_cleaned,int *sigs_cleaned);


void list_trustdb(const char *username);
void export_ownertrust(void);
void import_ownertrust(const char *fname);


int edit_ownertrust (PKT_public_key *pk, int mode );
# 55 "gpg.c" 2



# 1 "../include/ttyio.h" 1
# 27 "../include/ttyio.h"
const char *tty_get_ttyname (void);
int tty_batchmode( int onoff );

 void tty_printf (const char *fmt, ... ) __attribute__ ((format (printf,1,2)));
 void tty_fprintf (FILE *fp, const char *fmt, ... )
                                __attribute__ ((format (printf,2,3)));




void tty_print_string( const byte *p, size_t n );
void tty_print_utf8_string( const byte *p, size_t n );
void tty_print_utf8_string2( const byte *p, size_t n, size_t max_n );
char *tty_get( const char *prompt );
char *tty_get_hidden( const char *prompt );
void tty_kill_prompt(void);
int tty_get_answer_is_yes( const char *prompt );
int tty_no_terminal(int onoff);
# 61 "../include/ttyio.h"
void tty_cleanup_after_signal (void);
# 59 "gpg.c" 2
# 1 "../include/i18n.h" 1
# 32 "../include/i18n.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 1 3
# 26 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 3
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;

 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_p_sep_by_space;
 char int_n_cs_precedes;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};


char *setlocale (int, const char *);
struct lconv *localeconv(void);







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 65 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 2 3
# 76 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/locale.h" 3
locale_t duplocale(locale_t);
void freelocale(locale_t);
locale_t newlocale(int, const char *, locale_t);
locale_t uselocale(locale_t);
# 33 "../include/i18n.h" 2




# 1 "../intl/libintl.h" 1
# 58 "../intl/libintl.h"
extern int libintl_version;
# 134 "../intl/libintl.h"
extern char *gettext (const char *__msgid)
       __asm__ ("" "libintl_gettext")
       __attribute__ ((__format_arg__ (1)));
# 152 "../intl/libintl.h"
extern char *dgettext (const char *__domainname, const char *__msgid)
       __asm__ ("" "libintl_dgettext")
       __attribute__ ((__format_arg__ (2)));
# 172 "../intl/libintl.h"
extern char *dcgettext (const char *__domainname, const char *__msgid,
                        int __category)
       __asm__ ("" "libintl_dcgettext")
       __attribute__ ((__format_arg__ (2)));
# 194 "../intl/libintl.h"
extern char *ngettext (const char *__msgid1, const char *__msgid2,
                       unsigned long int __n)
       __asm__ ("" "libintl_ngettext")
       __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));
# 215 "../intl/libintl.h"
extern char *dngettext (const char *__domainname,
                        const char *__msgid1, const char *__msgid2,
                        unsigned long int __n)
       __asm__ ("" "libintl_dngettext")
       __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
# 239 "../intl/libintl.h"
extern char *dcngettext (const char *__domainname,
                         const char *__msgid1, const char *__msgid2,
                         unsigned long int __n, int __category)
       __asm__ ("" "libintl_dcngettext")
       __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
# 261 "../intl/libintl.h"
extern char *textdomain (const char *__domainname)
       __asm__ ("" "libintl_textdomain");
# 279 "../intl/libintl.h"
extern char *bindtextdomain (const char *__domainname, const char *__dirname)
       __asm__ ("" "libintl_bindtextdomain");
# 297 "../intl/libintl.h"
extern char *bind_textdomain_codeset (const char *__domainname,
                                      const char *__codeset)
       __asm__ ("" "libintl_bind_textdomain_codeset");
# 455 "../intl/libintl.h"
extern void
       libintl_set_relocation_prefix (const char *orig_prefix,
                                      const char *curr_prefix);
# 38 "../include/i18n.h" 2
# 60 "gpg.c" 2
# 1 "./status.h" 1
# 128 "./status.h"
void set_status_fd ( int fd );
int is_status_enabled ( void );
void write_status ( int no );
void write_status_text ( int no, const char *text );
void write_status_buffer ( int no,
                           const char *buffer, size_t len, int wrap );
void write_status_text_and_buffer ( int no, const char *text,
                                    const char *buffer, size_t len, int wrap );


  void init_shm_coprocessing ( ulong requested_shm_size, int lock_mem );


int cpr_enabled(void);
char *cpr_get( const char *keyword, const char *prompt );
char *cpr_get_no_help( const char *keyword, const char *prompt );
char *cpr_get_utf8( const char *keyword, const char *prompt );
char *cpr_get_hidden( const char *keyword, const char *prompt );
void cpr_kill_prompt(void);
int cpr_get_answer_is_yes( const char *keyword, const char *prompt );
int cpr_get_answer_yes_no_quit( const char *keyword, const char *prompt );
int cpr_get_answer_okay_cancel (const char *keyword,
                                 const char *prompt,
                                 int def_answer);
# 61 "gpg.c" 2
# 1 "./keyserver-internal.h" 1
# 23 "./keyserver-internal.h"
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/time.h" 1 3







int dysize(int year);







# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 1 3
# 33 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 3
# 1 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h" 1 3
# 34 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 2 3






struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 const char *tm_zone;
};

clock_t clock (void);
time_t time (time_t *);
double difftime (time_t, time_t);
time_t mktime (struct tm *);
size_t strftime (char *restrict, size_t, const char *restrict, const struct tm *restrict);
struct tm *gmtime (const time_t *);
struct tm *localtime (const time_t *);
char *asctime (const struct tm *);
char *ctime (const time_t *);
int timespec_get(struct timespec *, int);
# 73 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 3
size_t strftime_l (char * restrict, size_t, const char * restrict, const struct tm * restrict, locale_t);

struct tm *gmtime_r (const time_t *restrict, struct tm *restrict);
struct tm *localtime_r (const time_t *restrict, struct tm *restrict);
char *asctime_r (const struct tm *restrict, char *restrict);
char *ctime_r (const time_t *, char *);

void tzset (void);

struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};
# 102 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/time.h" 3
int nanosleep (const struct timespec *, struct timespec *);
int clock_getres (clockid_t, struct timespec *);
int clock_gettime (clockid_t, struct timespec *);
int clock_settime (clockid_t, const struct timespec *);
int clock_nanosleep (clockid_t, int, const struct timespec *, struct timespec *);
int clock_getcpuclockid (pid_t, clockid_t *);

struct sigevent;
int timer_create (clockid_t, struct sigevent *restrict, timer_t *restrict);
int timer_delete (timer_t);
int timer_settime (timer_t, int, const struct itimerspec *restrict, struct itimerspec *restrict);
int timer_gettime (timer_t, struct itimerspec *);
int timer_getoverrun (timer_t);

extern char *tzname[2];





char *strptime (const char *restrict, const char *restrict, struct tm *restrict);
extern int daylight;
extern long timezone;
extern int getdate_err;
struct tm *getdate (const char *);




int stime(const time_t *);
time_t timegm(struct tm *);
# 17 "/home/yang/wasm/emsdk/upstream/emscripten/cache/sysroot/include/compat/time.h" 2 3
# 24 "./keyserver-internal.h" 2
# 1 "../include/keyserver.h" 1
# 25 "./keyserver-internal.h" 2



int parse_keyserver_options(char *options);
void free_keyserver_spec(struct keyserver_spec *keyserver);
struct keyserver_spec *keyserver_match(struct keyserver_spec *spec);
struct keyserver_spec *parse_keyserver_uri(const char *string,
        int require_scheme,
        const char *configname,
        unsigned int configlineno);
struct keyserver_spec *parse_preferred_keyserver(PKT_signature *sig);
int keyserver_export(STRLIST users);
int keyserver_import(STRLIST users);
int keyserver_import_fprint(const byte *fprint,size_t fprint_len,
       struct keyserver_spec *keyserver);
int keyserver_import_keyid(u32 *keyid,struct keyserver_spec *keyserver);
int keyserver_refresh(STRLIST users);
int keyserver_search(STRLIST tokens);
int keyserver_fetch(STRLIST urilist);
int keyserver_import_cert(const char *name,
     unsigned char **fpr,size_t *fpr_len);
int keyserver_import_pka(const char *name,unsigned char **fpr,size_t *fpr_len);
int keyserver_import_name(const char *name,unsigned char **fpr,size_t *fpr_len,
     struct keyserver_spec *keyserver);
int keyserver_import_ldap(const char *name,
     unsigned char **fpr,size_t *fpr_len);
# 62 "gpg.c" 2
# 1 "./exec.h" 1
# 27 "./exec.h"
struct exec_info
{
  int progreturn;
  struct
  {
    unsigned int binary:1;
    unsigned int writeonly:1;
    unsigned int madedir:1;
    unsigned int use_temp_files:1;
    unsigned int keep_temp_files:1;
  } flags;
  pid_t child;
  FILE *tochild;
  IOBUF fromchild;
  char *command,*name,*tempdir,*tempfile_in,*tempfile_out;
};

int exec_write(struct exec_info **info,const char *program,
        const char *args_in,const char *name,int writeonly,int binary);
int exec_read(struct exec_info *info);
int exec_finish(struct exec_info *info);
int set_exec_path(const char *path);
# 63 "gpg.c" 2
# 1 "./cardglue.h" 1
# 32 "./cardglue.h"
typedef void (*gcry_handler_progress_t) (void *, const char *, int, int, int);



struct agent_card_info_s {
  int error;
  char *apptype;
  char *serialno;
  char *disp_name;
  char *disp_lang;
  int disp_sex;
  char *pubkey_url;
  char *login_data;
  char *private_do[4];
  char cafpr1valid;
  char cafpr2valid;
  char cafpr3valid;
  char cafpr1[20];
  char cafpr2[20];
  char cafpr3[20];
  char fpr1valid;
  char fpr2valid;
  char fpr3valid;
  char fpr1[20];
  char fpr2[20];
  char fpr3[20];
  u32 fpr1time;
  u32 fpr2time;
  u32 fpr3time;
  unsigned long sig_counter;
  int chv1_cached;


  int is_v2;
  int chvmaxlen[3];
  int chvretry[3];
  struct {
    int algo;
    unsigned int nbits;
  } key_attr[3];
  struct {
    unsigned int ki:1;
    unsigned int aac:1;
  } extcap;
};

struct agent_card_genkey_s {
  char fprvalid;
  char fpr[20];
  u32 created_at;
  MPI n;
  MPI e;
};


struct app_ctx_s;
struct ctrl_ctx_s;

typedef struct app_ctx_s *APP;
typedef struct app_ctx_s *app_t;
typedef struct ctrl_ctx_s *CTRL;
typedef struct ctrl_ctx_s *ctrl_t;
# 142 "./cardglue.h"
typedef int gpg_error_t;
typedef int gpg_err_code_t;
# 165 "./cardglue.h"
void card_set_reader_port (const char *portstr);

char *serialno_and_fpr_from_sk (const unsigned char *sn, size_t snlen,
                                PKT_secret_key *sk);
void send_status_info (ctrl_t ctrl, const char *keyword, ...);
void send_status_direct (ctrl_t ctrl, const char *keyword, const char *args);
void gcry_md_hash_buffer (int algo, void *digest,
     const void *buffer, size_t length);
const char *gcry_md_algo_name (int algorithm);
void log_printf (const char *fmt, ...);
void log_printhex (const char *text, const void *buffer, size_t length);
# 186 "./cardglue.h"
void gcry_mpi_release (MPI a);
MPI gcry_mpi_set_opaque (MPI a, void *p, unsigned int len);


void card_close (void);



void agent_release_card_info (struct agent_card_info_s *info);


int agent_learn (struct agent_card_info_s *info);



int agent_havekey (const char *hexkeygrip);


int agent_scd_getattr (const char *name, struct agent_card_info_s *info);


int agent_scd_setattr (const char *name,
                       const unsigned char *value, size_t valuelen,
                       const char *serialno);


int agent_scd_writekey (int keyno, const char *serialno,
                        const unsigned char *keydata, size_t keydatalen);


int agent_scd_genkey (struct agent_card_genkey_s *info, int keyno, int force,
                      const char *serialno, u32 *createtime);


int agent_scd_pksign (const char *keyid, int hashalgo,
                      const unsigned char *indata, size_t indatalen,
                      unsigned char **r_buf, size_t *r_buflen);


int agent_scd_pkdecrypt (const char *serialno,
                         const unsigned char *indata, size_t indatalen,
                         unsigned char **r_buf, size_t *r_buflen);


int agent_scd_change_pin (int chvno, const char *serialno);


int agent_scd_checkpin (const char *serialnobuf);


void agent_clear_pin_cache (const char *sn);



int agent_scd_writecert (const char *certidstr,
                         const unsigned char *certdata, size_t certdatalen);
int agent_scd_readcert (const char *certidstr,
                        void **r_buf, size_t *r_buflen);
# 64 "gpg.c" 2

# 1 "./ccid-driver.h" 1
# 77 "./ccid-driver.h"
struct ccid_driver_s;
typedef struct ccid_driver_s *ccid_driver_t;

int ccid_set_debug_level (int level);
char *ccid_get_reader_list (void);
int ccid_open_reader (ccid_driver_t *handle, const char *readerid);
int ccid_set_progress_cb (ccid_driver_t handle,
                          void (*cb)(void *, const char *, int, int, int),
                          void *cb_arg);
int ccid_shutdown_reader (ccid_driver_t handle);
int ccid_close_reader (ccid_driver_t handle);
int ccid_get_atr (ccid_driver_t handle,
                  unsigned char *atr, size_t maxatrlen, size_t *atrlen);
int ccid_slot_status (ccid_driver_t handle, int *statusbits);
int ccid_transceive (ccid_driver_t handle,
                     const unsigned char *apdu, size_t apdulen,
                     unsigned char *resp, size_t maxresplen, size_t *nresp);
int ccid_transceive_secure (ccid_driver_t handle,
                     const unsigned char *apdu, size_t apdulen,
                     int pin_mode,
                     int pinlen_min, int pinlen_max, int pin_padlen,
                     unsigned char *resp, size_t maxresplen, size_t *nresp);
int ccid_transceive_escape (ccid_driver_t handle,
                            const unsigned char *data, size_t datalen,
                            unsigned char *resp, size_t maxresplen,
                            size_t *nresp);
# 66 "gpg.c" 2
# 79 "gpg.c"
enum cmd_and_opt_values
  {
    aNull = 0,
    oArmor = 'a',
    aDetachedSign = 'b',
    aSym = 'c',
    aDecrypt = 'd',
    aEncr = 'e',
    oInteractive = 'i',
    oKOption = 'k',
    oDryRun = 'n',
    oOutput = 'o',
    oQuiet = 'q',
    oRecipient = 'r',
    oHiddenRecipient = 'R',
    aSign = 's',
    oTextmodeShort= 't',
    oLocalUser = 'u',
    oVerbose = 'v',
    oCompress = 'z',
    oSetNotation = 'N',
    aListSecretKeys = 'K',
    oBatch = 500,
    oMaxOutput,
    oSigNotation,
    oCertNotation,
    oShowNotation,
    oNoShowNotation,
    aEncrFiles,
    aEncrSym,
    aDecryptFiles,
    aClearsign,
    aStore,
    aKeygen,
    aSignEncr,
    aSignEncrSym,
    aSignSym,
    aSignKey,
    aLSignKey,
    aListConfig,
    aGPGConfList,
    aGPGConfTest,
    aListPackets,
    aEditKey,
    aDeleteKeys,
    aDeleteSecretKeys,
    aDeleteSecretAndPublicKeys,
    aKMode,
    aKModeC,
    aImport,
    aFastImport,
    aVerify,
    aVerifyFiles,
    aListKeys,
    aListSigs,
    aSendKeys,
    aRecvKeys,
    aSearchKeys,
    aRefreshKeys,
    aFetchKeys,
    aExport,
    aExportSecret,
    aExportSecretSub,
    aCheckKeys,
    aGenRevoke,
    aDesigRevoke,
    aPrimegen,
    aPrintMD,
    aPrintMDs,
    aCheckTrustDB,
    aUpdateTrustDB,
    aFixTrustDB,
    aListTrustDB,
    aListTrustPath,
    aExportOwnerTrust,
    aListOwnerTrust,
    aImportOwnerTrust,
    aDeArmor,
    aEnArmor,
    aGenRandom,
    aPipeMode,
    aRebuildKeydbCaches,
    aCardStatus,
    aCardEdit,
    aChangePIN,

    oTextmode,
    oNoTextmode,
    oExpert,
    oNoExpert,
    oDefSigExpire,
    oAskSigExpire,
    oNoAskSigExpire,
    oDefCertExpire,
    oAskCertExpire,
    oNoAskCertExpire,
    oDefCertLevel,
    oMinCertLevel,
    oAskCertLevel,
    oNoAskCertLevel,
    oFingerprint,
    oWithFingerprint,
    oAnswerYes,
    oAnswerNo,
    oKeyring,
    oPrimaryKeyring,
    oSecretKeyring,
    oShowKeyring,
    oDefaultKey,
    oDefRecipient,
    oDefRecipientSelf,
    oNoDefRecipient,
    oOptions,
    oDebug,
    oDebugAll,
    oDebugLevel,
    oDebugCCIDDriver,
    oStatusFD,
    oStatusFile,
    oAttributeFD,
    oAttributeFile,
    oEmitVersion,
    oNoEmitVersion,
    oCompletesNeeded,
    oMarginalsNeeded,
    oMaxCertDepth,
    oLoadExtension,
    oGnuPG,
    oRFC1991,
    oRFC2440,
    oRFC4880,
    oOpenPGP,
    oPGP2,
    oPGP6,
    oPGP7,
    oPGP8,
    oRFC2440Text,
    oNoRFC2440Text,
    oCipherAlgo,
    oDigestAlgo,
    oCertDigestAlgo,
    oCompressAlgo,
    oCompressLevel,
    oBZ2CompressLevel,
    oBZ2DecompressLowmem,
    oPasswd,
    oPasswdFD,
    oPasswdFile,
    oPasswdRepeat,
    oCommandFD,
    oCommandFile,
    oQuickRandom,
    oNoVerbose,
    oTrustDBName,
    oNoSecmemWarn,
    oRequireSecmem,
    oNoRequireSecmem,
    oNoPermissionWarn,
    oNoMDCWarn,
    oNoArmor,
    oNoDefKeyring,
    oNoGreeting,
    oNoTTY,
    oNoOptions,
    oNoBatch,
    oHomedir,
    oWithColons,
    oWithKeyData,
    oSkipVerify,
    oCompressKeys,
    oCompressSigs,
    oAlwaysTrust,
    oTrustModel,
    oForceOwnertrust,
    oRunAsShmCP,
    oSetFilename,
    oForYourEyesOnly,
    oNoForYourEyesOnly,
    oSetPolicyURL,
    oSigPolicyURL,
    oCertPolicyURL,
    oShowPolicyURL,
    oNoShowPolicyURL,
    oSigKeyserverURL,
    oUseEmbeddedFilename,
    oNoUseEmbeddedFilename,
    oComment,
    oDefaultComment,
    oNoComments,
    oThrowKeyids,
    oNoThrowKeyids,
    oShowPhotos,
    oNoShowPhotos,
    oPhotoViewer,
    oForceV3Sigs,
    oNoForceV3Sigs,
    oForceV4Certs,
    oNoForceV4Certs,
    oForceMDC,
    oNoForceMDC,
    oDisableMDC,
    oNoDisableMDC,
    oS2KMode,
    oS2KDigest,
    oS2KCipher,
    oS2KCount,
    oSimpleSKChecksum,
    oDisplayCharset,
    oNotDashEscaped,
    oEscapeFrom,
    oNoEscapeFrom,
    oLockOnce,
    oLockMultiple,
    oLockNever,
    oKeyServer,
    oKeyServerOptions,
    oImportOptions,
    oExportOptions,
    oListOptions,
    oVerifyOptions,
    oTempDir,
    oExecPath,
    oEncryptTo,
    oHiddenEncryptTo,
    oNoEncryptTo,
    oLoggerFD,
    oLoggerFile,
    oUtf8Strings,
    oNoUtf8Strings,
    oDisableCipherAlgo,
    oDisablePubkeyAlgo,
    oAllowNonSelfsignedUID,
    oNoAllowNonSelfsignedUID,
    oAllowFreeformUID,
    oNoAllowFreeformUID,
    oAllowSecretKeyImport,
    oEnableSpecialFilenames,
    oNoLiteral,
    oSetFilesize,
    oHonorHttpProxy,
    oFastListMode,
    oListOnly,
    oIgnoreTimeConflict,
    oIgnoreValidFrom,
    oIgnoreCrcError,
    oIgnoreMDCError,
    oShowSessionKey,
    oOverrideSessionKey,
    oNoRandomSeedFile,
    oAutoKeyRetrieve,
    oNoAutoKeyRetrieve,
    oUseAgent,
    oNoUseAgent,
    oGpgAgentInfo,
    oMergeOnly,
    oTryAllSecrets,
    oTrustedKey,
    oNoExpensiveTrustChecks,
    oFixedListMode,
    oNoSigCache,
    oAutoCheckTrustDB,
    oNoAutoCheckTrustDB,
    oPreservePermissions,
    oDefaultPreferenceList,
    oDefaultKeyserverURL,
    oPersonalCipherPreferences,
    oPersonalDigestPreferences,
    oPersonalCompressPreferences,
    oDisplay,
    oTTYname,
    oTTYtype,
    oLCctype,
    oLCmessages,
    oGroup,
    oUnGroup,
    oNoGroups,
    oStrict,
    oNoStrict,
    oMangleDosFilenames,
    oNoMangleDosFilenames,
    oEnableProgressFilter,
    oMultifile,
    oKeyidFormat,
    oExitOnStatusWriteError,
    oLimitCardInsertTries,
    oReaderPort,
    octapiDriver,
    opcscDriver,
    oDisableCCID,
    oRequireCrossCert,
    oNoRequireCrossCert,
    oAutoKeyLocate,
    oNoAutoKeyLocate,
    oAllowMultisigVerification,
    oEnableLargeRSA,
    oDisableLargeRSA,
    oEnableDSA2,
    oDisableDSA2,
    oAllowMultipleMessages,
    oNoAllowMultipleMessages,
    oAllowWeakDigestAlgos,
    oWeakDigest,

    oNoop
  };


static ARGPARSE_OPTS opts[] = {

    { 300, ((void*)0), 0, ("@Commands:\n ") },

    { aSign, "sign", 256, ("|[file]|make a signature")},
    { aClearsign, "clearsign", 256, ("|[file]|make a clear text signature")},
    { aDetachedSign, "detach-sign", 256, ("make a detached signature")},
    { aEncr, "encrypt", 256, ("encrypt data")},
    { aEncrFiles, "encrypt-files", 256, "@"},
    { aSym, "symmetric", 256, ("encryption only with symmetric cipher")},
    { aStore, "store", 256, "@"},
    { aDecrypt, "decrypt", 256, ("decrypt data (default)")},
    { aDecryptFiles, "decrypt-files", 256, "@"},
    { aVerify, "verify" , 256, ("verify a signature")},
    { aVerifyFiles, "verify-files" , 256, "@" },
    { aListKeys, "list-keys", 256, ("list keys")},
    { aListKeys, "list-public-keys", 256, "@" },
    { aListSigs, "list-sigs", 256, ("list keys and signatures")},
    { aCheckKeys, "check-sigs",256, ("list and check key signatures")},
    { oFingerprint, "fingerprint", 256, ("list keys and fingerprints")},
    { aListSecretKeys, "list-secret-keys", 256, ("list secret keys")},
    { aKeygen, "gen-key", 256, ("generate a new key pair")},
    { aDeleteKeys,"delete-keys",256,("remove keys from the public keyring")},
    { aDeleteSecretKeys, "delete-secret-keys",256,
        ("remove keys from the secret keyring")},
    { aSignKey, "sign-key" ,256, ("sign a key")},
    { aLSignKey, "lsign-key" ,256, ("sign a key locally")},
    { aEditKey, "edit-key" ,256, ("sign or edit a key")},
    { aGenRevoke, "gen-revoke",256, ("generate a revocation certificate")},
    { aDesigRevoke, "desig-revoke",256, "@" },
    { aExport, "export" , 256, ("export keys") },
    { aSendKeys, "send-keys" , 256, ("export keys to a key server") },
    { aRecvKeys, "recv-keys" , 256, ("import keys from a key server") },
    { aSearchKeys, "search-keys" , 256,
                                    ("search for keys on a key server") },
    { aRefreshKeys, "refresh-keys", 256,
                                    ("update all keys from a keyserver")},
    { aFetchKeys, "fetch-keys" , 256, "@" },
    { aExportSecret, "export-secret-keys" , 256, "@" },
    { aExportSecretSub, "export-secret-subkeys" , 256, "@" },
    { aImport, "import", 256 , ("import/merge keys")},
    { aFastImport, "fast-import", 256 , "@"},

    { aCardStatus, "card-status", 256, ("print the card status")},
    { aCardEdit, "card-edit", 256, ("change data on a card")},
    { aChangePIN, "change-pin", 256, ("change a card's PIN")},

    { aListConfig, "list-config", 256, "@"},
    { aGPGConfList, "gpgconf-list", 256, "@" },
    { aGPGConfTest, "gpgconf-test", 256, "@" },
    { aListPackets, "list-packets",256, "@"},
    { aExportOwnerTrust, "export-ownertrust", 256, "@"},
    { aImportOwnerTrust, "import-ownertrust", 256, "@"},
    { aUpdateTrustDB,
       "update-trustdb",0 , ("update the trust database")},
    { aCheckTrustDB, "check-trustdb", 0, "@"},
    { aFixTrustDB, "fix-trustdb", 0, "@"},
    { aDeArmor, "dearmor", 256, "@"},
    { aDeArmor, "dearmour", 256, "@"},
    { aEnArmor, "enarmor", 256, "@"},
    { aEnArmor, "enarmour", 256, "@"},
    { aPrintMD, "print-md" , 256, ("|algo [files]|print message digests")},
    { aPrimegen, "gen-prime" , 256, "@" },
    { aGenRandom, "gen-random" , 256, "@" },

    { 301, ((void*)0), 0, ("@\nOptions:\n ") },

    { oArmor, "armor", 0, ("create ascii armored output")},
    { oArmor, "armour", 0, "@" },
    { oRecipient, "recipient", 2, ("|NAME|encrypt for NAME")},
    { oHiddenRecipient, "hidden-recipient", 2, "@" },
    { oRecipient, "remote-user", 2, "@"},
    { oDefRecipient, "default-recipient", 2, "@"},
    { oDefRecipientSelf, "default-recipient-self", 0, "@"},
    { oNoDefRecipient, "no-default-recipient", 0, "@" },
    { oTempDir, "temp-directory", 2, "@" },
    { oExecPath, "exec-path", 2, "@" },
    { oEncryptTo, "encrypt-to", 2, "@" },
    { oHiddenEncryptTo, "hidden-encrypt-to", 2, "@" },
    { oNoEncryptTo, "no-encrypt-to", 0, "@" },
    { oLocalUser, "local-user",2, ("use this user-id to sign or decrypt")},
    { oCompress, ((void*)0), 1, ("|N|set compress level N (0 disables)") },
    { oCompressLevel, "compress-level", 1, "@" },
    { oBZ2CompressLevel, "bzip2-compress-level", 1, "@" },
    { oBZ2DecompressLowmem, "bzip2-decompress-lowmem", 0, "@" },
    { oTextmodeShort, ((void*)0), 0, "@"},
    { oTextmode, "textmode", 0, ("use canonical text mode")},
    { oNoTextmode, "no-textmode", 0, "@"},
    { oExpert, "expert", 0, "@"},
    { oNoExpert, "no-expert", 0, "@"},
    { oDefSigExpire, "default-sig-expire", 2, "@"},
    { oAskSigExpire, "ask-sig-expire", 0, "@"},
    { oNoAskSigExpire, "no-ask-sig-expire", 0, "@"},
    { oDefCertExpire, "default-cert-expire", 2, "@"},
    { oAskCertExpire, "ask-cert-expire", 0, "@"},
    { oNoAskCertExpire, "no-ask-cert-expire", 0, "@"},
    { oDefCertLevel, "default-cert-level", 1, "@"},
    { oMinCertLevel, "min-cert-level", 1, "@"},
    { oAskCertLevel, "ask-cert-level", 0, "@"},
    { oNoAskCertLevel, "no-ask-cert-level", 0, "@"},
    { oOutput, "output", 2, ("use as output file")},
    { oMaxOutput, "max-output", 16|4, "@" },
    { oVerbose, "verbose", 0, ("verbose") },
    { oQuiet, "quiet", 0, "@"},
    { oNoTTY, "no-tty", 0, "@"},
    { oForceV3Sigs, "force-v3-sigs", 0, "@"},
    { oNoForceV3Sigs, "no-force-v3-sigs", 0, "@"},
    { oForceV4Certs, "force-v4-certs", 0, "@"},
    { oNoForceV4Certs, "no-force-v4-certs", 0, "@"},
    { oForceMDC, "force-mdc", 0, "@"},
    { oNoForceMDC, "no-force-mdc", 0, "@" },
    { oDisableMDC, "disable-mdc", 0, "@"},
    { oNoDisableMDC, "no-disable-mdc", 0, "@" },
    { oDryRun, "dry-run", 0, ("do not make any changes") },
    { oInteractive, "interactive", 0, ("prompt before overwriting") },
    { oUseAgent, "use-agent",0, "@"},
    { oNoUseAgent, "no-use-agent",0, "@"},
    { oGpgAgentInfo, "gpg-agent-info",2, "@"},
    { oBatch, "batch", 0, "@"},
    { oAnswerYes, "yes", 0, "@"},
    { oAnswerNo, "no", 0, "@"},
    { oKeyring, "keyring", 2, "@"},
    { oPrimaryKeyring, "primary-keyring",2, "@" },
    { oSecretKeyring, "secret-keyring", 2, "@"},
    { oShowKeyring, "show-keyring", 0, "@"},
    { oDefaultKey, "default-key", 2, "@"},
    { oKeyServer, "keyserver", 2, "@"},
    { oKeyServerOptions, "keyserver-options",2,"@"},
    { oImportOptions, "import-options",2,"@"},
    { oExportOptions, "export-options",2,"@"},
    { oListOptions, "list-options",2,"@"},
    { oVerifyOptions, "verify-options",2,"@"},
    { oDisplayCharset, "display-charset", 2, "@"},
    { oDisplayCharset, "charset", 2, "@"},
    { oOptions, "options", 2, "@"},
    { oDebug, "debug" ,4|16, "@"},
    { oDebugAll, "debug-all" ,0, "@"},
    { oDebugLevel, "debug-level" ,2, "@"},
    { oStatusFD, "status-fd" ,1, "@"},
    { oStatusFile, "status-file" ,2, "@"},
    { oAttributeFD, "attribute-fd" ,1, "@" },
    { oAttributeFile, "attribute-file" ,2, "@" },
    { oNoop, "sk-comments", 0, "@"},
    { oNoop, "no-sk-comments", 0, "@"},
    { oCompletesNeeded, "completes-needed", 1, "@"},
    { oMarginalsNeeded, "marginals-needed", 1, "@"},
    { oMaxCertDepth, "max-cert-depth", 1, "@" },
    { oTrustedKey, "trusted-key", 2, "@"},
    { oLoadExtension, "load-extension", 2, "@"},
    { oGnuPG, "gnupg", 0, "@"},
    { oGnuPG, "no-pgp2", 0, "@"},
    { oGnuPG, "no-pgp6", 0, "@"},
    { oGnuPG, "no-pgp7", 0, "@"},
    { oGnuPG, "no-pgp8", 0, "@"},
    { oRFC1991, "rfc1991", 0, "@"},
    { oRFC2440, "rfc2440", 0, "@" },
    { oRFC4880, "rfc4880", 0, "@" },
    { oOpenPGP, "openpgp", 0, ("use strict OpenPGP behavior")},
    { oPGP2, "pgp2", 0, ("generate PGP 2.x compatible messages")},
    { oPGP6, "pgp6", 0, "@"},
    { oPGP7, "pgp7", 0, "@"},
    { oPGP8, "pgp8", 0, "@"},
    { oRFC2440Text, "rfc2440-text", 0, "@"},
    { oNoRFC2440Text, "no-rfc2440-text", 0, "@"},
    { oS2KMode, "s2k-mode", 1, "@"},
    { oS2KDigest, "s2k-digest-algo", 2, "@"},
    { oS2KCipher, "s2k-cipher-algo", 2, "@"},
    { oS2KCount, "s2k-count", 1, "@"},
    { oSimpleSKChecksum, "simple-sk-checksum", 0, "@"},
    { oCipherAlgo, "cipher-algo", 2, "@"},
    { oDigestAlgo, "digest-algo", 2, "@"},
    { oCertDigestAlgo, "cert-digest-algo", 2 , "@" },
    { oCompressAlgo,"compress-algo", 2, "@"},
    { oCompressAlgo, "compression-algo", 2, "@"},
    { oThrowKeyids, "throw-keyid", 0, "@"},
    { oThrowKeyids, "throw-keyids", 0, "@"},
    { oNoThrowKeyids, "no-throw-keyid", 0, "@" },
    { oNoThrowKeyids, "no-throw-keyids", 0, "@" },
    { oShowPhotos, "show-photos", 0, "@" },
    { oNoShowPhotos, "no-show-photos", 0, "@" },
    { oPhotoViewer, "photo-viewer", 2, "@" },
    { oSetNotation, "set-notation", 2, "@" },
    { oSetNotation, "notation-data", 2, "@" },
    { oSigNotation, "sig-notation", 2, "@" },
    { oCertNotation, "cert-notation", 2, "@" },

    { 302, ((void*)0), 0, ("@\n(See the man page for a complete listing of all commands and options)\n")},



    { 303, ((void*)0), 0, ("@\nExamples:\n\n" " -se -r Bob [file]          sign and encrypt for user Bob\n" " --clearsign [file]         make a clear text signature\n" " --detach-sign [file]       make a detached signature\n" " --list-keys [names]        show keys\n" " --fingerprint [names]      show fingerprints\n") },







    { aListOwnerTrust, "list-ownertrust", 256, "@"},
    { aPrintMDs, "print-mds" , 256, "@"},
    { aListTrustDB, "list-trustdb",0 , "@"},


    { aPipeMode, "pipemode", 0, "@" },
    { oKOption, ((void*)0), 0, "@"},
    { oPasswd, "passphrase",2, "@" },
    { oPasswdFD, "passphrase-fd",1, "@" },
    { oPasswdFile, "passphrase-file",2, "@" },
    { oPasswdRepeat, "passphrase-repeat", 1, "@"},
    { oCommandFD, "command-fd",1, "@" },
    { oCommandFile, "command-file",2, "@" },
    { oQuickRandom, "quick-random", 0, "@"},
    { oNoVerbose, "no-verbose", 0, "@"},
    { oTrustDBName, "trustdb-name", 2, "@" },
    { oNoSecmemWarn, "no-secmem-warning", 0, "@" },
    { oRequireSecmem,"require-secmem", 0, "@" },
    { oNoRequireSecmem,"no-require-secmem", 0, "@" },
    { oNoPermissionWarn, "no-permission-warning", 0, "@" },
    { oNoMDCWarn, "no-mdc-warning", 0, "@" },
    { oNoArmor, "no-armor", 0, "@"},
    { oNoArmor, "no-armour", 0, "@"},
    { oNoDefKeyring, "no-default-keyring", 0, "@" },
    { oNoGreeting, "no-greeting", 0, "@" },
    { oNoOptions, "no-options", 0, "@" },
    { oHomedir, "homedir", 2, "@" },
    { oNoBatch, "no-batch", 0, "@" },
    { oWithColons, "with-colons", 0, "@"},
    { oWithKeyData,"with-key-data", 0, "@"},
    { aListKeys, "list-key", 0, "@" },
    { aListSigs, "list-sig", 0, "@" },
    { aCheckKeys, "check-sig",0, "@" },
    { oSkipVerify, "skip-verify",0, "@" },
    { oCompressKeys, "compress-keys",0, "@"},
    { oCompressSigs, "compress-sigs",0, "@"},
    { oDefCertLevel, "default-cert-check-level", 1, "@"},
    { oAlwaysTrust, "always-trust", 0, "@"},
    { oTrustModel, "trust-model", 2, "@"},
    { oForceOwnertrust, "force-ownertrust", 2, "@"},
    { oRunAsShmCP, "run-as-shm-coprocess", 4, "@" },
    { oSetFilename, "set-filename", 2, "@" },
    { oForYourEyesOnly, "for-your-eyes-only", 0, "@" },
    { oNoForYourEyesOnly, "no-for-your-eyes-only", 0, "@" },
    { oSetPolicyURL, "set-policy-url", 2, "@" },
    { oSigPolicyURL, "sig-policy-url", 2, "@" },
    { oCertPolicyURL, "cert-policy-url", 2, "@" },
    { oShowPolicyURL, "show-policy-url", 0, "@" },
    { oNoShowPolicyURL, "no-show-policy-url", 0, "@" },
    { oSigKeyserverURL, "sig-keyserver-url", 2, "@" },
    { oShowNotation, "show-notation", 0, "@" },
    { oNoShowNotation, "no-show-notation", 0, "@" },
    { oComment, "comment", 2, "@" },
    { oDefaultComment, "default-comment", 0, "@" },
    { oNoComments, "no-comments", 0, "@" },
    { oEmitVersion, "emit-version", 0, "@"},
    { oNoEmitVersion, "no-emit-version", 0, "@"},
    { oNoEmitVersion, "no-version", 0, "@"},
    { oNotDashEscaped, "not-dash-escaped", 0, "@" },
    { oEscapeFrom, "escape-from-lines", 0, "@" },
    { oNoEscapeFrom, "no-escape-from-lines", 0, "@" },
    { oLockOnce, "lock-once", 0, "@" },
    { oLockMultiple, "lock-multiple", 0, "@" },
    { oLockNever, "lock-never", 0, "@" },
    { oLoggerFD, "logger-fd",1, "@" },
    { oLoggerFile, "logger-file",2, "@" },
    { oUseEmbeddedFilename, "use-embedded-filename", 0, "@" },
    { oNoUseEmbeddedFilename, "no-use-embedded-filename", 0, "@" },
    { oUtf8Strings, "utf8-strings", 0, "@" },
    { oNoUtf8Strings, "no-utf8-strings", 0, "@" },
    { oWithFingerprint, "with-fingerprint", 0, "@" },
    { oDisableCipherAlgo, "disable-cipher-algo", 2, "@" },
    { oDisablePubkeyAlgo, "disable-pubkey-algo", 2, "@" },
    { oAllowNonSelfsignedUID, "allow-non-selfsigned-uid", 0, "@" },
    { oNoAllowNonSelfsignedUID, "no-allow-non-selfsigned-uid", 0, "@" },
    { oAllowFreeformUID, "allow-freeform-uid", 0, "@" },
    { oNoAllowFreeformUID, "no-allow-freeform-uid", 0, "@" },
    { oNoLiteral, "no-literal", 0, "@" },
    { oSetFilesize, "set-filesize", 20, "@" },
    { oHonorHttpProxy,"honor-http-proxy", 0, "@" },
    { oFastListMode,"fast-list-mode", 0, "@" },
    { oFixedListMode,"fixed-list-mode", 0, "@" },
    { oListOnly, "list-only", 0, "@"},
    { oIgnoreTimeConflict, "ignore-time-conflict", 0, "@" },
    { oIgnoreValidFrom, "ignore-valid-from", 0, "@" },
    { oIgnoreCrcError, "ignore-crc-error", 0,"@" },
    { oIgnoreMDCError, "ignore-mdc-error", 0,"@" },
    { oShowSessionKey, "show-session-key", 0, "@" },
    { oOverrideSessionKey, "override-session-key", 2, "@" },
    { oNoRandomSeedFile, "no-random-seed-file", 0, "@" },
    { oAutoKeyRetrieve, "auto-key-retrieve", 0, "@" },
    { oNoAutoKeyRetrieve, "no-auto-key-retrieve", 0, "@" },
    { oNoSigCache, "no-sig-cache", 0, "@" },
    { oNoop, "no-sig-create-check", 0, "@" },
    { oAutoCheckTrustDB, "auto-check-trustdb", 0, "@"},
    { oNoAutoCheckTrustDB, "no-auto-check-trustdb", 0, "@"},
    { oMergeOnly, "merge-only", 0, "@" },
    { oAllowSecretKeyImport, "allow-secret-key-import", 0, "@" },
    { oTryAllSecrets, "try-all-secrets", 0, "@" },
    { oEnableSpecialFilenames, "enable-special-filenames", 0, "@" },
    { oNoExpensiveTrustChecks, "no-expensive-trust-checks", 0, "@" },
    { aDeleteSecretAndPublicKeys, "delete-secret-and-public-keys",256, "@" },
    { aRebuildKeydbCaches, "rebuild-keydb-caches", 256, "@"},
    { oPreservePermissions, "preserve-permissions", 0, "@"},
    { oDefaultPreferenceList, "default-preference-list", 2, "@"},
    { oDefaultKeyserverURL, "default-keyserver-url", 2, "@"},
    { oPersonalCipherPreferences, "personal-cipher-preferences", 2, "@"},
    { oPersonalDigestPreferences, "personal-digest-preferences", 2, "@"},
    { oPersonalCompressPreferences, "personal-compress-preferences", 2, "@"},
    { oWeakDigest, "weak-digest", 2, "@"},


    { oPersonalCipherPreferences, "personal-cipher-prefs", 2, "@"},
    { oPersonalDigestPreferences, "personal-digest-prefs", 2, "@"},
    { oPersonalCompressPreferences, "personal-compress-prefs", 2, "@"},
    { oDisplay, "display", 2, "@" },
    { oTTYname, "ttyname", 2, "@" },
    { oTTYtype, "ttytype", 2, "@" },
    { oLCctype, "lc-ctype", 2, "@" },
    { oLCmessages, "lc-messages", 2, "@" },
    { oGroup, "group", 2, "@" },
    { oUnGroup, "ungroup", 2, "@" },
    { oNoGroups, "no-groups", 0, "@" },
    { oStrict, "strict", 0, "@" },
    { oNoStrict, "no-strict", 0, "@" },
    { oMangleDosFilenames, "mangle-dos-filenames", 0, "@" },
    { oNoMangleDosFilenames, "no-mangle-dos-filenames", 0, "@" },
    { oEnableProgressFilter, "enable-progress-filter", 0, "@" },
    { oMultifile, "multifile", 0, "@" },
    { oKeyidFormat, "keyid-format", 2, "@" },
    { oExitOnStatusWriteError, "exit-on-status-write-error", 0, "@" },
    { oLimitCardInsertTries, "limit-card-insert-tries", 1, "@"},

    { oReaderPort, "reader-port", 2, "@"},
    { octapiDriver, "ctapi-driver", 2, "@"},
    { opcscDriver, "pcsc-driver", 2, "@"},
    { oDisableCCID, "disable-ccid", 0, "@"},



    { oAllowMultisigVerification, "allow-multisig-verification", 0, "@"},
    { oEnableLargeRSA, "enable-large-rsa", 0, "@"},
    { oDisableLargeRSA, "disable-large-rsa", 0, "@"},
    { oEnableDSA2, "enable-dsa2", 0, "@"},
    { oDisableDSA2, "disable-dsa2", 0, "@"},
    { oAllowMultipleMessages, "allow-multiple-messages", 0, "@"},
    { oNoAllowMultipleMessages, "no-allow-multiple-messages", 0, "@"},
    { oAllowWeakDigestAlgos, "allow-weak-digest-algos", 0, "@"},





    { oLocalUser, "sign-with", 2, "@" },
    { oRecipient, "user", 2, "@" },
    { oRequireCrossCert, "require-backsigs", 0, "@"},
    { oRequireCrossCert, "require-cross-certification", 0, "@"},
    { oNoRequireCrossCert, "no-require-backsigs", 0, "@"},
    { oNoRequireCrossCert, "no-require-cross-certification", 0, "@"},
    { oAutoKeyLocate, "auto-key-locate", 2, "@"},
    { oNoAutoKeyLocate, "no-auto-key-locate", 0, "@"},


    { oNoop, "with-subkey-fingerprint", 0, "@" },


    {0,((void*)0),0,((void*)0)}
};
# 761 "gpg.c"
int g10_errors_seen = 0;

static int utf8_strings = 0;
static int maybe_setuid = 1;

static char *build_list( const char *text, char letter,
    const char *(*mapf)(int), int (*chkf)(int) );
static void set_cmd( enum cmd_and_opt_values *ret_cmd,
   enum cmd_and_opt_values new_cmd );
static void print_mds( const char *fname, int algo );
static void add_notation_data( const char *string, int which );
static void add_policy_url( const char *string, int which );
static void add_keyserver_url( const char *string, int which );

const char *
strusage( int level )
{
  static char *digests, *pubkeys, *ciphers, *zips;
    const char *p;
    switch( level ) {
      case 11: p = "gpg (GnuPG)";
 break;
      case 13: p = "1.4.23"; break;
      case 17: p = "GNU/Linux"; break;
      case 19: p =
     gettext ("Please report bugs to <gnupg-bugs@gnu.org>.\n");
 break;
# 801 "gpg.c"
      case 1:
      case 40: p =
     gettext ("Usage: gpg [options] [files] (-h for help)");
 break;
      case 41: p =
     gettext ("Syntax: gpg [options] [files]\n" "Sign, check, encrypt or decrypt\n" "Default operation depends on the input data\n");


 break;

      case 31: p = "\nHome: "; break;

      case 32: p = opt.homedir; break;



      case 33: p = gettext ("\nSupported algorithms:\n"); break;
      case 34:
 if( !pubkeys )
     pubkeys = build_list(gettext ("Pubkey: "), 0, pubkey_algo_to_string,
       check_pubkey_algo );
 p = pubkeys;
 break;
      case 35:
 if( !ciphers )
     ciphers = build_list(gettext ("Cipher: "), 'S', cipher_algo_to_string,
       check_cipher_algo );
 p = ciphers;
 break;
      case 36:
 if( !digests )
     digests = build_list(gettext ("Hash: "), 'H', digest_algo_to_string,
       check_digest_algo );
 p = digests;
 break;
      case 37:
 if( !zips )
     zips = build_list(gettext ("Compression: "),'Z',compress_algo_to_string,
                                   check_compress_algo);
 p = zips;
 break;

      default: p = default_strusage(level);
    }
    return p;
}


static char *
build_list (const char *text, char letter,
     const char * (*mapf)(int), int (*chkf)(int))
{
  membuf_t mb;
  int indent;
  int i, j, len;
  const char *s;
  char *string;

  if (maybe_setuid)
    secmem_init (0);

  indent = strlen (text);
  len = 0;
  init_membuf (&mb, 512);

  for (i=0; i <= 110; i++ )
    {
      if (!chkf (i) && (s = mapf (i)))
        {
          if (mb.len - len > 60)
            {
              put_membuf_str (&mb, ",\n");
              len = mb.len;
              for (j=0; j < indent; j++)
                put_membuf_str (&mb, " ");
     }
          else if (mb.len)
            put_membuf_str (&mb, ", ");
          else
            put_membuf_str (&mb, text);

          put_membuf_str (&mb, s);
          if (opt.verbose && letter)
            {
              char num[20];
              snprintf (num, sizeof num, " (%c%d)", letter, i);
              put_membuf_str (&mb, num);
            }
 }
    }
  if (mb.len)
    put_membuf_str (&mb, "\n");
  put_membuf (&mb, "", 1);

  string = get_membuf (&mb, ((void*)0));
  return xrealloc (string, strlen (string)+1);
}


static void
i18n_init(void)
{




    setlocale( 6, "" );
    bindtextdomain ("gnupg", "/home/yang/wasm/gnupg-1.4.23/prefix/share/locale");
    textdomain( "gnupg" );


}

static void
wrong_args( const char *text)
{
    fputs(gettext ("usage: gpg [options] "),(stderr));
    fputs(text,(stderr));
    putc('\n',(stderr));
    g10_exit(2);
}


static char *
make_username( const char *string )
{
    char *p;
    if( utf8_strings )
 p = xstrdup(string);
    else
 p = native_to_utf8( string );
    return p;
}


static void
set_debug(void)
{
    if( opt.debug & 32 )
 memory_debug_mode = 1;
    if( opt.debug & 128 )
 memory_stat_debug_mode = 1;
    if( opt.debug & 2 )
 mpi_debug_mode = 1;
    if( opt.debug & 4 )
 g10c_debug_mode = 1;
    if( opt.debug & 16 )
 iobuf_debug_mode = 1;

}




static void
set_homedir (char *dir)
{
  if (!dir)
    dir = "";
  g10_opt_homedir = opt.homedir = dir;
}




static void
set_screen_dimensions(void)
{

  char *str;

  str=getenv("COLUMNS");
  if(str)
    opt.screen_columns=atoi(str);

  str=getenv("LINES");
  if(str)
    opt.screen_lines=atoi(str);


  if(opt.screen_columns<80 || opt.screen_columns>255)
    opt.screen_columns=80;

  if(opt.screen_lines<24 || opt.screen_lines>255)
    opt.screen_lines=24;
}







static int
open_info_file (const char *fname, int for_write)
{
# 1007 "gpg.c"
  int fd;
# 1016 "gpg.c"
      do
        {
          if (for_write)
            fd = open (fname, 0100 | 01000 | 01,
                        0400 | 0200 | 0040 | 0020);
          else
            fd = open (fname, 00 | 0);
        }
      while (fd == -1 && (*__errno_location()) == (27));

  if ( fd == -1)
    g10_log_error ( for_write? gettext ("can't create `%s': %s\n")
                         : gettext ("can't open `%s': %s\n"), fname, strerror((*__errno_location())));

  return fd;

}

static void
set_cmd( enum cmd_and_opt_values *ret_cmd, enum cmd_and_opt_values new_cmd )
{
    enum cmd_and_opt_values cmd = *ret_cmd;

    if( !cmd || cmd == new_cmd )
 cmd = new_cmd;
    else if( cmd == aSign && new_cmd == aEncr )
 cmd = aSignEncr;
    else if( cmd == aEncr && new_cmd == aSign )
 cmd = aSignEncr;
    else if( cmd == aSign && new_cmd == aSym )
 cmd = aSignSym;
    else if( cmd == aSym && new_cmd == aSign )
 cmd = aSignSym;
    else if( cmd == aSym && new_cmd == aEncr )
 cmd = aEncrSym;
    else if( cmd == aEncr && new_cmd == aSym )
 cmd = aEncrSym;
    else if( cmd == aKMode && new_cmd == aSym )
 cmd = aKModeC;
    else if (cmd == aSignEncr && new_cmd == aSym)
        cmd = aSignEncrSym;
    else if (cmd == aSignSym && new_cmd == aEncr)
        cmd = aSignEncrSym;
    else if (cmd == aEncrSym && new_cmd == aSign)
        cmd = aSignEncrSym;
    else if( ( cmd == aSign && new_cmd == aClearsign )
      || ( cmd == aClearsign && new_cmd == aSign ) )
 cmd = aClearsign;
    else {
 g10_log_error(gettext ("conflicting commands\n"));
 g10_exit(2);
    }

    *ret_cmd = cmd;
}


static void
add_group(char *string)
{
  char *name,*value;
  struct groupitem *item;


  name=strsep(&string,"=");
  if(string==((void*)0))
    {
      g10_log_error(gettext ("no = sign found in group definition `%s'\n"),name);
      return;
    }

  trim_trailing_ws(name,strlen(name));


  for(item=opt.grouplist;item;item=item->next)
    if(strcasecmp(item->name,name)==0)
      break;

  if(!item)
    {
      item=xmalloc(sizeof(struct groupitem));
      item->name=name;
      item->next=opt.grouplist;
      item->values=((void*)0);
      opt.grouplist=item;
    }


  while ((value= strsep(&string," \t")))
    {
      if (*value)
        add_to_strlist2(&item->values,value,utf8_strings);
    }
}


static void
rm_group(char *name)
{
  struct groupitem *item,*last=((void*)0);

  trim_trailing_ws(name,strlen(name));

  for(item=opt.grouplist;item;last=item,item=item->next)
    {
      if(strcasecmp(item->name,name)==0)
 {
   if(last)
     last->next=item->next;
   else
     opt.grouplist=item->next;

   free_strlist(item->values);
   xfree(item);
   break;
 }
    }
}
# 1146 "gpg.c"
static int
check_permissions(const char *path,int item)
{

  static int homedir_cache=-1;
  char *tmppath,*dir;
  struct stat statbuf,dirbuf;
  int homedir=0,ret=0,checkonly=0;
  int perm=0,own=0,enc_dir_perm=0,enc_dir_own=0;

  if(opt.no_perm_warn)
    return 0;

  ((void)((item==0 || item==1 || item==2) || (__assert_fail("item==0 || item==1 || item==2", "gpg.c", 1159, __func__),0)));

  tmppath=xstrdup(path);






  if(item!=0 && homedir_cache>-1
     && ascii_strncasecmp(opt.homedir,tmppath,strlen(opt.homedir))==0)
    {
      ret=homedir_cache;
      goto end;
    }


  if(stat(tmppath,&statbuf)!=0)
    {
      ret=0;
      goto end;
    }




  dir=make_dirname(tmppath);

  if(stat(dir,&dirbuf)!=0 || !(((dirbuf.st_mode) & 0170000) == 0040000))
    {

      ret=1;
      goto end;
    }

  xfree(dir);


  ret=1;

  if(item==0)
    {


      if((((statbuf.st_mode) & 0170000) == 0040000))
 {
   if(statbuf.st_uid==getuid())
     {
       if((statbuf.st_mode & (0070|0007))==0)
  ret=0;
       else
  perm=1;
     }
   else
     own=1;

   homedir_cache=ret;
 }
    }
  else if(item==1)
    {




      if((((statbuf.st_mode) & 0170000) == 0100000))
 {
   if(statbuf.st_uid==getuid() || statbuf.st_uid==0)
     {
       if((statbuf.st_mode & (0020|0002))==0)
  {


    if(dirbuf.st_uid==getuid() || dirbuf.st_uid==0)
      {
        if((dirbuf.st_mode & (0020|0002))==0)
   ret=0;
        else
   enc_dir_perm=1;
      }
    else
      enc_dir_own=1;
  }
       else
  {


    if(dirbuf.st_uid==getuid() || dirbuf.st_uid==0)
      {
        if((dirbuf.st_mode & (0070|0007))==0)
   ret=0;
        else
   perm=enc_dir_perm=1;
      }
    else
      enc_dir_own=1;
  }
     }
   else
     own=1;
 }
    }
  else
    g10_log_bug0( "gpg.c" , 1262, __FUNCTION__ );

  if(!checkonly)
    {
      if(own)
 {
   if(item==0)
     g10_log_info(gettext ("WARNING: unsafe ownership on" " homedir `%s'\n"),tmppath);

   else
     g10_log_info(gettext ("WARNING: unsafe ownership on" " configuration file `%s'\n"),tmppath);

 }
      if(perm)
 {
   if(item==0)
     g10_log_info(gettext ("WARNING: unsafe permissions on" " homedir `%s'\n"),tmppath);

   else
     g10_log_info(gettext ("WARNING: unsafe permissions on" " configuration file `%s'\n"),tmppath);

 }
      if(enc_dir_own)
 {
   if(item==0)
     g10_log_info(gettext ("WARNING: unsafe enclosing directory ownership on" " homedir `%s'\n"),tmppath);

   else
     g10_log_info(gettext ("WARNING: unsafe enclosing directory ownership on" " configuration file `%s'\n"),tmppath);

 }
      if(enc_dir_perm)
 {
   if(item==0)
     g10_log_info(gettext ("WARNING: unsafe enclosing directory permissions on" " homedir `%s'\n"),tmppath);

   else
     g10_log_info(gettext ("WARNING: unsafe enclosing directory permissions on" " configuration file `%s'\n"),tmppath);

 }
    }

 end:
  xfree(tmppath);

  if(homedir)
    homedir_cache=ret;

  return ret;



  return 0;
}

static void
print_algo_numbers(int (*checker)(int))
{
  int i,first=1;

  for(i=0;i<=110;i++)
    {
      if(!checker(i))
 {
   if(first)
     first=0;
   else
     printf(";");
   printf("%d",i);
 }
    }
}

static void
print_algo_names(int (*checker)(int),const char *(*mapper)(int))
{
  int i,first=1;

  for(i=0;i<=110;i++)
    {
      if(!checker(i))
 {
   if(first)
     first=0;
   else
     printf(";");
   printf("%s",mapper(i));
 }
    }
}





static void
list_config(char *items)
{
  int show_all=(items==((void*)0));
  char *name=((void*)0);

  if(!opt.with_colons)
    return;

  while(show_all || (name=strsep(&items," ")))
    {
      int any=0;

      if(show_all || ascii_strcasecmp(name,"group")==0)
 {
   struct groupitem *iter;

   for(iter=opt.grouplist;iter;iter=iter->next)
     {
       STRLIST sl;

       printf("cfg:group:");
       print_string((stdout),iter->name,strlen(iter->name),':');
       printf(":");

       for(sl=iter->values;sl;sl=sl->next)
  {
    print_string2((stdout),sl->d,strlen(sl->d),':',';');
    if(sl->next)
      printf(";");
  }

       printf("\n");
     }

   any=1;
 }

      if(show_all || ascii_strcasecmp(name,"version")==0)
 {
   printf("cfg:version:");
   print_string((stdout),"1.4.23",strlen("1.4.23"),':');
   printf("\n");
   any=1;
 }

      if(show_all || ascii_strcasecmp(name,"pubkey")==0)
 {
   printf("cfg:pubkey:");
   print_algo_numbers(check_pubkey_algo);
   printf("\n");
   any=1;
 }

      if(show_all || ascii_strcasecmp(name,"cipher")==0)
 {
   printf("cfg:cipher:");
   print_algo_numbers(check_cipher_algo);
   printf("\n");
   any=1;
 }

      if(show_all || ascii_strcasecmp(name,"ciphername")==0)
 {
   printf("cfg:ciphername:");
   print_algo_names(check_cipher_algo,cipher_algo_to_string);
   printf("\n");
   any=1;
 }

      if(show_all
  || ascii_strcasecmp(name,"digest")==0
  || ascii_strcasecmp(name,"hash")==0)
 {
   printf("cfg:digest:");
   print_algo_numbers(check_digest_algo);
   printf("\n");
   any=1;
 }

      if(show_all
  || ascii_strcasecmp(name,"digestname")==0
  || ascii_strcasecmp(name,"hashname")==0)
 {
   printf("cfg:digestname:");
   print_algo_names(check_digest_algo,digest_algo_to_string);
   printf("\n");
   any=1;
 }

      if(show_all || ascii_strcasecmp(name,"compress")==0)
 {
   printf("cfg:compress:");
   print_algo_numbers(check_compress_algo);
   printf("\n");
   any=1;
 }

      if(show_all || ascii_strcasecmp(name,"ccid-reader-id")==0)
 {
# 1467 "gpg.c"
   any=1;
 }

      if(show_all)
 break;

      if(!any)
 g10_log_error(gettext ("unknown configuration item `%s'\n"),name);
    }
}







static void
gpgconf_list (const char *configfile)
{




  printf ("gpgconf-gpg.conf:%lu:\"%s\n",
          (1UL << 4),configfile?configfile:"/dev/null");
  printf ("verbose:%lu:\n", 0UL);
  printf ("quiet:%lu:\n", 0UL);
  printf ("keyserver:%lu:\n", 0UL);
  printf ("reader-port:%lu:\n", 0UL);
}


static int
parse_subpacket_list(char *list)
{
  char *tok;
  byte subpackets[128],i;
  int count=0;

  if(!list)
    {

      memset(subpackets+1,1,sizeof(subpackets)-1);
      count=127;
    }
  else
    {
      memset(subpackets,0,sizeof(subpackets));


      if(opt.show_subpackets)
 {
   byte *in;

   for(in=opt.show_subpackets;*in;in++)
     {
       if(*in>127 || *in<1)
  g10_log_bug0( "gpg.c" , 1525, __FUNCTION__ );

       if(!subpackets[*in])
  count++;
       subpackets[*in]=1;
     }
 }

      while((tok=strsep(&list," ,")))
 {
   if(!*tok)
     continue;

   i=atoi(tok);
   if(i>127 || i<1)
     return 0;

   if(!subpackets[i])
     count++;
   subpackets[i]=1;
 }
    }

  xfree(opt.show_subpackets);
  opt.show_subpackets=xmalloc(count+1);
  opt.show_subpackets[count--]=0;

  for(i=1;i<128 && count>=0;i++)
    if(subpackets[i])
      opt.show_subpackets[count--]=i;

  return 1;
}


static int
parse_list_options(char *str)
{
  char *subpackets="";
  struct parse_options lopts[]=
    {
      {"show-photos",(1<<0),((void*)0),
       ("display photo IDs during key listings")},
      {"show-policy-urls",(1<<1),((void*)0),
       ("show policy URLs during signature listings")},
      {"show-notations",((1<<2)|(1<<3)),((void*)0),
       ("show all notations during signature listings")},
      {"show-std-notations",(1<<2),((void*)0),
       ("show IETF standard notations during signature listings")},
      {"show-standard-notations",(1<<2),((void*)0),
       ((void*)0)},
      {"show-user-notations",(1<<3),((void*)0),
       ("show user-supplied notations during signature listings")},
      {"show-keyserver-urls",(1<<4),((void*)0),
       ("show preferred keyserver URLs during signature listings")},
      {"show-uid-validity",(1<<5),((void*)0),
       ("show user ID validity during key listings")},
      {"show-unusable-uids",(1<<6),((void*)0),
       ("show revoked and expired user IDs in key listings")},
      {"show-unusable-subkeys",(1<<7),((void*)0),
       ("show revoked and expired subkeys in key listings")},
      {"show-keyring",(1<<8),((void*)0),
       ("show the keyring name in key listings")},
      {"show-sig-expire",(1<<9),((void*)0),
       ("show expiration dates during signature listings")},
      {"show-sig-subpackets",(1<<10),((void*)0),
       ((void*)0)},
      {((void*)0),0,((void*)0),((void*)0)}
    };





  lopts[12].value=&subpackets;

  if(parse_options(str,&opt.list_options,lopts,1))
    {
      if(opt.list_options&(1<<10))
 {

   opt.list_options&=~(1<<10);
   if(!parse_subpacket_list(subpackets))
     return 0;
 }
      else if(subpackets==((void*)0) && opt.show_subpackets)
 {

   xfree(opt.show_subpackets);
   opt.show_subpackets=((void*)0);
 }

      return 1;
    }
  else
    return 0;
}



static char *
collapse_args(int argc,char *argv[])
{
  char *str=((void*)0);
  int i,first=1,len=0;

  for(i=0;i<argc;i++)
    {
      len+=strlen(argv[i])+2;
      str=xrealloc(str,len);
      if(first)
 {
   str[0]='\0';
   first=0;
 }
      else
 strcat(str," ");

      strcat(str,argv[i]);
    }

  return str;
}

static void
parse_trust_model(const char *model)
{
  if(ascii_strcasecmp(model,"pgp")==0)
    opt.trust_model=TM_PGP;
  else if(ascii_strcasecmp(model,"classic")==0)
    opt.trust_model=TM_CLASSIC;
  else if(ascii_strcasecmp(model,"always")==0)
    opt.trust_model=TM_ALWAYS;
  else if(ascii_strcasecmp(model,"direct")==0)
    opt.trust_model=TM_DIRECT;
  else if(ascii_strcasecmp(model,"auto")==0)
    opt.trust_model=TM_AUTO;
  else
    g10_log_error("unknown trust model `%s'\n",model);
}


static void
reopen_std(void)
{

  struct stat statbuf;
  int did_stdin=0,did_stdout=0,did_stderr=0;
  FILE *complain;

  if(fstat(0,&statbuf)==-1 && (*__errno_location())==(8))
    {
      if(open("/dev/null",00)==0)
 did_stdin=1;
      else
 did_stdin=2;
    }

  if(fstat(1,&statbuf)==-1 && (*__errno_location())==(8))
    {
      if(open("/dev/null",01)==1)
 did_stdout=1;
      else
 did_stdout=2;
    }

  if(fstat(2,&statbuf)==-1 && (*__errno_location())==(8))
    {
      if(open("/dev/null",01)==2)
 did_stderr=1;
      else
 did_stderr=2;
    }



  if(did_stderr==0)
    complain=(stderr);
  else if(did_stdout==0)
    complain=(stdout);
  else
    complain=((void*)0);

  if(complain)
    {
      if(did_stdin==1)
 fprintf(complain,"gpg: WARNING: standard input reopened\n");
      if(did_stdout==1)
 fprintf(complain,"gpg: WARNING: standard output reopened\n");
      if(did_stderr==1)
 fprintf(complain,"gpg: WARNING: standard error reopened\n");

      if(did_stdin==2 || did_stdout==2 || did_stderr==2)
 fprintf(complain,"gpg: fatal: unable to reopen standard input,"
  " output, or error\n");
    }

  if(did_stdin==2 || did_stdout==2 || did_stderr==2)
    exit(3);

}



static unsigned char
encode_s2k_iterations(int iterations)
{
  unsigned char c=0,result;
  unsigned int count;

  if(iterations<=1024)
    return 0;

  if(iterations>=65011712)
    return 255;


  for(count=iterations>>6;count>=32;count>>=1)
    c++;

  result=(c<<4)|(count-16);

  if(((16ul + ((result) & 15)) << (((result) >> 4) + 6))<iterations)
    result++;

  return result;
}


char *
get_default_configname (void)
{
  char *configname = ((void*)0);
  char *name = xstrdup ("gpg" "." "conf-" "1.4.23");
  char *ver = &name[strlen ("gpg" "." "conf-")];

  do
    {
      if (configname)
 {
   char *tok;

   xfree (configname);
   configname = ((void*)0);

   if ((tok = strrchr (ver, '-')))
     *tok='\0';
   else if ((tok = strrchr (ver, '.')))
     *tok='\0';
   else
     break;
 }

      configname = make_filename (opt.homedir, name, ((void*)0));
    }
  while (access (configname, 4));

  xfree(name);

  if (! configname)
    configname = make_filename (opt.homedir, "gpg" "." "conf", ((void*)0));
  if (! access (configname, 4))
    {

      char *p = make_filename (opt.homedir, "options", ((void*)0));
      if (! access (p, 4))
 g10_log_info (gettext ("NOTE: old default options file `%s' ignored\n"), p);
      xfree (p);
    }
  else
    {

      char *p = make_filename (opt.homedir, "options", ((void*)0));
      if (!access (p, 4))
 {
   xfree (configname);
   configname = p;
 }
      else
 xfree (p);
    }

  return configname;
}



int
main (int argc, char **argv )
{
    ARGPARSE_ARGS pargs;
    IOBUF a;
    int rc=0;
    int orig_argc;
    char **orig_argv;
    const char *fname;
    char *username;
    int may_coredump;
    STRLIST sl, remusr= ((void*)0), locusr=((void*)0);
    STRLIST nrings=((void*)0), sec_nrings=((void*)0);
    armor_filter_context_t afx;
    int detached_sig = 0;
    FILE *configfp = ((void*)0);
    char *configname = ((void*)0);
    char *save_configname = ((void*)0);
    char *default_configname = ((void*)0);
    unsigned configlineno;
    int parse_debug = 0;
    int default_config = 1;
    int default_keyring = 1;
    int greeting = 0;
    int nogreeting = 0;
    int use_random_seed = 1;
    enum cmd_and_opt_values cmd = 0;
    const char *trustdb_name = ((void*)0);
    char *def_cipher_string = ((void*)0);
    char *def_digest_string = ((void*)0);
    char *compress_algo_string = ((void*)0);
    char *cert_digest_string = ((void*)0);
    char *s2k_cipher_string = ((void*)0);
    char *s2k_digest_string = ((void*)0);
    char *pers_cipher_list = ((void*)0);
    char *pers_digest_list = ((void*)0);
    char *pers_compress_list = ((void*)0);
    int eyes_only=0;
    int multifile=0;
    int pwfd = -1;
    int fpr_maybe_cmd = 0;
    int any_explicit_recipient = 0;
    int require_secmem=0,got_secmem=0;

    ulong requested_shm_size=0;
# 1872 "gpg.c"
    reopen_std();
    trap_unaligned();
    secmem_set_flags( secmem_get_flags() | 2 );




    log_set_name("gpg");
    secure_randoxmalloc();
    may_coredump = disable_core_dumps();
    init_signals();
    dotlock_create (((void*)0), 0);
    i18n_init();
    opt.command_fd = -1;
    opt.compress_level = -1;
    opt.bz2_compress_level = -1;

    opt.def_cipher_algo = 0;
    opt.def_digest_algo = 0;
    opt.cert_digest_algo = 0;
    opt.compress_algo = -1;
    opt.s2k_mode = 3;
    opt.s2k_count = 96;
    opt.s2k_cipher_algo = 7;
    opt.completes_needed = 1;
    opt.marginals_needed = 3;
    opt.max_cert_depth = 5;
    opt.pgp2_workarounds = 1;
    opt.escape_from = 1;
    opt.flags.require_cross_cert = 1;
    opt.import_options=(1<<3);
    opt.export_options=(1<<1);
    opt.keyserver_options.import_options=(1<<1);
    opt.keyserver_options.export_options=(1<<1);
    opt.keyserver_options.options=
      (1<<4)|(1<<5);
    opt.verify_options=
      (1<<1)|(1<<2)|(1<<4);
    opt.trust_model=TM_AUTO;
    opt.mangle_dos_filenames=0;
    opt.min_cert_level=2;
    set_screen_dimensions();
    opt.keyid_format=KF_SHORT;
    opt.def_sig_expire="0";
    opt.def_cert_expire="0";
    set_homedir ( default_homedir () );
    opt.passwd_repeat=1;
    opt.emit_version = 0;
# 1929 "gpg.c"
    opt.pcsc_driver = "libpcsclite.so";

    opt.disable_keypad = 1;

    opt.weak_digests = ((void*)0);
    additional_weak_digest("MD5");


    orig_argc = argc;
    orig_argv = argv;
    pargs.argc = &argc;
    pargs.argv = &argv;
    pargs.flags= 1|(1<<6);
    while( arg_parse( &pargs, opts) ) {
 if( pargs.r_opt == oDebug || pargs.r_opt == oDebugAll )
     parse_debug++;
 else if( pargs.r_opt == oOptions ) {



     default_config = 0;
 }
 else if( pargs.r_opt == oNoOptions )
          {
     default_config = 0;
            opt.no_homedir_creation = 1;
          }
 else if( pargs.r_opt == oHomedir )
     set_homedir ( pargs.r.ret_str );
 else if( pargs.r_opt == oNoPermissionWarn )
     opt.no_perm_warn=1;
 else if (pargs.r_opt == oStrict )
   {
     opt.strict=1;
     log_set_strict(1);
   }
 else if (pargs.r_opt == oNoStrict )
   {
     opt.strict=0;
     log_set_strict(0);
   }

 else if( pargs.r_opt == oRunAsShmCP ) {


     opt.shm_coprocess = 1;
     requested_shm_size = pargs.r.ret_ulong;
 }
 else if ( pargs.r_opt == oStatusFD ) {


     set_status_fd( iobuf_translate_file_handle (pargs.r.ret_int, 1) );
 }

    }
# 2002 "gpg.c"
    if( opt.shm_coprocess ) {
 init_shm_coprocessing(requested_shm_size, 1 );
    }


    got_secmem=secmem_init( 32768 );
    maybe_setuid = 0;





    if ( getuid () != geteuid () )
      g10_log_bug0( "gpg.c" , 2015, __FUNCTION__ );


    set_native_charset (((void*)0));


    default_configname = get_default_configname ();
    if (default_config)
      configname = xstrdup (default_configname);

    argc = orig_argc;
    argv = orig_argv;
    pargs.argc = &argc;
    pargs.argv = &argv;
    pargs.flags= 1;


    check_permissions(opt.homedir,0);

  next_pass:
    if( configname ) {
      if(check_permissions(configname,1))
 {






   opt.exec_disable=1;
 }

 configlineno = 0;
 configfp = fopen( configname, "r" );
        if (configfp && is_secured_file (fileno (configfp)))
          {
            fclose (configfp);
            configfp = ((void*)0);
            (*__errno_location()) = (63);
          }
 if( !configfp ) {
     if( default_config ) {
  if( parse_debug )
      g10_log_info(gettext ("NOTE: no default option file `%s'\n"),
           configname );
     }
     else {
  g10_log_error(gettext ("option file `%s': %s\n"),
        configname, strerror((*__errno_location())) );
  g10_exit(2);
     }
     xfree(configname); configname = ((void*)0);
 }
 if( parse_debug && configname )
     g10_log_info(gettext ("reading options from `%s'\n"), configname );
 default_config = 0;
    }

    while( optfile_parse( configfp, configname, &configlineno,
      &pargs, opts) )
      {
 switch( pargs.r_opt )
   {
   case aCheckKeys:
   case aListConfig:
          case aGPGConfList:
          case aGPGConfTest:
   case aListPackets:
   case aImport:
   case aFastImport:
   case aSendKeys:
   case aRecvKeys:
   case aSearchKeys:
   case aRefreshKeys:
   case aFetchKeys:
   case aExport:
            set_cmd (&cmd, pargs.r_opt);
            break;
   case aListKeys: set_cmd( &cmd, aListKeys); break;
   case aListSigs: set_cmd( &cmd, aListSigs); break;
   case aExportSecret: set_cmd( &cmd, aExportSecret); break;
   case aExportSecretSub: set_cmd( &cmd, aExportSecretSub); break;
   case aDeleteSecretKeys:
     set_cmd( &cmd, aDeleteSecretKeys);
     greeting=1;
     break;
   case aDeleteSecretAndPublicKeys:
            set_cmd( &cmd, aDeleteSecretAndPublicKeys);
            greeting=1;
            break;
   case aDeleteKeys: set_cmd( &cmd, aDeleteKeys); greeting=1; break;

   case aDetachedSign: detached_sig = 1; set_cmd( &cmd, aSign ); break;
   case aSym: set_cmd( &cmd, aSym); break;

   case aDecryptFiles: multifile=1;
   case aDecrypt: set_cmd( &cmd, aDecrypt); break;

   case aEncrFiles: multifile=1;
   case aEncr: set_cmd( &cmd, aEncr); break;

   case aVerifyFiles: multifile=1;
   case aVerify: set_cmd( &cmd, aVerify); break;

   case aSign: set_cmd( &cmd, aSign ); break;
   case aKeygen: set_cmd( &cmd, aKeygen); greeting=1; break;
   case aSignKey: set_cmd( &cmd, aSignKey); break;
   case aLSignKey: set_cmd( &cmd, aLSignKey); break;
   case aStore: set_cmd( &cmd, aStore); break;
   case aEditKey: set_cmd( &cmd, aEditKey); greeting=1; break;
   case aClearsign: set_cmd( &cmd, aClearsign); break;
   case aGenRevoke: set_cmd( &cmd, aGenRevoke); break;
   case aDesigRevoke: set_cmd( &cmd, aDesigRevoke); break;
   case aPrimegen: set_cmd( &cmd, aPrimegen); break;
   case aGenRandom: set_cmd( &cmd, aGenRandom); break;
   case aPrintMD: set_cmd( &cmd, aPrintMD); break;
   case aPrintMDs: set_cmd( &cmd, aPrintMDs); break;
   case aListTrustDB: set_cmd( &cmd, aListTrustDB); break;
   case aCheckTrustDB: set_cmd( &cmd, aCheckTrustDB); break;
   case aUpdateTrustDB: set_cmd( &cmd, aUpdateTrustDB); break;
   case aFixTrustDB: set_cmd( &cmd, aFixTrustDB); break;
   case aListTrustPath: set_cmd( &cmd, aListTrustPath); break;
   case aDeArmor: set_cmd( &cmd, aDeArmor); break;
   case aEnArmor: set_cmd( &cmd, aEnArmor); break;
   case aListOwnerTrust:
     deprecated_warning(configname,configlineno,
          "--list-ownertrust","--export-ownertrust","");
   case aExportOwnerTrust: set_cmd( &cmd, aExportOwnerTrust); break;
   case aImportOwnerTrust: set_cmd( &cmd, aImportOwnerTrust); break;
          case aPipeMode:
     deprecated_command ("--pipemode");
            set_cmd( &cmd, aPipeMode);
            break;

          case aRebuildKeydbCaches: set_cmd( &cmd, aRebuildKeydbCaches); break;


          case aCardStatus: set_cmd (&cmd, aCardStatus); break;
          case aCardEdit: set_cmd (&cmd, aCardEdit); break;
          case aChangePIN: set_cmd (&cmd, aChangePIN); break;
          case oReaderPort:
            card_set_reader_port (pargs.r.ret_str);
            break;
          case octapiDriver: opt.ctapi_driver = pargs.r.ret_str; break;
          case opcscDriver: opt.pcsc_driver = pargs.r.ret_str; break;
          case oDisableCCID: opt.disable_ccid = 1; break;


   case oArmor: opt.armor = 1; opt.no_armor=0; break;
   case oOutput: opt.outfile = pargs.r.ret_str; break;
   case oMaxOutput: opt.max_output = pargs.r.ret_ulong; break;
   case oQuiet: opt.quiet = 1; break;
   case oNoTTY: tty_no_terminal(1); break;
   case oDryRun: opt.dry_run = 1; break;
   case oInteractive: opt.interactive = 1; break;
   case oVerbose:
     g10_opt_verbose++;
     opt.verbose++;
     opt.list_options|=(1<<6);
     opt.list_options|=(1<<7);
     break;
   case oKOption: set_cmd( &cmd, aKMode ); break;

   case oBatch: opt.batch = 1; nogreeting = 1; break;
          case oUseAgent:

            opt.use_agent = 1;




            break;
          case oNoUseAgent: opt.use_agent = 0; break;
   case oGpgAgentInfo: opt.gpg_agent_info = pargs.r.ret_str; break;
   case oAnswerYes: opt.answer_yes = 1; break;
   case oAnswerNo: opt.answer_no = 1; break;
   case oKeyring: append_to_strlist( &nrings, pargs.r.ret_str); break;
   case oPrimaryKeyring:
     sl=append_to_strlist( &nrings, pargs.r.ret_str);
     sl->flags=2;
     break;
   case oShowKeyring:
     deprecated_warning(configname,configlineno,"--show-keyring",
          "--list-options ","show-keyring");
     opt.list_options|=(1<<8);
     break;
   case oDebug: opt.debug |= pargs.r.ret_ulong; break;
   case oDebugAll: opt.debug = ~0; break;
          case oDebugLevel: break;
          case oDebugCCIDDriver:



            break;
   case oStatusFD:
            set_status_fd( iobuf_translate_file_handle (pargs.r.ret_int, 1) );
            break;
   case oStatusFile:
            set_status_fd ( open_info_file (pargs.r.ret_str, 1) );
            break;
   case oAttributeFD:
            set_attrib_fd(iobuf_translate_file_handle (pargs.r.ret_int, 1));
            break;
   case oAttributeFile:
            set_attrib_fd ( open_info_file (pargs.r.ret_str, 1) );
            break;
   case oLoggerFD:
            log_set_logfile( ((void*)0),
                             iobuf_translate_file_handle (pargs.r.ret_int, 1));
            break;
   case oLoggerFile:



            if (strncmp (pargs.r.ret_str, "socket://", 9))
              log_set_logfile( ((void*)0), open_info_file (pargs.r.ret_str, 1) );
            break;

   case oWithFingerprint:
            opt.with_fingerprint = 1;
            opt.fingerprint++;
            break;
   case oFingerprint:
            opt.fingerprint++;
            fpr_maybe_cmd = 1;
            break;

   case oSecretKeyring:
            append_to_strlist( &sec_nrings, pargs.r.ret_str);
            break;
   case oOptions:

     if( !configfp ) {
  xfree(configname);
  configname = xstrdup(pargs.r.ret_str);
  goto next_pass;
     }
     break;
   case oNoArmor: opt.no_armor=1; opt.armor=0; break;
   case oNoDefKeyring: default_keyring = 0; break;
   case oNoGreeting: nogreeting = 1; break;
   case oNoVerbose: g10_opt_verbose = 0;
      opt.verbose = 0; opt.list_sigs=0; break;
   case oQuickRandom: quick_random_gen(1); break;
   case oEmitVersion: opt.emit_version++; break;
   case oNoEmitVersion: opt.emit_version=0; break;
   case oCompletesNeeded: opt.completes_needed = pargs.r.ret_int; break;
   case oMarginalsNeeded: opt.marginals_needed = pargs.r.ret_int; break;
   case oMaxCertDepth: opt.max_cert_depth = pargs.r.ret_int; break;
   case oTrustDBName: trustdb_name = pargs.r.ret_str; break;
   case oDefaultKey: opt.def_secret_key = pargs.r.ret_str; break;
   case oDefRecipient:
      if( *pargs.r.ret_str )
   opt.def_recipient = make_username(pargs.r.ret_str);
      break;
   case oDefRecipientSelf:
      xfree(opt.def_recipient); opt.def_recipient = ((void*)0);
      opt.def_recipient_self = 1;
      break;
   case oNoDefRecipient:
      xfree(opt.def_recipient); opt.def_recipient = ((void*)0);
      opt.def_recipient_self = 0;
      break;
   case oNoOptions: opt.no_homedir_creation = 1; break;
   case oHomedir: break;
   case oNoBatch: opt.batch = 0; break;
   case oWithKeyData: opt.with_key_data=1;
   case oWithColons: opt.with_colons=':'; break;

   case oSkipVerify: opt.skip_verify=1; break;
   case oCompressKeys: opt.compress_keys = 1; break;
   case aListSecretKeys: set_cmd( &cmd, aListSecretKeys); break;



   case oAlwaysTrust: opt.trust_model=TM_ALWAYS; break;
   case oTrustModel:
     parse_trust_model(pargs.r.ret_str);
     break;
   case oForceOwnertrust:
     g10_log_info(gettext ("NOTE: %s is not for normal use!\n"),
       "--force-ownertrust");
     opt.force_ownertrust=string_to_trust_value(pargs.r.ret_str);
     if(opt.force_ownertrust==-1)
       {
  g10_log_error("invalid ownertrust `%s'\n",pargs.r.ret_str);
  opt.force_ownertrust=0;
       }
     break;
   case oLoadExtension:
            break;
   case oRFC1991:
     opt.compliance = CO_RFC1991;
     opt.force_v4_certs = 0;
     opt.escape_from = 1;
     break;
   case oOpenPGP:
   case oRFC4880:



     opt.compliance = CO_RFC4880;
     opt.flags.dsa2 = 1;
     opt.flags.require_cross_cert = 1;
     opt.rfc2440_text = 0;
     opt.allow_non_selfsigned_uid = 1;
     opt.allow_freeform_uid = 1;
     opt.pgp2_workarounds = 0;
     opt.escape_from = 1;
     opt.force_v3_sigs = 0;
     opt.compress_keys = 0;
     opt.compress_sigs = 0;
     opt.not_dash_escaped = 0;
     opt.def_cipher_algo = 0;
     opt.def_digest_algo = 0;
     opt.cert_digest_algo = 0;
     opt.compress_algo = -1;
            opt.s2k_mode = 3;
     opt.s2k_digest_algo = 2;
     opt.s2k_cipher_algo = 2;
     break;
   case oRFC2440:
     opt.compliance = CO_RFC2440;
     opt.flags.dsa2 = 0;
     opt.rfc2440_text = 1;
     opt.allow_non_selfsigned_uid = 1;
     opt.allow_freeform_uid = 1;
     opt.pgp2_workarounds = 0;
     opt.escape_from = 0;
     opt.force_v3_sigs = 0;
     opt.compress_keys = 0;
     opt.compress_sigs = 0;
     opt.not_dash_escaped = 0;
     opt.def_cipher_algo = 0;
     opt.def_digest_algo = 0;
     opt.cert_digest_algo = 0;
     opt.compress_algo = -1;
            opt.s2k_mode = 3;
     opt.s2k_digest_algo = 2;
     opt.s2k_cipher_algo = 2;
     break;
   case oPGP2: opt.compliance = CO_PGP2; break;
   case oPGP6: opt.compliance = CO_PGP6; break;
   case oPGP7: opt.compliance = CO_PGP7; break;
   case oPGP8: opt.compliance = CO_PGP8; break;
   case oGnuPG: opt.compliance = CO_GNUPG; break;
   case oCompressSigs: opt.compress_sigs = 1; break;
   case oRFC2440Text: opt.rfc2440_text=1; break;
   case oNoRFC2440Text: opt.rfc2440_text=0; break;
   case oRunAsShmCP:
# 2374 "gpg.c"
     break;
   case oSetFilename:
     if(utf8_strings)
       opt.set_filename = pargs.r.ret_str;
     else
       opt.set_filename = native_to_utf8(pargs.r.ret_str);
     break;
   case oForYourEyesOnly: eyes_only = 1; break;
   case oNoForYourEyesOnly: eyes_only = 0; break;
   case oSetPolicyURL:
     add_policy_url(pargs.r.ret_str,0);
     add_policy_url(pargs.r.ret_str,1);
     break;
   case oSigPolicyURL: add_policy_url(pargs.r.ret_str,0); break;
   case oCertPolicyURL: add_policy_url(pargs.r.ret_str,1); break;
          case oShowPolicyURL:
     deprecated_warning(configname,configlineno,"--show-policy-url",
          "--list-options ","show-policy-urls");
     deprecated_warning(configname,configlineno,"--show-policy-url",
          "--verify-options ","show-policy-urls");
     opt.list_options|=(1<<1);
     opt.verify_options|=(1<<1);
     break;
   case oNoShowPolicyURL:
     deprecated_warning(configname,configlineno,"--no-show-policy-url",
          "--list-options ","no-show-policy-urls");
     deprecated_warning(configname,configlineno,"--no-show-policy-url",
          "--verify-options ","no-show-policy-urls");
     opt.list_options&=~(1<<1);
     opt.verify_options&=~(1<<1);
     break;
   case oSigKeyserverURL: add_keyserver_url(pargs.r.ret_str,0); break;
   case oUseEmbeddedFilename:
     opt.flags.use_embedded_filename=1;
     break;
   case oNoUseEmbeddedFilename:
     opt.flags.use_embedded_filename=0;
     break;
   case oComment:
     if(pargs.r.ret_str[0])
       append_to_strlist(&opt.comments,pargs.r.ret_str);
     break;
   case oDefaultComment:
     deprecated_warning(configname,configlineno,
          "--default-comment","--no-comments","");

   case oNoComments:
     free_strlist(opt.comments);
     opt.comments=((void*)0);
     break;
   case oThrowKeyids: opt.throw_keyid = 1; break;
   case oNoThrowKeyids: opt.throw_keyid = 0; break;
   case oShowPhotos:
     deprecated_warning(configname,configlineno,"--show-photos",
          "--list-options ","show-photos");
     deprecated_warning(configname,configlineno,"--show-photos",
          "--verify-options ","show-photos");
     opt.list_options|=(1<<0);
     opt.verify_options|=(1<<0);
     break;
   case oNoShowPhotos:
     deprecated_warning(configname,configlineno,"--no-show-photos",
          "--list-options ","no-show-photos");
     deprecated_warning(configname,configlineno,"--no-show-photos",
          "--verify-options ","no-show-photos");
     opt.list_options&=~(1<<0);
     opt.verify_options&=~(1<<0);
     break;
   case oPhotoViewer: opt.photo_viewer = pargs.r.ret_str; break;
   case oForceV3Sigs: opt.force_v3_sigs = 1; break;
   case oNoForceV3Sigs: opt.force_v3_sigs = 0; break;
          case oForceV4Certs: opt.force_v4_certs = 1; break;
          case oNoForceV4Certs: opt.force_v4_certs = 0; break;
   case oForceMDC: opt.force_mdc = 1; break;
   case oNoForceMDC: opt.force_mdc = 0; break;
   case oDisableMDC: opt.disable_mdc = 1; break;
   case oNoDisableMDC: opt.disable_mdc = 0; break;
   case oS2KMode: opt.s2k_mode = pargs.r.ret_int; break;
   case oS2KDigest: s2k_digest_string = xstrdup(pargs.r.ret_str); break;
   case oS2KCipher: s2k_cipher_string = xstrdup(pargs.r.ret_str); break;
   case oS2KCount:
     opt.s2k_count=encode_s2k_iterations(pargs.r.ret_int);
     break;
          case oSimpleSKChecksum: opt.simple_sk_checksum = 1; break;
   case oNoEncryptTo: opt.no_encrypt_to = 1; break;
   case oEncryptTo:
     sl = add_to_strlist2( &remusr, pargs.r.ret_str, utf8_strings );
     sl->flags = 1;
     break;
   case oHiddenEncryptTo:
     sl = add_to_strlist2( &remusr, pargs.r.ret_str, utf8_strings );
     sl->flags = 1|2;
     break;
   case oRecipient:
     add_to_strlist2( &remusr, pargs.r.ret_str, utf8_strings );
            any_explicit_recipient = 1;
     break;
   case oHiddenRecipient:
     sl = add_to_strlist2( &remusr, pargs.r.ret_str, utf8_strings );
     sl->flags = 2;
            any_explicit_recipient = 1;
     break;
   case oTextmodeShort: opt.textmode = 2; break;
   case oTextmode: opt.textmode=1; break;
   case oNoTextmode: opt.textmode=0; break;
   case oExpert: opt.expert = 1; break;
   case oNoExpert: opt.expert = 0; break;
   case oDefSigExpire:
     if(*pargs.r.ret_str!='\0')
       {
  if(parse_expire_string(0,pargs.r.ret_str)==(u32)-1)
    g10_log_error(gettext ("`%s' is not a valid signature expiration\n"),
       pargs.r.ret_str);
  else
    opt.def_sig_expire=pargs.r.ret_str;
       }
     break;
   case oAskSigExpire: opt.ask_sig_expire = 1; break;
   case oNoAskSigExpire: opt.ask_sig_expire = 0; break;
   case oDefCertExpire:
     if(*pargs.r.ret_str!='\0')
       {
  if(parse_expire_string(0,pargs.r.ret_str)==(u32)-1)
    g10_log_error(gettext ("`%s' is not a valid signature expiration\n"),
       pargs.r.ret_str);
  else
    opt.def_cert_expire=pargs.r.ret_str;
       }
     break;
   case oAskCertExpire: opt.ask_cert_expire = 1; break;
   case oNoAskCertExpire: opt.ask_cert_expire = 0; break;
          case oDefCertLevel: opt.def_cert_level=pargs.r.ret_int; break;
          case oMinCertLevel: opt.min_cert_level=pargs.r.ret_int; break;
   case oAskCertLevel: opt.ask_cert_level = 1; break;
   case oNoAskCertLevel: opt.ask_cert_level = 0; break;
   case oLocalUser:
     add_to_strlist2( &locusr, pargs.r.ret_str, utf8_strings );
     break;
   case oCompress:

     opt.compress_level = opt.bz2_compress_level = pargs.r.ret_int;
     break;
   case oCompressLevel: opt.compress_level = pargs.r.ret_int; break;
   case oBZ2CompressLevel: opt.bz2_compress_level = pargs.r.ret_int; break;
   case oBZ2DecompressLowmem: opt.bz2_decompress_lowmem=1; break;
   case oPasswd:
     set_passphrase_from_string(pargs.r.ret_str);
     break;
   case oPasswdFD:
            pwfd = iobuf_translate_file_handle (pargs.r.ret_int, 0);
            opt.use_agent = 0;
            break;
   case oPasswdFile:
            pwfd = open_info_file (pargs.r.ret_str, 0);
            break;
   case oPasswdRepeat: opt.passwd_repeat=pargs.r.ret_int; break;
   case oCommandFD:
            opt.command_fd = iobuf_translate_file_handle (pargs.r.ret_int, 0);
            break;
   case oCommandFile:
            opt.command_fd = open_info_file (pargs.r.ret_str, 0);
            break;
   case oCipherAlgo:
            def_cipher_string = xstrdup(pargs.r.ret_str);
            break;
   case oDigestAlgo:
            def_digest_string = xstrdup(pargs.r.ret_str);
            break;
   case oCompressAlgo:



     {
       char *pt=pargs.r.ret_str;
       while(*pt)
  {
    if (!(0 ? isascii(*pt) : (unsigned)(*pt) < 128) || !(0 ? isdigit(*pt) : ((unsigned)(*pt)-'0') < 10))
      break;

    pt++;
  }

       if(*pt=='\0')
  {
    compress_algo_string=xmalloc(strlen(pargs.r.ret_str)+2);
    strcpy(compress_algo_string,"Z");
    strcat(compress_algo_string,pargs.r.ret_str);
  }
       else
  compress_algo_string = xstrdup(pargs.r.ret_str);
     }
     break;
   case oCertDigestAlgo: cert_digest_string = xstrdup(pargs.r.ret_str); break;
   case oNoSecmemWarn: secmem_set_flags( secmem_get_flags() | 1 ); break;
   case oRequireSecmem: require_secmem=1; break;
   case oNoRequireSecmem: require_secmem=0; break;
   case oNoPermissionWarn: opt.no_perm_warn=1; break;
   case oNoMDCWarn: opt.no_mdc_warn=1; break;
          case oDisplayCharset:
     if( set_native_charset( pargs.r.ret_str ) )
  g10_log_error(gettext ("`%s' is not a valid character set\n"),
     pargs.r.ret_str);
     break;
   case oNotDashEscaped: opt.not_dash_escaped = 1; break;
   case oEscapeFrom: opt.escape_from = 1; break;
   case oNoEscapeFrom: opt.escape_from = 0; break;
   case oLockOnce: opt.lock_once = 1; break;
   case oLockNever:
            dotlock_disable ();
            random_disable_locking ();
            break;
   case oLockMultiple:

     opt.lock_once = 0;



            break;
   case oKeyServer:
     {
       struct keyserver_spec *keyserver;
       keyserver=parse_keyserver_uri(pargs.r.ret_str,0,
         configname,configlineno);
       if(!keyserver)
  g10_log_error(gettext ("could not parse keyserver URL\n"));
       else
  {
    keyserver->next=opt.keyserver;
    opt.keyserver=keyserver;
  }
     }
     break;
   case oKeyServerOptions:
     if(!parse_keyserver_options(pargs.r.ret_str))
       {
  if(configname)
    g10_log_error(gettext ("%s:%d: invalid keyserver options\n"),
       configname,configlineno);
  else
    g10_log_error(gettext ("invalid keyserver options\n"));
       }
     break;
   case oImportOptions:
     if(!parse_import_options(pargs.r.ret_str,&opt.import_options,1))
       {
  if(configname)
    g10_log_error(gettext ("%s:%d: invalid import options\n"),
       configname,configlineno);
  else
    g10_log_error(gettext ("invalid import options\n"));
       }
     break;
   case oExportOptions:
     if(!parse_export_options(pargs.r.ret_str,&opt.export_options,1))
       {
  if(configname)
    g10_log_error(gettext ("%s:%d: invalid export options\n"),
       configname,configlineno);
  else
    g10_log_error(gettext ("invalid export options\n"));
       }
     break;
   case oListOptions:
     if(!parse_list_options(pargs.r.ret_str))
       {
  if(configname)
    g10_log_error(gettext ("%s:%d: invalid list options\n"),
       configname,configlineno);
  else
    g10_log_error(gettext ("invalid list options\n"));
       }
     break;
   case oVerifyOptions:
     {
       struct parse_options vopts[]=
  {
    {"show-photos",(1<<0),((void*)0),
     ("display photo IDs during signature verification")},
    {"show-policy-urls",(1<<1),((void*)0),
     ("show policy URLs during signature verification")},
    {"show-notations",((1<<2)|(1<<3)),((void*)0),
     ("show all notations during signature verification")},
    {"show-std-notations",(1<<2),((void*)0),
     ("show IETF standard notations during signature verification")},
    {"show-standard-notations",(1<<2),((void*)0),
     ((void*)0)},
    {"show-user-notations",(1<<3),((void*)0),
     ("show user-supplied notations during signature verification")},
    {"show-keyserver-urls",(1<<4),((void*)0),
     ("show preferred keyserver URLs during signature verification")},
    {"show-uid-validity",(1<<5),((void*)0),
     ("show user ID validity during signature verification")},
    {"show-unusable-uids",(1<<6),((void*)0),
     ("show revoked and expired user IDs in signature verification")},
    {"show-primary-uid-only",(1<<9),((void*)0),
     ("show only the primary user ID in signature verification")},
    {"pka-lookups",(1<<7),((void*)0),
     ("validate signatures with PKA data")},
    {"pka-trust-increase",(1<<8),((void*)0),
     ("elevate the trust of signatures with valid PKA data")},
    {((void*)0),0,((void*)0),((void*)0)}
  };

       if(!parse_options(pargs.r.ret_str,&opt.verify_options,vopts,1))
  {
    if(configname)
      g10_log_error(gettext ("%s:%d: invalid verify options\n"),
         configname,configlineno);
    else
      g10_log_error(gettext ("invalid verify options\n"));
  }
     }
     break;
   case oTempDir: opt.temp_dir=pargs.r.ret_str; break;
   case oExecPath:
     if(set_exec_path(pargs.r.ret_str))
       g10_log_error(gettext ("unable to set exec-path to %s\n"),pargs.r.ret_str);
     else
       opt.exec_path_set=1;
     break;
   case oSetNotation:
     add_notation_data( pargs.r.ret_str, 0 );
     add_notation_data( pargs.r.ret_str, 1 );
     break;
   case oSigNotation: add_notation_data( pargs.r.ret_str, 0 ); break;
   case oCertNotation: add_notation_data( pargs.r.ret_str, 1 ); break;
   case oShowNotation:
     deprecated_warning(configname,configlineno,"--show-notation",
          "--list-options ","show-notations");
     deprecated_warning(configname,configlineno,"--show-notation",
          "--verify-options ","show-notations");
     opt.list_options|=((1<<2)|(1<<3));
     opt.verify_options|=((1<<2)|(1<<3));
     break;
   case oNoShowNotation:
     deprecated_warning(configname,configlineno,"--no-show-notation",
          "--list-options ","no-show-notations");
     deprecated_warning(configname,configlineno,"--no-show-notation",
          "--verify-options ","no-show-notations");
     opt.list_options&=~((1<<2)|(1<<3));
     opt.verify_options&=~((1<<2)|(1<<3));
     break;
   case oUtf8Strings: utf8_strings = 1; break;
   case oNoUtf8Strings: utf8_strings = 0; break;
   case oDisableCipherAlgo:
  disable_cipher_algo( string_to_cipher_algo(pargs.r.ret_str) );
  break;
   case oDisablePubkeyAlgo:
  disable_pubkey_algo( string_to_pubkey_algo(pargs.r.ret_str) );
  break;
          case oNoSigCache: opt.no_sig_cache = 1; break;
   case oAllowNonSelfsignedUID: opt.allow_non_selfsigned_uid = 1; break;
   case oNoAllowNonSelfsignedUID: opt.allow_non_selfsigned_uid=0; break;
   case oAllowFreeformUID: opt.allow_freeform_uid = 1; break;
   case oNoAllowFreeformUID: opt.allow_freeform_uid = 0; break;
   case oNoLiteral: opt.no_literal = 1; break;
   case oSetFilesize: opt.set_filesize = pargs.r.ret_ulong; break;
   case oHonorHttpProxy:
         add_to_strlist(&opt.keyserver_options.other,"http-proxy");
  deprecated_warning(configname,configlineno,
       "--honor-http-proxy",
       "--keyserver-options ","http-proxy");
  break;
   case oFastListMode: opt.fast_list_mode = 1; break;
   case oFixedListMode: opt.fixed_list_mode = 1; break;
   case oListOnly: opt.list_only=1; break;
   case oIgnoreTimeConflict: opt.ignore_time_conflict = 1; break;
   case oIgnoreValidFrom: opt.ignore_valid_from = 1; break;
   case oIgnoreCrcError: opt.ignore_crc_error = 1; break;
   case oIgnoreMDCError: opt.ignore_mdc_error = 1; break;
   case oNoRandomSeedFile: use_random_seed = 0; break;
   case oAutoKeyRetrieve:
   case oNoAutoKeyRetrieve:
         if(pargs.r_opt==oAutoKeyRetrieve)
    opt.keyserver_options.options|=(1<<3);
  else
    opt.keyserver_options.options&=~(1<<3);

  deprecated_warning(configname,configlineno,
      pargs.r_opt==oAutoKeyRetrieve?"--auto-key-retrieve":
          "--no-auto-key-retrieve","--keyserver-options ",
      pargs.r_opt==oAutoKeyRetrieve?"auto-key-retrieve":
          "no-auto-key-retrieve");
  break;
   case oShowSessionKey: opt.show_session_key = 1; break;
   case oOverrideSessionKey:
  opt.override_session_key = pargs.r.ret_str;
  break;
   case oMergeOnly:
         deprecated_warning(configname,configlineno,"--merge-only",
       "--import-options ","merge-only");
  opt.import_options|=(1<<4);
     break;
          case oAllowSecretKeyImport: break;
   case oTryAllSecrets: opt.try_all_secrets = 1; break;
          case oTrustedKey: register_trusted_key( pargs.r.ret_str ); break;
          case oEnableSpecialFilenames:
            iobuf_enable_special_filenames (1);
            break;
          case oNoExpensiveTrustChecks: opt.no_expensive_trust_checks=1; break;
          case oAutoCheckTrustDB: opt.no_auto_check_trustdb=0; break;
          case oNoAutoCheckTrustDB: opt.no_auto_check_trustdb=1; break;
          case oPreservePermissions: opt.preserve_permissions=1; break;
          case oDefaultPreferenceList:
     opt.def_preference_list = pargs.r.ret_str;
     break;
   case oDefaultKeyserverURL:
     {
       struct keyserver_spec *keyserver;
       keyserver=parse_keyserver_uri(pargs.r.ret_str,1,
         configname,configlineno);
       if(!keyserver)
  g10_log_error(gettext ("could not parse keyserver URL\n"));
       else
  free_keyserver_spec(keyserver);

       opt.def_keyserver_url = pargs.r.ret_str;
     }
     break;
          case oPersonalCipherPreferences:
     pers_cipher_list=pargs.r.ret_str;
     break;
          case oPersonalDigestPreferences:
     pers_digest_list=pargs.r.ret_str;
     break;
          case oPersonalCompressPreferences:
     pers_compress_list=pargs.r.ret_str;
     break;
          case oDisplay: opt.display = pargs.r.ret_str; break;
          case oTTYname: opt.ttyname = pargs.r.ret_str; break;
          case oTTYtype: opt.ttytype = pargs.r.ret_str; break;
          case oWeakDigest:
     additional_weak_digest(pargs.r.ret_str);
     break;
          case oLCctype: opt.lc_ctype = pargs.r.ret_str; break;
          case oLCmessages: opt.lc_messages = pargs.r.ret_str; break;
   case oGroup: add_group(pargs.r.ret_str); break;
   case oUnGroup: rm_group(pargs.r.ret_str); break;
   case oNoGroups:
     while(opt.grouplist)
       {
  struct groupitem *iter=opt.grouplist;
  free_strlist(iter->values);
  opt.grouplist=opt.grouplist->next;
  xfree(iter);
       }
     break;
   case oStrict: opt.strict=1; log_set_strict(1); break;
   case oNoStrict: opt.strict=0; log_set_strict(0); break;
          case oMangleDosFilenames: opt.mangle_dos_filenames = 1; break;
          case oNoMangleDosFilenames: opt.mangle_dos_filenames = 0; break;
          case oEnableProgressFilter: opt.enable_progress_filter = 1; break;
   case oMultifile: multifile=1; break;
   case oKeyidFormat:
     if(ascii_strcasecmp(pargs.r.ret_str,"short")==0)
       opt.keyid_format=KF_SHORT;
     else if(ascii_strcasecmp(pargs.r.ret_str,"long")==0)
       opt.keyid_format=KF_LONG;
     else if(ascii_strcasecmp(pargs.r.ret_str,"0xshort")==0)
       opt.keyid_format=KF_0xSHORT;
     else if(ascii_strcasecmp(pargs.r.ret_str,"0xlong")==0)
       opt.keyid_format=KF_0xLONG;
     else
       g10_log_error("unknown keyid-format `%s'\n",pargs.r.ret_str);
     break;

          case oExitOnStatusWriteError:
            opt.exit_on_status_write_error = 1;
            break;

   case oLimitCardInsertTries:
            opt.limit_card_insert_tries = pargs.r.ret_int;
            break;

   case oRequireCrossCert: opt.flags.require_cross_cert=1; break;
   case oNoRequireCrossCert: opt.flags.require_cross_cert=0; break;

   case oAutoKeyLocate:
     if(!parse_auto_key_locate(pargs.r.ret_str))
       {
  if(configname)
    g10_log_error(gettext ("%s:%d: invalid auto-key-locate list\n"),
       configname,configlineno);
  else
    g10_log_error(gettext ("invalid auto-key-locate list\n"));
       }
     break;
   case oNoAutoKeyLocate:
     release_akl();
     break;

   case oEnableLargeRSA:



            if (configname)
              g10_log_info("%s:%d: WARNING: gpg not built with large secure "
                         "memory buffer.  Ignoring enable-large-rsa\n",
                        configname,configlineno);
            else
              g10_log_info("WARNING: gpg not built with large secure "
                         "memory buffer.  Ignoring --enable-large-rsa\n");

            break;
   case oDisableLargeRSA: opt.flags.large_rsa=0;
            break;

   case oEnableDSA2: opt.flags.dsa2=1; break;
   case oDisableDSA2: opt.flags.dsa2=0; break;

          case oAllowMultisigVerification:
   case oAllowMultipleMessages:
     opt.flags.allow_multiple_messages=1;
     break;

   case oNoAllowMultipleMessages:
     opt.flags.allow_multiple_messages=0;
     break;

          case oAllowWeakDigestAlgos:
            opt.flags.allow_weak_digest_algos = 1;
            break;

   case oNoop: break;

   default : pargs.err = configfp? 1:2; break;
   }
      }


    if( configfp ) {
 fclose( configfp );
 configfp = ((void*)0);

        if (!save_configname)
          save_configname = configname;
        else
          xfree(configname);
        configname = ((void*)0);
 goto next_pass;
    }
    xfree( configname ); configname = ((void*)0);
    if( log_get_errorcount(0) )
 g10_exit(2);



    if (cmd == aGPGConfList)
      {
        gpgconf_list (save_configname ? save_configname : default_configname);
        g10_exit (0);
      }
    xfree (save_configname);
    xfree (default_configname);

    if( nogreeting )
 greeting = 0;

    if( greeting ) {
 fprintf((stderr), "%s %s; %s\n",
   strusage(11), strusage(13), strusage(14) );
 fprintf((stderr), "%s\n", strusage(15) );
    }
# 2951 "gpg.c"
    if (opt.verbose > 2)
        g10_log_info ("using character set `%s'\n", get_native_charset ());

    if( may_coredump && !opt.quiet )
 g10_log_info(gettext ("WARNING: program may create a core file!\n"));

    if (eyes_only) {
      if (opt.set_filename)
   g10_log_info(gettext ("WARNING: %s overrides %s\n"),
     "--for-your-eyes-only","--set-filename");

      opt.set_filename="_CONSOLE";
    }

    if (opt.no_literal) {
 g10_log_info(gettext ("NOTE: %s is not for normal use!\n"), "--no-literal");
 if (opt.textmode)
     g10_log_error(gettext ("%s not allowed with %s!\n"),
         "--textmode", "--no-literal" );
 if (opt.set_filename)
     g10_log_error(gettext ("%s makes no sense with %s!\n"),
   eyes_only?"--for-your-eyes-only":"--set-filename",
          "--no-literal" );
    }


    if (opt.use_agent) {
      g10_log_info(gettext ("NOTE: %s is not available in this version\n"),
               "--use-agent");
      opt.use_agent = 0;
    }


    if (opt.set_filesize)
 g10_log_info(gettext ("NOTE: %s is not for normal use!\n"), "--set-filesize");
    if( opt.batch )
 tty_batchmode( 1 );

    secmem_set_flags( secmem_get_flags() & ~2 );

    if(require_secmem && !got_secmem)
      {
 g10_log_info(gettext ("will not run with insecure memory due to %s\n"),
   "--require-secmem");
 g10_exit(2);
      }

    set_debug();


    if((opt.compliance==CO_PGP2))
      {
 int unusable=0;

 if(cmd==aSign && !detached_sig)
   {
     g10_log_info(gettext ("you can only make detached or clear signatures " "while in --pgp2 mode\n"));

     unusable=1;
   }
 else if(cmd==aSignEncr || cmd==aSignSym)
   {
     g10_log_info(gettext ("you can't sign and encrypt at the " "same time while in --pgp2 mode\n"));

     unusable=1;
   }
 else if(argc==0 && (cmd==aSign || cmd==aEncr || cmd==aSym))
   {
     g10_log_info(gettext ("you must use files (and not a pipe) when " "working with --pgp2 enabled.\n"));

     unusable=1;
   }
 else if(cmd==aEncr || cmd==aSym)
   {





     if(check_cipher_algo(1))
       {
  g10_log_info(gettext ("encrypting a message in --pgp2 mode requires " "the IDEA cipher\n"));

  unusable=1;
       }
     else if(cmd==aSym)
       {



  xfree(def_cipher_string);
  def_cipher_string = xstrdup("idea");
       }






     if(!unusable)
       opt.textmode=0;
   }

 if(unusable)
   compliance_failure();
 else
   {
     opt.force_v4_certs = 0;
     opt.escape_from = 1;
     opt.force_v3_sigs = 1;
     opt.pgp2_workarounds = 1;
     opt.ask_sig_expire = 0;
     opt.ask_cert_expire = 0;
            opt.flags.allow_weak_digest_algos = 1;
     xfree(def_digest_string);
     def_digest_string = xstrdup("md5");
     xfree(s2k_digest_string);
     s2k_digest_string = xstrdup("md5");
     opt.compress_algo = 1;
   }
      }
    else if((opt.compliance==CO_PGP6))
      {
 opt.disable_mdc=1;
 opt.escape_from=1;
 opt.force_v3_sigs=1;
 opt.ask_sig_expire=0;
      }
    else if((opt.compliance==CO_PGP7))
      {
 opt.escape_from=1;
 opt.force_v3_sigs=1;
 opt.ask_sig_expire=0;
      }
    else if((opt.compliance==CO_PGP8))
      {
 opt.escape_from=1;
      }



    if( def_cipher_string ) {
 opt.def_cipher_algo = string_to_cipher_algo(def_cipher_string);
 xfree(def_cipher_string); def_cipher_string = ((void*)0);
 if( check_cipher_algo(opt.def_cipher_algo) )
     g10_log_error(gettext ("selected cipher algorithm is invalid\n"));
    }
    if( def_digest_string ) {
 opt.def_digest_algo = string_to_digest_algo(def_digest_string);
 xfree(def_digest_string); def_digest_string = ((void*)0);
 if( check_digest_algo(opt.def_digest_algo) )
     g10_log_error(gettext ("selected digest algorithm is invalid\n"));
    }
    if( compress_algo_string ) {
 opt.compress_algo = string_to_compress_algo(compress_algo_string);
 xfree(compress_algo_string); compress_algo_string = ((void*)0);
 if( check_compress_algo(opt.compress_algo) )
     g10_log_error(gettext ("selected compression algorithm is invalid\n"));
    }
    if( cert_digest_string ) {
 opt.cert_digest_algo = string_to_digest_algo(cert_digest_string);
 xfree(cert_digest_string); cert_digest_string = ((void*)0);
 if( check_digest_algo(opt.cert_digest_algo) )
     g10_log_error(gettext ("selected certification digest algorithm is invalid\n"));
    }
    if( s2k_cipher_string ) {
 opt.s2k_cipher_algo = string_to_cipher_algo(s2k_cipher_string);
 xfree(s2k_cipher_string); s2k_cipher_string = ((void*)0);
 if( check_cipher_algo(opt.s2k_cipher_algo) )
     g10_log_error(gettext ("selected cipher algorithm is invalid\n"));
    }
    if( s2k_digest_string ) {
 opt.s2k_digest_algo = string_to_digest_algo(s2k_digest_string);
 xfree(s2k_digest_string); s2k_digest_string = ((void*)0);
 if( check_digest_algo(opt.s2k_digest_algo) )
     g10_log_error(gettext ("selected digest algorithm is invalid\n"));
    }
    if( opt.completes_needed < 1 )
      g10_log_error(gettext ("completes-needed must be greater than 0\n"));
    if( opt.marginals_needed < 2 )
      g10_log_error(gettext ("marginals-needed must be greater than 1\n"));
    if( opt.max_cert_depth < 1 || opt.max_cert_depth > 255 )
      g10_log_error(gettext ("max-cert-depth must be in the range from 1 to 255\n"));
    if(opt.def_cert_level<0 || opt.def_cert_level>3)
      g10_log_error(gettext ("invalid default-cert-level; must be 0, 1, 2, or 3\n"));
    if( opt.min_cert_level < 1 || opt.min_cert_level > 3 )
      g10_log_error(gettext ("invalid min-cert-level; must be 1, 2, or 3\n"));
    switch( opt.s2k_mode ) {
      case 0:
 g10_log_info(gettext ("NOTE: simple S2K mode (0) is strongly discouraged\n"));
 break;
      case 1: case 3: break;
      default:
 g10_log_error(gettext ("invalid S2K mode; must be 0, 1 or 3\n"));
    }



    if(opt.def_preference_list &&
 keygen_set_std_prefs(opt.def_preference_list,0))
      g10_log_error(gettext ("invalid default preferences\n"));

    if(pers_cipher_list &&
       keygen_set_std_prefs(pers_cipher_list,PREFTYPE_SYM))
      g10_log_error(gettext ("invalid personal cipher preferences\n"));

    if(pers_digest_list &&
       keygen_set_std_prefs(pers_digest_list,PREFTYPE_HASH))
      g10_log_error(gettext ("invalid personal digest preferences\n"));

    if(pers_compress_list &&
       keygen_set_std_prefs(pers_compress_list,PREFTYPE_ZIP))
      g10_log_error(gettext ("invalid personal compress preferences\n"));


    if(multifile)
      {
 char *cmdname;

 switch(cmd)
   {
   case aSign:
     cmdname="--sign";
     break;
   case aClearsign:
     cmdname="--clearsign";
     break;
   case aDetachedSign:
     cmdname="--detach-sign";
     break;
   case aSym:
     cmdname="--symmetric";
     break;
   case aEncrSym:
     cmdname="--symmetric --encrypt";
     break;
   case aStore:
     cmdname="--store";
     break;
   default:
     cmdname=((void*)0);
     break;
   }

 if(cmdname)
   g10_log_error(gettext ("%s does not yet work with %s\n"),cmdname,"--multifile");
      }

    if( log_get_errorcount(0) )
 g10_exit(2);

    if(opt.compress_level==0)
      opt.compress_algo=0;




    if(!(opt.compliance==CO_GNUPG))
      {
 const char *badalg=((void*)0);
 preftype_t badtype=PREFTYPE_NONE;

 if(opt.def_cipher_algo
    && !algo_available(PREFTYPE_SYM,opt.def_cipher_algo,((void*)0)))
   {
     badalg=cipher_algo_to_string(opt.def_cipher_algo);
     badtype=PREFTYPE_SYM;
   }
 else if(opt.def_digest_algo
  && !algo_available(PREFTYPE_HASH,opt.def_digest_algo,((void*)0)))
   {
     badalg=digest_algo_to_string(opt.def_digest_algo);
     badtype=PREFTYPE_HASH;
   }
 else if(opt.cert_digest_algo
  && !algo_available(PREFTYPE_HASH,opt.cert_digest_algo,((void*)0)))
   {
     badalg=digest_algo_to_string(opt.cert_digest_algo);
     badtype=PREFTYPE_HASH;
   }
 else if(opt.compress_algo!=-1
  && !algo_available(PREFTYPE_ZIP,opt.compress_algo,((void*)0)))
   {
     badalg=compress_algo_to_string(opt.compress_algo);
     badtype=PREFTYPE_ZIP;
   }

 if(badalg)
   {
     switch(badtype)
       {
       case PREFTYPE_SYM:
  g10_log_info(gettext ("you may not use cipher algorithm `%s'" " while in %s mode\n"),

    badalg,compliance_option_string());
  break;
       case PREFTYPE_HASH:
  g10_log_info(gettext ("you may not use digest algorithm `%s'" " while in %s mode\n"),

    badalg,compliance_option_string());
  break;
       case PREFTYPE_ZIP:
  g10_log_info(gettext ("you may not use compression algorithm `%s'" " while in %s mode\n"),

    badalg,compliance_option_string());
  break;
       default:
  g10_log_bug0( "gpg.c" , 3258, __FUNCTION__ );
       }

     compliance_failure();
   }
      }


    if( use_random_seed ) {
 char *p = make_filename(opt.homedir, "random_seed", ((void*)0) );
 set_random_seed_file(p);
        if (!access (p, 0))
          register_secured_file (p);
 xfree(p);
    }



    if (!cmd && fpr_maybe_cmd)
      {
 set_cmd (&cmd, aListKeys);
      }

    if( cmd == aKMode || cmd == aKModeC ) {
 if( cmd == aKModeC ) {
     opt.fingerprint = 1;
     cmd = aKMode;
 }
 opt.list_sigs = 0;
 if( opt.verbose > 2 )
     opt.check_sigs++;
 if( opt.verbose > 1 )
     opt.list_sigs++;

 opt.verbose = opt.verbose > 1;
 g10_opt_verbose = opt.verbose;
    }


    if( opt.textmode == 2 && !detached_sig && opt.armor && cmd == aSign )
 cmd = aClearsign;

    if( opt.verbose > 1 )
 set_packet_list_mode(1);

    if (cmd == aGPGConfTest)
      g10_exit(0);
# 3314 "gpg.c"
    if( 0
        || (cmd != aDeArmor && cmd != aEnArmor
            && !(cmd == aKMode && argc == 2 )) )
      {
        if (0
            || (cmd != aCheckKeys && cmd != aListSigs && cmd != aListKeys
                && cmd != aVerify && cmd != aSym))
          {
            if (!sec_nrings || default_keyring)
              keydb_add_resource ("secring" "." "gpg", 4, 1);
            for (sl = sec_nrings; sl; sl = sl->next)
              keydb_add_resource ( sl->d, 0, 1 );
          }
 if( !nrings || default_keyring )
     keydb_add_resource ("pubring" "." "gpg", 4, 0);
 for(sl = nrings; sl; sl = sl->next )
     keydb_add_resource ( sl->d, sl->flags, 0 );
      }
    do { free_strlist((nrings)); (nrings) = ((void*)0) ; } while(0);
    do { free_strlist((sec_nrings)); (sec_nrings) = ((void*)0) ; } while(0);


    if( pwfd != -1 )
 read_passphrase_from_fd( pwfd );

    fname = argc? *argv : ((void*)0);

    if(fname && utf8_strings)
      opt.flags.utf8_filename=1;

    switch( cmd ) {
      case aPrimegen:
      case aPrintMD:
      case aPrintMDs:
      case aGenRandom:
      case aDeArmor:
      case aEnArmor:
 break;
      case aFixTrustDB:
      case aExportOwnerTrust: rc = setup_trustdb( 0, trustdb_name ); break;
      case aListTrustDB: rc = setup_trustdb( argc? 1:0, trustdb_name ); break;
      default:


        rc = setup_trustdb (opt.trust_model != TM_ALWAYS, trustdb_name);
        break;
      }
    if( rc )
 g10_log_error(gettext ("failed to initialize the TrustDB: %s\n"), g10_errstr(rc));


    switch (cmd)
      {
      case aStore:
      case aSym:
      case aSign:
      case aSignSym:
      case aClearsign:
        if (!opt.quiet && any_explicit_recipient)
          g10_log_info (gettext ("WARNING: recipients (-r) given " "without using public key encryption\n"));

 break;
      default:
        break;
      }

    switch( cmd )
      {
      case aStore:
 if( argc > 1 )
     wrong_args(gettext ("--store [filename]"));
 if( (rc = encode_store(fname)) )
     g10_log_error ("storing `%s' failed: %s\n",
                       print_fname_stdin(fname),g10_errstr(rc) );
 break;
      case aSym:
 if( argc > 1 )
     wrong_args(gettext ("--symmetric [filename]"));
 if( (rc = encode_symmetric(fname)) )
            g10_log_error (gettext ("symmetric encryption of `%s' failed: %s\n"),
                        print_fname_stdin(fname),g10_errstr(rc) );
 break;

      case aEncr:
 if(multifile)
   encode_crypt_files(argc, argv, remusr);
 else
   {
     if( argc > 1 )
       wrong_args(gettext ("--encrypt [filename]"));
     if( (rc = encode_crypt(fname,remusr,0)) )
       g10_log_error("%s: encryption failed: %s\n",
   print_fname_stdin(fname), g10_errstr(rc) );
   }
 break;

      case aEncrSym:




 if( argc > 1 )
   wrong_args(gettext ("--symmetric --encrypt [filename]"));
 else if(opt.s2k_mode==0)
   g10_log_error(gettext ("you cannot use --symmetric --encrypt" " with --s2k-mode 0\n"));

 else if((opt.compliance==CO_PGP2) || (opt.compliance==CO_PGP6) || (opt.compliance==CO_PGP7) || (opt.compliance==CO_RFC1991 || opt.compliance==CO_PGP2))
   g10_log_error(gettext ("you cannot use --symmetric --encrypt" " while in %s mode\n"),compliance_option_string());

 else
   {
     if( (rc = encode_crypt(fname,remusr,1)) )
       g10_log_error("%s: encryption failed: %s\n",
   print_fname_stdin(fname), g10_errstr(rc) );
   }
 break;

      case aSign:
 sl = ((void*)0);
 if( detached_sig ) {
     for( ; argc; argc--, argv++ )
  add_to_strlist( &sl, *argv );
 }
 else {
     if( argc > 1 )
  wrong_args(gettext ("--sign [filename]"));
     if( argc ) {
  sl = xmalloc_clear( sizeof *sl + strlen(fname));
  strcpy(sl->d, fname);
     }
 }
 if( (rc = sign_file( sl, detached_sig, locusr, 0, ((void*)0), ((void*)0))) )
     g10_log_error("signing failed: %s\n", g10_errstr(rc) );
 free_strlist(sl);
 break;

      case aSignEncr:
 if( argc > 1 )
     wrong_args(gettext ("--sign --encrypt [filename]"));
 if( argc ) {
     sl = xmalloc_clear( sizeof *sl + strlen(fname));
     strcpy(sl->d, fname);
 }
 else
     sl = ((void*)0);
 if( (rc = sign_file(sl, detached_sig, locusr, 1, remusr, ((void*)0))) )
     g10_log_error("%s: sign+encrypt failed: %s\n",
        print_fname_stdin(fname), g10_errstr(rc) );
 free_strlist(sl);
 break;

      case aSignEncrSym:
 if( argc > 1 )
     wrong_args(gettext ("--symmetric --sign --encrypt [filename]"));
 else if(opt.s2k_mode==0)
   g10_log_error(gettext ("you cannot use --symmetric --sign --encrypt" " with --s2k-mode 0\n"));

 else if((opt.compliance==CO_PGP2) || (opt.compliance==CO_PGP6) || (opt.compliance==CO_PGP7) || (opt.compliance==CO_RFC1991 || opt.compliance==CO_PGP2))
   g10_log_error(gettext ("you cannot use --symmetric --sign --encrypt" " while in %s mode\n"),compliance_option_string());

 else
   {
     if( argc )
       {
  sl = xmalloc_clear( sizeof *sl + strlen(fname));
  strcpy(sl->d, fname);
       }
     else
       sl = ((void*)0);
     if( (rc = sign_file(sl, detached_sig, locusr, 2, remusr, ((void*)0))) )
       g10_log_error("%s: symmetric+sign+encrypt failed: %s\n",
   print_fname_stdin(fname), g10_errstr(rc) );
     free_strlist(sl);
   }
 break;

      case aSignSym:
 if (argc > 1)
     wrong_args(gettext ("--sign --symmetric [filename]"));
 rc = sign_symencrypt_file (fname, locusr);
        if (rc)
     g10_log_error("%s: sign+symmetric failed: %s\n",
                      print_fname_stdin(fname), g10_errstr(rc) );
 break;

      case aClearsign:
 if( argc > 1 )
     wrong_args(gettext ("--clearsign [filename]"));
 if( (rc = clearsign_file(fname, locusr, ((void*)0))) )
     g10_log_error("%s: clearsign failed: %s\n",
                      print_fname_stdin(fname), g10_errstr(rc) );
 break;

      case aVerify:
 if(multifile)
   {
     if( (rc = verify_files( argc, argv ) ))
       g10_log_error("verify files failed: %s\n", g10_errstr(rc) );
   }
 else
   {
     if( (rc = verify_signatures( argc, argv ) ))
       g10_log_error("verify signatures failed: %s\n", g10_errstr(rc) );
   }
 break;

      case aDecrypt:
        if(multifile)
   decrypt_messages(argc, argv);
 else
   {
     if( argc > 1 )
       wrong_args(gettext ("--decrypt [filename]"));
     if( (rc = decrypt_message( fname ) ))
       g10_log_error("decrypt_message failed: %s\n", g10_errstr(rc) );
   }
 break;

      case aSignKey:
 if( argc != 1 )
   wrong_args(gettext ("--sign-key user-id"));

      case aLSignKey:
 if( argc != 1 )
   wrong_args(gettext ("--lsign-key user-id"));


 sl=((void*)0);

 if(cmd==aSignKey)
   append_to_strlist(&sl,"sign");
 else if(cmd==aLSignKey)
   append_to_strlist(&sl,"lsign");
 else
   g10_log_bug0( "gpg.c" , 3548, __FUNCTION__ );

 append_to_strlist( &sl, "save" );
 username = make_username( fname );
 keyedit_menu(username, locusr, sl, 0, 0 );
 xfree(username);
 free_strlist(sl);
 break;

      case aEditKey:
 if( !argc )
     wrong_args(gettext ("--edit-key user-id [commands]"));
 username = make_username( fname );
 if( argc > 1 ) {
     sl = ((void*)0);
     for( argc--, argv++ ; argc; argc--, argv++ )
  append_to_strlist( &sl, *argv );
     keyedit_menu( username, locusr, sl, 0, 1 );
     free_strlist(sl);
 }
 else
     keyedit_menu(username, locusr, ((void*)0), 0, 1 );
 xfree(username);
 break;

      case aDeleteKeys:
      case aDeleteSecretKeys:
      case aDeleteSecretAndPublicKeys:
 sl = ((void*)0);



 for( ; argc; argc-- )
   add_to_strlist2( &sl, argv[argc-1], utf8_strings );
 delete_keys(sl,cmd==aDeleteSecretKeys,cmd==aDeleteSecretAndPublicKeys);
 free_strlist(sl);
 break;

      case aCheckKeys:
 opt.check_sigs = 1;
      case aListSigs:
 opt.list_sigs = 1;
      case aListKeys:
 sl = ((void*)0);
 for( ; argc; argc--, argv++ )
     add_to_strlist2( &sl, *argv, utf8_strings );
 public_key_list( sl );
 free_strlist(sl);
 break;
      case aListSecretKeys:
 sl = ((void*)0);
 for( ; argc; argc--, argv++ )
     add_to_strlist2( &sl, *argv, utf8_strings );
 secret_key_list( sl );
 free_strlist(sl);
 break;

      case aKMode:
 if( argc < 2 ) {
     sl = ((void*)0);
     if (argc && **argv)
  add_to_strlist2( &sl, *argv, utf8_strings );
     public_key_list( sl );
     free_strlist(sl);
 }
 else if( argc == 2 ) {
     if( access( argv[1], 4 ) ) {
  g10_log_error(gettext ("can't open `%s': %s\n"),
          print_fname_stdin(argv[1]), strerror((*__errno_location())));
     }
     else {


  keydb_add_resource( argv[1], 0, 0 );
  sl = ((void*)0);
  if (**argv)
      add_to_strlist2( &sl, *argv, utf8_strings );
  public_key_list( sl );
  free_strlist(sl);
     }
 }
 else
     wrong_args(gettext ("-k[v][v][v][c] [user-id] [keyring]") );
 break;

      case aKeygen:
 if( opt.batch ) {
     if( argc > 1 )
  wrong_args("--gen-key [parameterfile]");
     generate_keypair( argc? *argv : ((void*)0), ((void*)0), ((void*)0) );
 }
 else {
     if( argc )
  wrong_args("--gen-key");
     generate_keypair(((void*)0), ((void*)0), ((void*)0));
 }
 break;

      case aFastImport:
        opt.import_options |= (1<<2);
      case aImport:
 import_keys( argc? argv:((void*)0), argc, ((void*)0), opt.import_options );
 break;






      case aExport:
      case aSendKeys:
      case aRecvKeys:
 sl = ((void*)0);
 for( ; argc; argc--, argv++ )
     append_to_strlist2( &sl, *argv, utf8_strings );
 if( cmd == aSendKeys )
     rc=keyserver_export( sl );
 else if( cmd == aRecvKeys )
     rc=keyserver_import( sl );
 else
     rc=export_pubkeys( sl, opt.export_options );
 if(rc)
   {
     if(cmd==aSendKeys)
       g10_log_error(gettext ("keyserver send failed: %s\n"),g10_errstr(rc));
     else if(cmd==aRecvKeys)
       g10_log_error(gettext ("keyserver receive failed: %s\n"),g10_errstr(rc));
     else
       g10_log_error(gettext ("key export failed: %s\n"),g10_errstr(rc));
   }
 free_strlist(sl);
 break;

     case aSearchKeys:
 sl = ((void*)0);
 for( ; argc; argc--, argv++ )
   append_to_strlist2( &sl, *argv, utf8_strings );
 rc=keyserver_search( sl );
 if(rc)
   g10_log_error(gettext ("keyserver search failed: %s\n"),g10_errstr(rc));
 free_strlist(sl);
 break;

      case aRefreshKeys:
 sl = ((void*)0);
 for( ; argc; argc--, argv++ )
     append_to_strlist2( &sl, *argv, utf8_strings );
 rc=keyserver_refresh(sl);
 if(rc)
   g10_log_error(gettext ("keyserver refresh failed: %s\n"),g10_errstr(rc));
 free_strlist(sl);
 break;

      case aFetchKeys:
 sl = ((void*)0);
 for( ; argc; argc--, argv++ )
     append_to_strlist2( &sl, *argv, utf8_strings );
 rc=keyserver_fetch(sl);
 if(rc)
   g10_log_error("key fetch failed: %s\n",g10_errstr(rc));
 free_strlist(sl);
 break;

      case aExportSecret:
 sl = ((void*)0);
 for( ; argc; argc--, argv++ )
     add_to_strlist2( &sl, *argv, utf8_strings );
 export_seckeys( sl );
 free_strlist(sl);
 break;

      case aExportSecretSub:
 sl = ((void*)0);
 for( ; argc; argc--, argv++ )
     add_to_strlist2( &sl, *argv, utf8_strings );
 export_secsubkeys( sl );
 free_strlist(sl);
 break;

      case aGenRevoke:
 if( argc != 1 )
     wrong_args("--gen-revoke user-id");
 username = make_username(*argv);
 gen_revoke( username );
 xfree( username );
 break;

      case aDesigRevoke:
 if( argc != 1 )
     wrong_args("--desig-revoke user-id");
 username = make_username(*argv);
 gen_desig_revoke( username, locusr );
 xfree( username );
 break;

      case aDeArmor:
 if( argc > 1 )
     wrong_args("--dearmor [file]");
 rc = dearmor_file( argc? *argv: ((void*)0) );
 if( rc )
     g10_log_error(gettext ("dearmoring failed: %s\n"), g10_errstr(rc));
 break;

      case aEnArmor:
 if( argc > 1 )
     wrong_args("--enarmor [file]");
 rc = enarmor_file( argc? *argv: ((void*)0) );
 if( rc )
     g10_log_error(gettext ("enarmoring failed: %s\n"), g10_errstr(rc));
 break;


      case aPrimegen:
 { int mode = argc < 2 ? 0 : atoi(*argv);

     if( mode == 1 && argc == 2 ) {
  mpi_print( (stdout), generate_public_prime( atoi(argv[1]) ), 1);
     }
     else if( mode == 2 && argc == 3 ) {
  mpi_print( (stdout), generate_elg_prime(
          0, atoi(argv[1]),
          atoi(argv[2]), ((void*)0),((void*)0) ), 1);
     }
     else if( mode == 3 && argc == 3 ) {
  MPI *factors;
  mpi_print( (stdout), generate_elg_prime(
          1, atoi(argv[1]),
          atoi(argv[2]), ((void*)0),&factors ), 1);
  putchar('\n');
  mpi_print( (stdout), factors[0], 1 );
     }
     else if( mode == 4 && argc == 3 ) {
  MPI g = mpi_alloc(1);
  mpi_print( (stdout), generate_elg_prime(
       0, atoi(argv[1]),
       atoi(argv[2]), g, ((void*)0) ), 1);
  putchar('\n');
  mpi_print( (stdout), g, 1 );
  mpi_free(g);
     }
     else
  wrong_args("--gen-prime mode bits [qbits] ");
     putchar('\n');
 }
 break;

      case aGenRandom:
 {
     int level = argc ? atoi(*argv):0;
     int count = argc > 1 ? atoi(argv[1]): 0;
     int endless = !count;

     if( argc < 1 || argc > 2 || level < 0 || level > 2 || count < 0 )
  wrong_args("--gen-random 0|1|2 [count]");

     while( endless || count ) {
  byte *p;




  size_t n = !endless && count < 99? count : 99;

  p = get_random_bits( n*8, level, 0);



                if (opt.armor) {
                    char *tmp = make_radix64_string (p, n);
                    fputs (tmp, (stdout));
                    xfree (tmp);
                    if (n%3 == 1)
                      putchar ('=');
                    if (n%3)
                      putchar ('=');
                } else {
                    fwrite( p, n, 1, (stdout) );
                }
  xfree(p);
  if( !endless )
      count -= n;
     }
            if (opt.armor)
                putchar ('\n');
 }
 break;

      case aPrintMD:
 if( argc < 1)
     wrong_args("--print-md algo [files]");
 {
     int all_algos = (**argv=='*' && !(*argv)[1]);
     int algo = all_algos? 0 : string_to_digest_algo(*argv);

     if( !algo && !all_algos )
  g10_log_error(gettext ("invalid hash algorithm `%s'\n"), *argv );
     else {
  argc--; argv++;
  if( !argc )
      print_mds(((void*)0), algo);
  else {
      for(; argc; argc--, argv++ )
   print_mds(*argv, algo);
  }
     }
 }
 break;

      case aPrintMDs:
 if( !argc )
     print_mds(((void*)0),0);
 else {
     for(; argc; argc--, argv++ )
  print_mds(*argv,0);
 }
 break;

      case aListTrustDB:
 if( !argc )
     list_trustdb(((void*)0));
 else {
     for( ; argc; argc--, argv++ )
  list_trustdb( *argv );
 }
 break;

      case aUpdateTrustDB:
 if( argc )
     wrong_args("--update-trustdb");
 update_trustdb();
 break;

      case aCheckTrustDB:

        check_trustdb();
 break;

      case aFixTrustDB:
        how_to_fix_the_trustdb ();
 break;

      case aListTrustPath:
 if( !argc )
     wrong_args("--list-trust-path <user-ids>");
 for( ; argc; argc--, argv++ ) {
     username = make_username( *argv );
     list_trust_path( username );
     xfree(username);
 }
 break;

      case aExportOwnerTrust:
 if( argc )
     wrong_args("--export-ownertrust");
 export_ownertrust();
 break;

      case aImportOwnerTrust:
 if( argc > 1 )
     wrong_args("--import-ownertrust [file]");
 import_ownertrust( argc? *argv:((void*)0) );
 break;

      case aPipeMode:
        if ( argc )
            wrong_args ("--pipemode");
        run_in_pipemode ();
        break;

      case aRebuildKeydbCaches:
        if (argc)
            wrong_args ("--rebuild-keydb-caches");
        keydb_rebuild_caches (1);
        break;


      case aCardStatus:
        if (argc)
            wrong_args ("--card-status");
        card_status ((stdout), ((void*)0), 0);
        break;

      case aCardEdit:
        if (argc) {
            sl = ((void*)0);
            for (argc--, argv++ ; argc; argc--, argv++)
                append_to_strlist (&sl, *argv);
            card_edit (sl);
            free_strlist (sl);
 }
        else
            card_edit (((void*)0));
        break;

      case aChangePIN:
        if (!argc)
            change_pin (0,1);
        else if (argc == 1)
            change_pin (atoi (*argv),1);
        else
        wrong_args ("--change-pin [no]");
        break;


      case aListConfig:
 {
   char *str=collapse_args(argc,argv);
   list_config(str);
   xfree(str);
 }
 break;

      case aListPackets:
      default:
 if( argc > 1 )
     wrong_args(gettext ("[filename]"));

 if( !fname && !opt.outfile && isatty( fileno((stdin)) )
  && isatty( fileno((stdout)) ) && isatty( fileno((stderr)) ) )
     g10_log_info(gettext ("Go ahead and type your message ...\n"));

 a = iobuf_open(fname);
        if (a && is_secured_file (iobuf_get_fd (a)))
          {
            iobuf_close (a);
            a = ((void*)0);
            (*__errno_location()) = (63);
          }
 if( !a )
     g10_log_error(gettext ("can't open `%s'\n"), print_fname_stdin(fname));
 else {

     if( !opt.no_armor ) {
  if( use_armor_filter( a ) ) {
      memset( &afx, 0, sizeof afx);
      iobuf_push_filter( a, armor_filter, &afx );
  }
     }
     if( cmd == aListPackets ) {
  opt.list_packets=1;
  set_packet_list_mode(1);
     }
     rc = proc_packets(((void*)0), a );
     if( rc )
  g10_log_error("processing message failed: %s\n", g10_errstr(rc) );
     iobuf_close(a);
 }
 break;
      }


    do { free_strlist((remusr)); (remusr) = ((void*)0) ; } while(0);
    do { free_strlist((locusr)); (locusr) = ((void*)0) ; } while(0);
    g10_exit(0);
    return 8;
}


void
g10_exit( int rc )
{

    card_close ();

    update_random_seed_file();
    if( opt.debug & 128 ) {
 m_print_stats("on exit");
 random_dump_stats();
    }
    if( opt.debug )
 secmem_dump_stats();
    secmem_term();
    rc = rc? rc : log_get_errorcount(0)? 2 :
   g10_errors_seen? 1 : 0;
    exit(rc );
}





static void
print_hex( MD_HANDLE md, int algo, const char *fname )
{
  int i,n,count,indent=0;
  const byte *p;

  if(fname)
    indent=printf("%s: ",fname);

  if(indent>40)
    {
      printf("\n");
      indent=0;
    }

  if(algo==3)
    indent+=printf("RMD160 = ");
  else if(algo>0)
    indent+=printf("%6s = ",digest_algo_to_string(algo));
  else
    algo=abs(algo);

  count=indent;

  p = md_read( md, algo );
  n = md_digest_length(algo);

  count+=printf("%02X",*p++);

  for(i=1;i<n;i++,p++)
    {
      if(n==16)
 {
   if(count+2>79)
     {
       printf("\n%*s",indent," ");
       count=indent;
     }
   else
     count+=printf(" ");

   if(!(i%8))
     count+=printf(" ");
 }
      else if (n==20)
 {
   if(!(i%2))
     {
       if(count+4>79)
  {
    printf("\n%*s",indent," ");
    count=indent;
  }
       else
  count+=printf(" ");
     }

   if(!(i%10))
     count+=printf(" ");
 }
      else
 {
   if(!(i%4))
     {
       if(count+8>79)
  {
    printf("\n%*s",indent," ");
    count=indent;
  }
       else
  count+=printf(" ");
     }
 }

      count+=printf("%02X",*p);
    }

  printf("\n");
}

static void
print_hashline( MD_HANDLE md, int algo, const char *fname )
{
    int i, n;
    const byte *p;

    if ( fname ) {
        for (p = fname; *p; p++ ) {
            if ( *p <= 32 || *p > 127 || *p == ':' || *p == '%' )
                printf("%%%02X", *p );
            else
                putchar( *p );
        }
    }
    putchar(':');
    printf("%d:", algo );
    p = md_read( md, algo );
    n = md_digest_length(algo);
    for(i=0; i < n ; i++, p++ )
        printf("%02X", *p );
    putchar(':');
    putchar('\n');
}

static void
print_mds( const char *fname, int algo )
{
    FILE *fp;
    char buf[1024];
    size_t n;
    MD_HANDLE md;

    if( !fname ) {
 fp = (stdin);



    }
    else {
 fp = fopen( fname, "rb" );
        if (fp && is_secured_file (fileno (fp)))
          {
            fclose (fp);
            fp = ((void*)0);
            (*__errno_location()) = (63);
          }
    }
    if( !fp ) {
 g10_log_error("%s: %s\n", fname?fname:"[stdin]", strerror((*__errno_location())) );
 return;
    }

    md = md_open( 0, 0 );
    if( algo )
 md_enable( md, algo );
    else {
 md_enable( md, 1 );
 md_enable( md, 2 );
 md_enable( md, 3 );

 md_enable( md, 11 );
 md_enable( md, 8 );


 md_enable( md, 9 );
 md_enable( md, 10 );

    }

    while( (n=fread( buf, 1, (sizeof(buf)/sizeof((buf)[0])), fp )) )
 md_write( md, buf, n );
    if( ferror(fp) )
 g10_log_error("%s: %s\n", fname?fname:"[stdin]", strerror((*__errno_location())) );
    else {
 md_final(md);
        if ( opt.with_colons ) {
            if ( algo )
                print_hashline( md, algo, fname );
            else {
                print_hashline( md, 1, fname );
                print_hashline( md, 2, fname );
                print_hashline( md, 3, fname );

                print_hashline( md, 11, fname );
                print_hashline( md, 8, fname );


  print_hashline( md, 9, fname );
  print_hashline( md, 10, fname );

            }
        }
        else {
            if( algo )
        print_hex(md,-algo,fname);
            else {
                print_hex( md, 1, fname );
                print_hex( md, 2, fname );
                print_hex( md, 3, fname );

                print_hex( md, 11, fname );
                print_hex( md, 8, fname );


  print_hex( md, 9, fname );
  print_hex( md, 10, fname );

            }
        }
    }
    md_close(md);

    if( fp != (stdin) )
 fclose(fp);
}







static void
add_notation_data( const char *string, int which )
{
  struct notation *notation;

  notation=string_to_notation(string,utf8_strings);
  if(notation)
    {
      if(which)
 {
   notation->next=opt.cert_notations;
   opt.cert_notations=notation;
 }
      else
 {
   notation->next=opt.sig_notations;
   opt.sig_notations=notation;
 }
    }
}

static void
add_policy_url( const char *string, int which )
{
  unsigned int i,critical=0;
  STRLIST sl;

  if(*string=='!')
    {
      string++;
      critical=1;
    }

  for(i=0;i<strlen(string);i++)
    if( !(0 ? isascii(string[i]) : (unsigned)(string[i]) < 128) || iscntrl(string[i]))
      break;

  if(i==0 || i<strlen(string))
    {
      if(which)
 g10_log_error(gettext ("the given certification policy URL is invalid\n"));
      else
 g10_log_error(gettext ("the given signature policy URL is invalid\n"));
    }

  if(which)
    sl=add_to_strlist( &opt.cert_policy_url, string );
  else
    sl=add_to_strlist( &opt.sig_policy_url, string );

  if(critical)
    sl->flags |= 1;
}

static void
add_keyserver_url( const char *string, int which )
{
  unsigned int i,critical=0;
  STRLIST sl;

  if(*string=='!')
    {
      string++;
      critical=1;
    }

  for(i=0;i<strlen(string);i++)
    if( !(0 ? isascii(string[i]) : (unsigned)(string[i]) < 128) || iscntrl(string[i]))
      break;

  if(i==0 || i<strlen(string))
    {
      if(which)
 g10_log_bug0( "gpg.c" , 4304, __FUNCTION__ );
      else
 g10_log_error(gettext ("the given preferred keyserver URL is invalid\n"));
    }

  if(which)
    g10_log_bug0( "gpg.c" , 4310, __FUNCTION__ );
  else
    sl=add_to_strlist( &opt.sig_keyserver_url, string );

  if(critical)
    sl->flags |= 1;
}
